{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"/:\\ gitStream","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p>"},{"location":"#ai-powered-productivity-with-linearbs-ai","title":"AI-Powered Productivity with LinearB's AI","text":"<p>Enhance your pull request experience with our new AI capabilities using LinearB's AI services. Automatically generate PR descriptions, perform comprehensive code reviews, and more to improve efficiency and productivity.</p> <p></p> <p>Add PR Description Using LinearB's AI</p> <p>Automatically generate and append a concise, AI-generated description to a pull request to ensure all PRs include meaningful and helpful descriptions, improving review efficiency.</p> <p></p> <p>Use LinearB's AI for a Comprehensive Code Review</p> <p>Leverage LinearB's AI to automatically review introduced changes to the code, ensuring high-quality code reviews and reducing the manual effort required.</p>"},{"location":"#features","title":"Features","text":"<p>Auto-Merge PRs</p> <p>Not all PRs need extensive review policies that loop in multiple experts. gitStream lets you auto-merge safe changes, small fixes, PRs from trusted teams, and anything else you want to unblock the review process to keep your team focused on their work.</p> <p></p> <p>Contextual Labels</p> <p>Reduce the mental burden of code reviews with labels that provide a high degree of context. Indicate an estimated time to review or flag potential issues with Jira information, missing tests, deleted files, and more.</p> <p></p> <p>Review Assignment</p> <p>Identifying the correct people to review a PR can take time, particularly for complex projects and repos requiring deep expertise. Assign code experts to review complex PRs, notify your security team about sensitive changes, and automatically assign reviewers based on the contents of the PR.</p> <p></p> <p>Automated Change Requests</p> <p>Reduce code review noise by catching issues before anyone invests precious time. Flag deprecated components, missing data objects, off-limits code, and other problems that need to be addressed before assigning code reviewers.</p> <p>Build Your First Automation in 2 Minutes</p>  GitHub GitHub Server GitLab Bitbucket <ol> <li>Install gitStream for free in GitHub</li> <li>Configure your repository using the instructions for GitHub. This will guide you through setting up your first automations.</li> </ol> <p>That's it! Now sit back and watch gitStream run automation rules on your next PR.</p> <p>Tip: Install gitStream for your entire organization</p> <p>gitStream can be installed for one repo, specific repos, or all repos in your organization. We recommend installing for all because it will ensure all new repos are able to use gitStream. You can change this setting at any time in the future.</p> <ol> <li>Create and install a Custom GitHub App for Self-Hosted GitHub Server</li> <li>Login to the LinearB app. Navigate to Company Settings -&gt; Git<ol> <li>Make sure the GHES is integrated with LinearB</li> <li>Connect gitStream to the GHES integration by pressing the \"Connect gitStream\" button</li> <li>Connect the repositories to gitStream by selecting the checkbox under the \"gitStream\" column (for org level installation, <code>cm</code> repo must be selected)</li> </ol> </li> <li>Configure your repository using the instructions for GitHub. This will guide you through setting up your first automations.</li> </ol> <p>That's it! Now sit back and watch gitStream run automation rules on your next PR.</p> <p>Tip: Install gitStream for your entire organization</p> <p>gitStream can be installed for one repo, specific repos, or all repos in your organization. We recommend installing for all because it will ensure all new repos are able to use gitStream. You can change this setting at any time in the future.</p> <ol> <li>Login, or create a free account on the LinearB app.</li> <li>Connect gitStream to your GitLab repos by following the steps described here.</li> </ol> <p>That's it! Now sit back and watch gitStream run automation rules on your next PR.</p> <ol> <li>Login, or create a free account on the LinearB app.</li> <li>Connect gitStream to your Bitbucket repos by following the steps described in the Bitbucket installation guide.</li> </ol> <p>That's it! Now sit back and watch gitStream run automation rules on your next PR.</p> <p>Automation limits for free accounts</p> <p>Free accounts have a monthly cap on PRs that can trigger gitStream automations.</p> <ul> <li>At 90% usage, a warning appears in PR comments.  </li> <li>Once the limit is reached, new PRs will not run automations and the gitStream check will be concluded as <code>Skipped</code>.  </li> <li>Limits reset at the start of each month.</li> </ul> <p>\ud83d\udd17 Learn more: Automation Limits</p>"},{"location":"#get-involved","title":"Get Involved","text":"<p>Want to report a bug, request a new feature, ask a question, get updates for new features, or propose a new configuration for the automation library? Join us on GitHub.</p>"},{"location":"automation-actions/","title":"Automation actions","text":"<p>Actions are the end results of the automation described in your <code>.cm</code> file.</p> <p>Legend</p> <p>The icons indicate the availability status of each action.</p> <ul> <li> Supported on GitHub</li> <li> Supported on GitLab</li> <li> Supported on Bitbucket</li> <li> Open beta - Feature is under development and currently available for all</li> </ul>"},{"location":"automation-actions/#overview","title":"Overview","text":"<p><code>send-http-request</code> is executed immediately after the evaluation of the condition. For all other actions, gitStream executes the actions in the order they are listed per automation. If an action result fails, the following actions will not be executed.</p> <ul> <li><code>add-code-comment</code> </li> <li><code>add-comment</code> </li> <li><code>add-github-check</code> </li> <li><code>add-label</code> </li> <li><code>add-labels</code> </li> <li><code>add-reviewers</code> </li> <li><code>add-thread</code> </li> <li><code>approve</code> </li> <li><code>change-pr-state</code> </li> <li><code>close</code> </li> <li><code>code-review</code> </li> <li><code>describe-changes</code> </li> <li><code>explain-code-experts</code> </li> <li><code>merge</code> </li> <li><code>request-changes</code> </li> <li><code>require-reviewers</code> </li> <li><code>run-github-workflow</code> </li> <li><code>send-http-request</code> </li> <li><code>send-slack-message</code> </li> <li><code>set-required-approvals</code> </li> <li><code>update-description</code> </li> <li><code>update-title</code> </li> </ul> <p>Note</p> <p>Multiple actions can be listed in a single automation. The actions are invoked one by one.</p>"},{"location":"automation-actions/#dynamic-actions-arguments","title":"Dynamic actions arguments","text":"<p>Argument values support dynamic values using expressions based on Jinja2 syntax, and include gitStream context variables, for example:</p> <pre><code>automations:\npr_complexity:\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: \"Estimated {{ branch | estimatedReviewTime }} minutes to review\"\n</code></pre>"},{"location":"automation-actions/#reference","title":"Reference","text":""},{"location":"automation-actions/#add-code-comment","title":"<code>add-code-comment</code>","text":"<p>This action, once triggered, adds a single code comment to the PR.</p> <p>This is a managed action, when PR updates, the existing comments added by gitStream are re-evaluated, and those that are not applicable are removed.</p> Args Usage Type Description <code>comment</code> Required String Sets the comment, markdown is supported, including suggestion syntax (<code>suggestion \u2026</code>) <code>file_name</code> Required String The relative path to the file that necessitates the comment <code>start_line</code> Optional Integer The line (or the first line in multi-line comment)of the blob in the pull request diff that the comment applies to. If start_line is empty, the code comment should be on the file provided <code>end_line</code> Optional Integer For a multi-line comment, the last line of the range that your comment applies to. Must be equal to or larger than start_line example<pre><code>automations:\nsenior_review:\nif:\n- true\nrun:\n- action: add-code-comment@v1\nargs:\nfile_name: &lt;FILE&gt;\nstart_line: 20\ncomment: |\nMagic! Move it to a constant variable.\n</code></pre>"},{"location":"automation-actions/#add-comment","title":"<code>add-comment</code>","text":"<p>This action, once triggered, adds a comment to the PR.</p> <p>This is a managed action, when a PR updates, the existing comments that were added by gitStream are re-evaluated and those that are not applicable are removed.</p> Args Usage Type Description <code>comment</code> Required String Sets the comment, markdown is supported example<pre><code>automations:\nsenior_review:\nif:\n- {{ files | match(term='core/') | some }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nCore service update\n(Updates API)\n</code></pre>"},{"location":"automation-actions/#add-github-check","title":"<code>add-github-check</code>","text":"<p>This action, once triggered, adds a <code>completed</code> check with the specified conclusion to the listed checks in the PR.</p> Args Usage Type Description <code>check_name</code> Required String The check name to be added to the checks list on gitHub <code>conclusion</code> Required String The conclusion of the check. The value is one of the following: <code>action_required</code>, <code>cancelled</code>, <code>timed_out</code>, <code>failure</code>, <code>neutral</code>, <code>skipped</code>, <code>success</code> example<pre><code>automations:\n# Skip UI checks if the PR doesn't have a UI code changes\nskip_ui_check:\nif:\n- {{ not has.fe_code_changes }}\nrun:\n- action: add-github-check@v1\nargs:\ncheck_name: FE-tests\nconclusion: skipped\nhas:\nfe_code_changes: {{ files | match(regex=r/frontend\\//) | some }}\n</code></pre>"},{"location":"automation-actions/#add-label","title":"<code>add-label</code>","text":"<p>This action, once triggered, adds a label to the PR.</p> <p>This is a managed action, when a PR updates, the existing labels that were added by gitStream are re-evaluated and those that are not applicable are removed.</p> Args Usage Type Description <code>label</code> Required String The label text any string can work <code>color</code> Optional String The color in hex, for example: <code>'FEFEFE'</code> (you can also add <code>#</code> prefix <code>#FEFEFE</code>) example<pre><code>automations:\nsenior_review:\nif:\n- {{ files | match(term='api/') | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: api-change\n</code></pre>"},{"location":"automation-actions/#add-labels","title":"<code>add-labels</code>","text":"<p>This action, once triggered, adds a list of labels to the PR.</p> <p>This is a managed action, when a PR updates existing labels that were added by gitStream are re-evaluated and those that are not applicable are removed.</p> Args Usage Type Description <code>labels</code> Required [String] The list of text labels"},{"location":"automation-actions/#add-reviewers","title":"<code>add-reviewers</code>","text":"<p>This action, once triggered, sets a specific reviewer.</p> Args Usage Type Description <code>reviewers</code> Required [String] Sets required reviewers. Supports user names and teams. Teams notated by adding a prefix with the owner name e.g. <code>owner/team</code> <code>team_reviewers</code> Optional [String] Sets required team reviewers without a prefix <code>team</code> <code>unless_reviewers_set</code> Optional Bool When <code>true</code>, the reviewers are not added if the PR has already assigned reviewers. It is set to <code>false</code> by default <code>fail_on_error</code> Optional Bool When <code>true</code>, trying to assign illegal reviewers shall fail the automation, when <code>false</code> these errors are silently ignored. It is set to <code>true</code> by default <code>wait_for_all_checks</code> Optional Bool By default <code>false</code>. When <code>true</code>, the action will add reviewers only if all checks (except gitStream) are completed with <code>neutral</code>, <code>skipped</code>, or <code>success</code> conclusion example<pre><code>automations:\nsenior_review:\nif:\n- {{ files | match(term='src/ui/') }}\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: [popeye, olive, acme/team-a]\n</code></pre> <p>Enable Team Write Access</p> <p>If you want to assign teams as PR reviewers, you need to first make sure the team has write access to the repo in your organization's settings. For more info, refer to the GitHub instructions for managing team review settings.</p>"},{"location":"automation-actions/#add-thread","title":"<code>add-thread</code>","text":"<p>When this action is triggered, a new thread is added to the MR. gitStream can then preserve the thread state after each automation run, including the RESOLVE state and COMMENTS. If the rule's condition doesn't pass, gitStream will remove the thread completely.</p> Args Usage Type Description <code>comment</code> Required [String] The desired thread content <code>resolvable</code> Optional Bool By default, <code>true</code>. When set to <code>true</code>, gitStream will issue the thread once and retain all changes made to it by the user. Therefore, if the thread is resolved, it will stay resolved until the condition no longer applies. When set to <code>false</code>, gitStream will re-issue the thread after each automation run until the condition no longer applies. example<pre><code>automations:\nenforce_documentation:\nif:\n- true\nrun:\n- action: add-thread@v1\nargs:\ncomment: \"Please make sure this change request is documented before merging\"\n</code></pre>"},{"location":"automation-actions/#approve","title":"<code>approve</code>","text":"<p>This action, once triggered, approves the PR for merge.</p> <p>This is a managed action, when a PR updates existing approval by gitStream is re-evaluated and removed if no longer applicable.</p> example<pre><code>automations:\nsmall_change:\nif:\n- {{ source.diff.files | isFormattingChange }}\nrun:\n- action: approve@v1\n</code></pre>"},{"location":"automation-actions/#change-pr-state","title":"<code>change-pr-state</code>","text":"<p>This action, once triggered, updates the PR state between draft and ready for review.</p> <p>Explicit Triggers Required for Draft PRs</p> <p>Since gitStream does not run on draft PRs by default, this action requires the use of explicit triggers to function properly. Define triggers using the <code>on</code> parameter at the automation level to specify when the automation should evaluate draft PRs.</p> Args Usage Type Description <code>draft</code> Optional Bool When <code>true</code>, convert the PR to Draft. When <code>false</code>, mark the PR as Ready for review. example<pre><code>automations:\nready_for_review:\n# Explicit triggers required to work with draft PRs\non:\n- label_added\n- pr_created\nif:\n- true\nrun:\n- action: change-pr-state@v1\nargs:\ndraft: false\n</code></pre>"},{"location":"automation-actions/#close","title":"<code>close</code>","text":"<p>This action, once triggered, closes the PR without merging.</p> example<pre><code>automations:\nclose_ui_changes_by_non_ui:\nif:\n- {{ files | match(regex=r/src\\/views/) | some }}\n- {{ pr.author_teams | match(term='ui-team') | nope }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nPlease contact a member of `ui-team` team if you need to make changes to files in `src/views`\n- action: close@v1\n</code></pre>"},{"location":"automation-actions/#code-review","title":"<code>code-review</code>","text":"<p>This action, once triggered, reviews the code in the PR, and generates a comment with the identified issue, bugs, misconfigurations, and bad practices in the newly introduced code, with an option to approve the PR if no issues were found.</p> Args Usage Type Description <code>approve_on_LGTM</code> Optional Bool Approve this PR if no issues were found. Default is <code>false</code> <code>guidelines</code> Optional String Provides custom instructions to the AI model to tailor the code review. Can be inline text or loaded from a file using the <code>readFile()</code> function. <code>issues_limit</code> Optional Integer | <code>unlimited</code> Limits the number of issues included in the generated code review comment. Set to a positive integer (e.g., <code>10</code>) or <code>unlimited</code> to include all issues. Default is <code>3</code>. <p>This action returns outputs that can be used by subsequent automations through the <code>actions</code> context variable. Outputs available:</p> Output Type Description <code>is_LGTM</code> Bool <code>true</code> if the code review found no issues (looks good to me), <code>false</code> if issues were found <p>See <code>actions</code> for how to use the <code>actions</code> context variable to access outputs from this action in subsequent automations.</p> <p>Examples</p> <p>This example demonstrates using the <code>is_LGTM</code> output to automatically approve PRs that pass the AI code review:</p> example - auto-approve based on code review output<pre><code>automations:\n# First automation: Run AI code review\nai_code_review:\nif:\n- true\nrun:\n- action: code-review@v1\n# Second automation: Only runs if the AI review found no issues\nauto_approve_on_ai_lgtm:\nif:\n- {{ actions.ai_code_review.outputs.is_LGTM }}\nrun:\n- action: approve@v1\n</code></pre> <p>Automation Names with Hyphens</p> <p>If your automation name contains hyphens (e.g., <code>ai-code-review</code>), you must use bracket notation to access its outputs:</p> <p><code>{{ actions['ai-code-review'].outputs.is_LGTM }}  # use bracket notation</code></p> <p>This example shows how to use guidelines for AI review.</p> example - inline guidelines<pre><code>automations:\nlinearb_ai_review:\nif:\n- {{ not pr.draft }}\n- {{ not (is.bot_author or is.bot_branch) }}\nrun:\n- action: code-review@v1\nargs:\napprove_on_LGTM: {{ approve_pr_on_lgtm }} # optional\nguidelines: {{ guidelines | dump }} # optional\n# Define variables\napprove_pr_on_lgtm: false\n# Add your prompts to the review as inline text\nguidelines: |\n- Don't comment on using outdated dependencies\n- In Javascript\n- Make sure camelCase is used for variable names\n- Make sure PascalCase is used for class names\nis:\nbot_author: {{ pr.author | match(list=['github-actions', '_bot_', '[bot]', 'dependabot']) | some }}\nbot_branch: {{ branch.name | match(list=['renovate/']) | some }}\n</code></pre> <p>This example shows how to load guidelines from an external file and use them for the AI Review.</p> example - guidelines from file<pre><code>automations:\nlinearb_ai_review:\nif:\n- {{ not pr.draft }}\n- {{ not (is.bot_author or is.bot_branch) }}\nrun:\n- action: code-review@v1\nargs:\napprove_on_LGTM: false\nguidelines: {{ \"./REVIEW_RULES.md\" | readFile() | dump }}\nis:\nbot_author: {{ pr.author | match(list=['github-actions', '_bot_', '[bot]', 'dependabot']) | some }}\nbot_branch: {{ branch.name | match(list=['renovate/']) | some }}\n</code></pre> <p>This example shows how to combine organization-level and repository-level guidelines.</p> example - combined org + repo guidelines<pre><code>automations:\nlinearb_ai_review:\nif:\n- true\nrun:\n- action: code-review@v1\nargs:\nguidelines: |\nRepo {{ \"./repo_guidelines.md\" | readFile() }}\nOrg: {{ \"../cm/org_guidelines.md\" | readFile() }}\n</code></pre> <p>Iterative Guidelines Refinement with Playground</p> <p>To achieve the exact review behavior you want, use this iterative workflow:</p> <ol> <li>Start with the Playground</li> <li>Add specific guidelines e.g., \"Do not comment on formatting issues\"</li> <li>Run in the Playground with a reference PR from your repository</li> <li>Refine guidelines based on the results</li> <li>Repeat cycles 2-4 until you get the expected review behavior</li> <li>Deploy to your repository CM rules - The guidelines will now work consistently on real PRs</li> </ol> <p>Loading Guidelines from Files</p> Location Description File Placement Configuration Repository Root Files Guidelines file in your repository root Place your guidelines file (e.g., <code>REVIEW_RULES.md</code>) at the root of your repository <code>guidelines: {{ \"./REVIEW_RULES.md\" | readFile() | dump }}</code> CM Repository Files Organization-wide guidelines in central CM repository Place guidelines in your central CM repository <code>guidelines: {{ \"../cm/REVIEW_RULES.md\" | readFile() | dump }}</code> <p>The <code>dump</code> filter ensures proper YAML formatting when the file content is inserted into the configuration.</p> Files Excluded from AI Review <p>The following files are automatically excluded from the code review.</p> File type Filter type Values Data Extension <code>ini</code> <code>csv</code> <code>xls</code> <code>xlsx</code> <code>xlr</code> <code>doc</code> <code>docx</code> <code>txt</code> <code>pps</code> <code>ppt</code> <code>pptx</code> <code>dot</code> <code>dotx</code> <code>log</code> <code>tar</code> <code>rtf</code> <code>dat</code> <code>ipynb</code> <code>po</code> <code>profile</code> <code>object</code> <code>obj</code> <code>dxf</code> <code>twb</code> <code>bcsymbolmap</code> <code>tfstate</code> <code>pdf</code> <code>rbi</code> <code>pem</code> <code>crt</code> <code>svg</code> <code>png</code> <code>jpeg</code> <code>jpg</code> <code>ttf</code> <code>app</code> <code>bin</code> <code>bmp</code> <code>bz2</code> <code>class</code> <code>db</code> <code>dll</code> <code>dylib</code> <code>egg</code> <code>eot</code> <code>exe</code> <code>gif</code> <code>gitignore</code> <code>glif</code> <code>gradle</code> <code>gz</code> <code>ico</code> <code>jar</code> <code>lo</code> <code>lock</code> <code>mp3</code> <code>mp4</code> <code>nar</code> <code>o</code> <code>ogg</code> <code>otf</code> <code>p</code> <code>pickle</code> <code>pkl</code> <code>pyc</code> <code>pyd</code> <code>pyo</code> <code>rkt</code> <code>so</code> <code>ss</code> <code>tgz</code> <code>tsv</code> <code>war</code> <code>webm</code> <code>woff</code> <code>woff2</code> <code>xz</code> <code>zip</code> <code>zst</code> <code>snap</code> <code>lockb</code> Lock Regex <code>.*(yarn\\|gemfile\\|podfile\\|cargo\\|composer\\|pipfile\\|gopkg)\\.lock$</code> <code>.*gradle\\.lockfile$</code> <code>.*lock\\.sbt$</code> Build Regex <code>.*dist/.*\\\\.js</code> <code>.*build/.*\\\\.js</code> Data Regex <code>.*public/assets/.*\\\\.js</code> Lock File Name Programming Language Package Manager <code>package-lock.json</code> JavaScript npm <code>yarn.lock</code> JavaScript Yarn <code>npm-shrinkwrap.json</code> JavaScript npm <code>Pipfile.lock</code> Python pipenv <code>poetry.lock</code> Python Poetry <code>conda-lock.yml</code> Python conda <code>Gemfile.lock</code> Ruby Bundler <code>composer.lock</code> PHP Composer <code>packages.lock.json</code> .NET NuGet <code>project.assets.json</code> .NET .NET Core <code>pom.xml</code> Java Maven <code>Cargo.lock</code> Rust Cargo <code>mix.lock</code> Elixir Mix <code>pubspec.lock</code> Dart/Flutter pub <code>go.sum</code> Go Go modules <code>stack.yaml.lock</code> Haskell Stack <code>vcpkg.json</code> C++ vcpkg <code>conan.lock</code> C++ Conan <code>ivy.xml</code> Scala sbt/Ivy <code>project.clj</code> Clojure Leiningen <code>Podfile.lock</code> Swift/Objective-C CocoaPods <code>Cartfile.resolved</code> Swift/Objective-C Carthage <code>flake.lock</code> Nix Nix <code>pnpm-lock.yaml</code> JavaScript pnpm <p>Tip</p> <p>You can also filter more files, using <code>config.ignore_files</code>.</p>"},{"location":"automation-actions/#describe-changes","title":"<code>describe-changes</code>","text":"<p>This action, once triggered, leverages AI to generate a comprehensive summary of the changes in the PR and incorporates it into the PR description.</p> <p>The action automatically analyzes the code modifications to create a clear, high-level overview of what has been changed, making it easier for reviewers to understand the scope and purpose of the PR.</p> Args Usage Type Description <code>concat_mode</code> Optional String By default <code>replace</code>. The mode to add the changes description, can be <code>replace</code>, <code>append</code>, or <code>prepend</code> to the PR description <code>guidelines</code> Optional String Provides custom instructions to the AI model to tailor the generated description. <code>template</code> Optional String Specifies a template for the AI model to use and fill in when generating the PR description. example<pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlinearb_ai_description:\n# skip description for Draft PRs and PRs from bots\nif:\n- {{ not pr.draft }}\n- {{ not (is.bot_author or is.bot_branch) }}\nrun:\n- action: describe-changes@v1\nargs:\nconcat_mode: append\nguidelines: {{ guidelines }}\ntemplate: {{ TEMPLATE }}\nguidelines: |\nRemove all unnecessary checkboxes.\nTry to extract the Jira ticket from \"{{ branch.name }}\" or \"{{ pr.title }}\" and fill it into the template.\nJira ticket should be in format ABC-12345.\n# Load the PR template content from a file in the repository\nTEMPLATE: {{ \".github/PULL_REQUEST_TEMPLATE.md\" | readFile() | dump }}\nis:\nbot_author: {{ pr.author | match(list=['github-actions', '_bot_', '[bot]', 'dependabot']) | some }}\nbot_branch: {{ branch.name | match(list=['renovate/']) | some }}\n</code></pre> <p>Excluded Files</p> <p>The <code>describe-changes</code> action processes the same files as <code>code-review</code>. For details see <code>code-review</code>.</p>"},{"location":"automation-actions/#explain-code-experts","title":"<code>explain-code-experts</code>","text":"<p>This action, shall add a comment with codeExperts suggestion. If the comment already exists, the comment shall be edited.</p> Args Usage Type Description <code>lt</code> Optional Integer Filter the user list, keeping those below the specified threshold <code>gt</code> Optional Integer Filter the user list, keeping those above the specified threshold <code>verbose</code> Optional Bool When set to false then only shows the suggestion summary and skips the per file details (true by default) example<pre><code>automations:\ncode_experts:\nif:\n- true\nrun:\n- action: explain-code-experts@v1\nargs:\ngt: 10\n</code></pre> <p>Automatically assign code experts</p> <p>You can automatically assign code experts as reviewers by using the <code>add-reviewers</code> action with the <code>codeExperts</code> filter function:</p> <pre><code>automations:\ncode_experts:\nif:\n- true\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: {{ repo | codeExperts(gt=10) }}\n</code></pre> <p>For more information about the <code>codeExperts</code> filter function, see the filter functions documentation.</p> <p>Limit git history for code experts</p> <p>Use the <code>config.git_history_since</code> configuration to limit the git history analysis to commits after a specific date. This is useful for team transitions or when you want to focus on recent contributors only.</p>"},{"location":"automation-actions/#merge","title":"<code>merge</code>","text":"<p>Once triggered, merge the PR if possible. It can be set to wait for all checks to pass or only required ones.</p> Args Usage Type Description <code>wait_for_all_checks</code> Optional Bool By default <code>false</code>, so only Required checks can block merge, when <code>true</code> the action will merge after all checks are completed with <code>neutral</code>, <code>skipped</code>, or <code>success</code> conclusion (except gitStream itself) <code>rebase_on_merge</code> Optional Bool By default <code>false</code>, when merging use rebase mode <code>squash_on_merge</code> Optional Bool By default <code>false</code>, when merging use squash mode example<pre><code>automations:\nsmall_change:\nif:\n- {{ files | allDocs }}\nrun:\n- action: merge@v1\nargs:\nrebase_on_merge: true\n</code></pre>"},{"location":"automation-actions/#request-changes","title":"<code>request-changes</code>","text":"<p>This action, once triggered, requests changes on the PR. As long as request change is set, gitStream will block the PR merge.</p> <p>This is a managed action, when a PR updates an existing change request by gitStream is re-evaluated and removed if no longer applicable.</p> Args Usage Type Description <code>comment</code> Required [String] The desired request changes comment example<pre><code>automations:\ncatch_deprecated:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/^[+].*oldFetch/) | some }}\nrun:\n- action: request-changes@v1\nargs:\ncomment: |\nYou have used deprecated API `oldFetch`, use `newFetch` instead.\n</code></pre> <p>Attention</p> <p>To allow this action to block merge, The following settings should be set:</p> <p> Enable branch protection and set gitStream as a required check</p> <p> Enable the \"All threads must be resolved\" Merge check</p>"},{"location":"automation-actions/#require-reviewers","title":"<code>require-reviewers</code>","text":"<p>This action, once triggered, requires a specific reviewer approval. The PR/MR merge is blocked till approved by either of the listed users or teams.</p> Args Usage Type Description <code>reviewers</code> Required [String] Sets required reviewers. Supports user names and teams. Teams notated by adding a prefix with the owner name e.g. <code>owner/team</code>. Merge is blocked till approved by either of the listed users <code>also_assign</code> Optional Bool <code>true</code> by default, also assign the specified users as reviewers example<pre><code>automations:\nsenior_review:\nif:\n- {{ files | match(regex=r/src\\/ui\\//) | some }}\nrun:\n- action: require-reviewers@v1\nargs:\nreviewers: [popeye, olive, acme/team-a]\n</code></pre> <p>Attention</p> <p>To allow this action to block merge, The following settings should be set:</p> <p> Enable branch protection and set gitStream as a required check</p> <p> GitLab automatically blocks merge when this action is triggered</p> <p> Select \"Prevent a merge with unresolved merge checks\" under Branch restrictions</p>"},{"location":"automation-actions/#run-github-workflow","title":"<code>run-github-workflow</code>","text":"<p>This action, once triggered, will start a workflow dispatch automation with the option to add a check to the list of checks in the PR</p> Args Usage Type Description <code>workflow</code> Required String The ID or the path of the workflow dispatch. <code>owner</code> Optional String By default, the value of <code>repo.owner</code> context variable. The account owner of the repository. Case insensitive. <code>repo</code> Optional String By default, the value of <code>repo.name</code> context variable. The name of the repository without the <code>.git</code> extension. Case insensitive. <code>ref</code> Optional String By default, the value of <code>branch.name</code> context variable. The branch name. Case sensitive. <code>inputs</code> Optional String By default, an empty list. Key-Value list with the arguments to provide to the workflow <code>check_name</code> Optional String When added, after the workflow is complete, add the check name to the checks list on GitHub <code>stop_ongoing_workflow</code> Optional Bool By default, <code>false</code>. If the workflow already runs on the branch, When <code>true</code>: cancel the ongoing workflow before running the newly dispatched workflow. When <code>false</code>: wait for the old workflow to finish before dispatching a new one example<pre><code>automations:\nrun_workflow_dispatch:\non:\n- commit\nif:\n- {{ has.fe_code_changes }}\nrun:\n- action: run-github-workflow@v1\nargs:\nowner: {{ repo.owner }}\nrepo: {{ repo.name}}\nworkflow: .github/workflows/frontend-manual.yml\nref: {{ branch.name }}\ncheck_name: FE-tests\nhas:\nfe_code_changes: {{ files | match(regex=r/frontend\\//) | some }}\n</code></pre> <p>Attention</p> <ul> <li>This action will invoke the run of a workflow dispatch; thus, it might result in a significant GitHub action minutes charge.</li> <li>We encourage you to use this action with custom triggers</li> <li>To manually test the webhook dispatch, please run the workflow before using it with gitStream.</li> </ul>"},{"location":"automation-actions/#send-http-request","title":"<code>send-http-request</code>","text":"<p>The action, once triggered, sends an HTTP request to the specified URL</p> Args Usage Type Description <code>url</code> Required String The request URL <code>method</code> Optional String By default <code>GET</code>, the request method <code>headers</code> Optional [String] Empty by default (<code>[]</code>), Key-Value list of strings, which will be sent as the HTTP headers <code>user</code> Optional String Empty by default, format: <code>'username:password'</code>.  If used - adds a Basic-auth HTTP header, by setting the <code>Authorization</code> header. Using this arg will override any existing <code>Authorization</code> header that was set using <code>headers</code> <code>body</code> Optional String Empty by default, the data to be sent as the request body. Only applicable for request methods <code>PUT</code>, <code>POST</code>, <code>DELETE</code>, and <code>PATCH</code> <code>timeout</code> Optional String Empty by default (no timeout), the number of milliseconds before the request times out. When the time out is reached, the request will be aborted example<pre><code>automations:\nsend_webhook:\nif:\n- true\nrun:\n- action: send-http-request@v1\nargs:\nurl: \"http://WEBHOOK_URL\"\nmethod: POST\nheaders: '{\"Content-type\": \"application/json\"}'\nbody: '{\"text\": \"Hello, world!\"}'\n</code></pre>"},{"location":"automation-actions/#send-slack-message","title":"<code>send-slack-message</code>","text":"<p>The action, once triggered, sends a webhook with a message content to a Slack app. To use this action, create a Slack app with Incoming Webhooks enabled. gitStream uses the webhook URL to send the message.</p> Args Usage Type Description <code>message</code> Required String The message content <code>webhook_url</code> Optional String The webhook URL. Use the <code>env</code> variable to pass secrets example<pre><code>automations:\nsend_slack:\nif:\n- true\nrun:\n- action: send-slack-message@v1\nargs:\nmessage: \"Hello world :tada:.\"\nwebhook_url: \"{{ slack_webhook }}\"\nslack_webhook: {{ env.SLACK_WEBHOOK }}\n</code></pre>"},{"location":"automation-actions/#set-required-approvals","title":"<code>set-required-approvals</code>","text":"<p>This action, once triggered, blocks PR merge till the desired reviewers approve the PR. The actions fail the check to prevent the PR from merging.</p> Args Usage Type Description <code>approvals</code> Required Integer Sets the number of required reviewer approvals for merge for that PR example<pre><code>automations:\ndouble_review:\nif:\n- {{ files | match(regex=r/agent\\//) | some }}\nrun:\n- action: set-required-approvals@v1\nargs:\napprovals: 2\n</code></pre> <p>Attention</p> <p>To allow this action to block merge, The following settings should be set:</p> <p> Enable branch protection and set gitStream as a required check</p> <p> Select \"Prevent a merge with unresolved merge checks\" under Branch restrictions</p>"},{"location":"automation-actions/#update-description","title":"<code>update-description</code>","text":"<p>This action, when triggered, updates the PR description with new content.</p> <p>This is a managed action. When a PR updates, the existing comments that were added by gitStream are re-evaluated, and those that are not applicable are removed.</p> Args Usage Type Description <code>description</code> Required String Sets the PR description <code>concat_mode</code> Optional String <code>replace</code> by default, the mode to concatenate the new description with the existing one. Possible values: <code>prepend</code>, <code>append</code>, <code>replace</code> <p>For example, this automation updates the PR description with the ticket info if present in the PR title.</p> example<pre><code>automations:\nadd_jira_to_desc:\nif:\n- {{ has.jira_ticket_in_title and (not has.jira_ticket_in_desc) }}\nrun:\n- action: update-description@v1\nargs:\nconcat_mode: prepend\ndescription: |\n{{ jira_ticket_from_title }}\nhas:\njira_ticket_in_title: {{ pr.title | includes(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\njira_ticket_in_desc: {{ pr.description | includes(regex=r/atlassian.net\\/browse\\/\\w{1,}-\\d{3,4}/) }}\njira_ticket_from_title: {{ pr.title | capture(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\n</code></pre>"},{"location":"automation-actions/#update-title","title":"<code>update-title</code>","text":"<p>This action, when triggered, updates the PR title with new content.</p> <p>This is a managed action. When a PR updates, the existing comments that were added by gitStream are re-evaluated, and those that are not applicable are removed.</p> Args Usage Type Description <code>title</code> Required String Sets the PR title <code>concat_mode</code> Optional String <code>replace</code> by default, the mode to concatenate the new description with the existing one. Possible values: <code>prepend</code>, <code>append</code>, <code>replace</code> <p>For example, this automation updates the PR title with the ticket info if present in the PR title.</p> example<pre><code>automations:\nadd_jira_to_title:\nif:\n- {{ has.jira_ticket_in_desc and (not has.jira_ticket_in_title) }}\nrun:\n- action: update-title@v1\nargs:\nconcat_mode: prepend\ntitle: |\n{{ jira_ticket_from_desc }} -\nhas:\njira_ticket_in_title: {{ pr.title | includes(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\njira_ticket_in_desc: {{ pr.description | includes(regex=r/atlassian.net\\/browse\\/\\w{1,}-\\d{3,4}/) }}\njira_ticket_from_desc: {{ pr.description | capture(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\n</code></pre>"},{"location":"bitbucket-installation/","title":"How to Setup gitStream with Bitbucket Cloud","text":"<p>gitStream for Bitbucket Cloud is currently in beta</p> <p>To start automating your Bitbucket pull requests and enhancing your development workflow, please contact our product team to request access and receive setup instructions. We\u2019d love to hear your feedback and collaborate to improve this integration during the beta phase. Thank you for your interest!</p> <p>Prerequisites</p> <ol> <li>Bitbucket Cloud account</li> <li>Bitbucket Pipelines enabled</li> <li>Login, or create a free account on the LinearB app, and follow the steps to connect gitStream using a Bitbucket integration.</li> <li>A dedicated user for gitStream, whose name includes the term \"gitstream\".</li> <li>Allowed network connection between the runners and the following IPs:<ul> <li>13.56.203.235</li> <li>54.151.81.98</li> </ul> </li> </ol> Advanced: IP Allowlisting for gitStream <p>When setting up IP allowlists in Bitbucket, you're specifying which source IP addresses are permitted to interact with your repositories and APIs. This affects both gitStream and your CI/CD runners.</p> <p>There are two primary cases where this matters for gitStream:</p> <ol> <li>Webhook Event Handling by gitStream    When Bitbucket triggers a webhook event (e.g., a pull request opened), gitStream may need to make follow-up API calls to Bitbucket. This can include fetching additional metadata, posting comments to the PR, or performing other actions. These calls are made from the LinearB/gitStream service, which uses a fixed set of IP addresses. These IPs must be added to your Bitbucket allowlist to ensure proper operation.</li> <li>Outbound Requests from Your CI Runner    When your pipeline runs gitStream, that runner might also make outbound calls to Bitbucket\u2014for example, to clone a repository or retrieve commit history. These requests will originate from the runner's IP address.</li> </ol> <p>If you encounter errors due to blocked IPs during your CI runs, it's likely that the runner is using an IP that is not part of the configured allowlist.</p> <p>Recommended Solution To ensure reliability:</p> <ul> <li>Add LinearB/gitStream service IPs to your Bitbucket allowlist (listed above).</li> <li>Use self-hosted runners or runners with static IPs so you can manage and allowlist their addresses explicitly.</li> <li>Add must add to your <code>bitbucket-pipeline.yml</code> <code>step.runtime.cloud.atlassian-ip-ranges: true</code>.</li> </ul> <p>This combination ensures that both gitStream's internal operations and your CI runners' interactions with Bitbucket function without network restrictions.</p>"},{"location":"bitbucket-installation/#bitbucket-installation-overview","title":"Bitbucket Installation Overview","text":"<ol> <li>Designate a gitStream user account.</li> <li>Create a <code>cm</code> repo and <code>.cm</code> configuration file.</li> <li>Create a Bitbucket pipeline.</li> <li>Configure self-hosted runners (if applicable).</li> <li>Install the gitStream service.</li> </ol>"},{"location":"bitbucket-installation/#designate-a-gitstream-user-account","title":"Designate a gitStream User Account","text":"<p>gitStream automation rules are executed on behalf of the user account configured when you connect gitStream to your Bitbucket instance. This account must have the appropriate permissions to the relevant repositories.</p> <ul> <li>A meaningful account identifier whose name contains the string <code>gitstream</code> (case insensitive), such as <code>gitStream-cm</code>, is required to ensure clarity and proper identification of the automated actions</li> </ul> <p>Use this account when you integrate gitStream</p> <p>Make sure to use this account when authorizing Bitbucket in LinearB.</p>"},{"location":"bitbucket-installation/#create-a-cm-repo-and-cm-configuration-file","title":"Create a <code>cm</code> repo and <code>.cm</code> configuration file.","text":"<p>Create a <code>cm</code> repository in your Bitbucket workspace. This repository must reside in the same project as your target repositories. In the root directory of the default branch (usually <code>master</code> or <code>main</code>), create a <code>gitstream.cm</code> rules file to define the workflow automations. The file can have any name but must end with the <code>.cm</code> extension.</p> <p>Changes Must Be in Main Branch</p> <p>Ensure all changes to your <code>.cm</code> configuration files are committed to the main branch before proceeding with the setup.</p> <p>Configuration File Locations</p> <p>Group-level rules require your <code>.cm</code> files to be placed in the <code>cm</code> repository's root directory. You can also define specific repo-level rules under the <code>.cm</code> folder in each of the connected repositories</p> <p>Example Configuration</p> <pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlinearb_ai_codereview:\nif:\n- {{ not is.bot }}\nrun:\n- action: code-review@v1\nargs:\nguidelines: |\n- Keep suggestions short and actionable.\npr_policy_low_noise:\nif:\n- {{ not pr.draft }}\n- {{ not is.bot }}\nrun:\n# AI description (updates PR body; not a comment)\n- action: describe-changes@v1\nargs:\nconcat_mode: append\n# Assign reviewers silently\n- action: add-reviewers@v1\nargs:\nreviewers: {{ who.experts }}\n# ONE consolidated, updatable comment\n- action: add-comment@v1\nargs:\ncomment: |\n## gitStream Summary \u2014 Low Noise (Staff Engineer focus)\n**AI PR Description:** Updated in the PR body above.  \n**ETR:** {{ calc.etr }} min review\n**Unresolved threads:** {{ pr.unresolved_threads | default(value=0) }}\n**JIRA:** {{ '\u2705 Found in title/description.' if (has.jira_ticket_in_title or has.jira_ticket_in_desc) else '\u26a0\ufe0f Missing Jira ticket. Please add one (e.g., `ABC-123` or an `atlassian.net/browse/...` link).' }}\n### Suggested Reviewers (auto-assigned)\n{{ who.experts }}\n# ----------------- config -----------------\ncalc:\netr: {{ branch | estimatedReviewTime }}\nhas:\njira_ticket_in_title: {{ pr.title       | includes(regex=r/\\b[A-Za-z][A-Za-z0-9_]+-\\d+\\b/) }}\njira_ticket_in_desc:  {{ pr.description | includes(regex=r/\\b[A-Za-z][A-Za-z0-9_]+-\\d+\\b/) }}\nwho:\nexperts: {{ repo | codeExperts(gt=10) }}\nis:\nbot: {{ pr.author | match(list=['github-actions','_bot_','[bot]','dependabot','gitstream-cm','prvalidation','aida-bot']) | some }}\ncolors:\nred:    'b60205'\nyellow: 'fbca04'\ngreen:  '0e8a16'\n</code></pre>"},{"location":"bitbucket-installation/#create-a-bitbucket-pipeline","title":"Create a Bitbucket Pipeline","text":"<p>Once your gitStream configuration file is set up, you need a Bitbucket Pipelines configuration file to trigger gitStream automations. Create a <code>bitbucket-pipelines.yml</code> file in your <code>cm</code> repository's default branch and add the following configuration:</p> <pre><code># Code generated by gitStream - DO NOT EDIT\nimage: atlassian/default-image:4\npipelines:\n# Pipelines that can only be triggered manually\ncustom:\ngitstream:\n- variables:\n- name: client_payload\ndescription: the client payload\n- name: head_ref\ndescription: the head sha\n- name: debug_mode\ndescription: Debug mode\ndefault: 'true'\n- name: oauth_token\ndescription: token to do operations in bitbucket\n- name: full_repo\ndescription: workspace/repo\n- step:\nname: /:\\ gitstream workflow automation\n##### For cloud runners with IP whitelist, uncomment the section below\n# size: 4x # Required as atlassian-ip-ranges supported only on 4x or more\n# runtime:\n#   cloud:\n#     atlassian-ip-ranges: true\n##### End of section\n#\n##### For self-hosted runners, uncomment the section below\n# runs-on:\n#   - self.hosted # Required to indicate a self-hosted runner\n#   - cmgitstreamrunner # Custom label that must be added to your self-hosted runner\n##### End of section\nmax-time: 15\nclone:\nenabled: false\nservices:\n- docker\nscript:\n- git clone --shallow-since=\"6 months ago\" --no-tags https://x-token-auth:$oauth_token@bitbucket.org/$full_repo.git gitstream/repo\n- git clone --depth=1 --no-tags https://x-token-auth:$oauth_token@bitbucket.org/$BITBUCKET_WORKSPACE/$BITBUCKET_REPO_SLUG.git gitstream/cm\n- cd gitstream/repo &amp;&amp; git fetch origin $head_ref:$head_ref &amp;&amp; git checkout $head_ref\n- docker pull gitstream/rules-engine:latest\n- |\ndocker run -v $BITBUCKET_CLONE_DIR/gitstream:/code \\\n-e RUN_ID=$BITBUCKET_BUILD_NUMBER \\\n-e CLIENT_PAYLOAD=\"$client_payload\" \\\n-e DEBUG_MODE=$debug_mode gitstream/rules-engine:latest\n</code></pre>"},{"location":"bitbucket-installation/#configure-self-hosted-runners-optional","title":"Configure Self-Hosted Runners (Optional)","text":"<p>If you're using self-hosted runners for your gitStream automation, follow these additional configuration steps:</p> <p>1. Self-Hosted Runner Must Be on the CM Repository</p> <p>Self-hosted runners need to be configured specifically for the <code>cm</code> repository where your gitStream configuration files are stored.</p> <p>2. Update Pipeline Configuration</p> <p>Add the following configuration to your <code>bitbucket-pipelines.yml</code> in the gitstream custom pipeline section:</p> <pre><code>runs-on:\n- self.hosted # Required to indicate a self-hosted runner\n- cmgitstreamrunner # Must use custom label for gitStream runner\n</code></pre> <p>3. Configure Runner Labels in Bitbucket</p> <p>Required Runner Labels</p> <p>You MUST add the following labels to your self-hosted runner in Bitbucket:</p> <ul> <li><code>self.hosted</code> (provided by default)</li> <li><code>linux</code> (provided by default)</li> <li><code>cmgitstreamrunner</code> (custom label you need to add)</li> </ul> <p>The <code>cmgitstreamrunner</code> label is required for gitStream to properly identify and use your self-hosted runner.</p> <p>4. Verify Runner Configuration</p> <p>Labels are not supported</p> <p>The <code>add-label</code> action is not supported in Bitbucket as Bitbucket does not have a native labeling feature.</p> <p>Explicit triggers are not supported</p> <p>The <code>triggers</code> and <code>on</code> functionality are not currently supported in Bitbucket. If you include them in your CM automation files, gitStream will skip the automations entirely.</p>"},{"location":"bitbucket-installation/#install-the-gitstream-service","title":"Install the gitStream Service","text":"<p>To complete the setup, install the gitStream service in your Bitbucket workspace. Follow the instructions provided in the LinearB app to connect your Bitbucket account and repositories to gitStream.</p>"},{"location":"bitbucket-installation/#next-step","title":"Next Step","text":"<p>If you successfully complete these instructions, gitStream will now automate your code review workflows in Bitbucket.</p> <p>How gitStream Works</p> <p>Read our guide, How gitStream Works, for a deeper understanding of gitStream's capabilities and how to leverage them fully.</p>"},{"location":"bitbucket-installation/#additional-resources","title":"Additional Resources","text":""},{"location":"bitbucket-installation/#required-bitbucket-permissions","title":"Required Bitbucket Permissions","text":"<p>The required permissions are:</p> Scope Description <code>account: email, read</code> Access user account information and email. <code>repositories: read, write, admin</code> Read, write, and administer repositories. <code>pullrequest: read, write</code> Read and modify pull requests. <code>webhook: read, write</code> Read and manage webhooks. <code>pipeline: read, write</code> Read and write pipelines. <code>runner: read, write</code> Read and manage runners. <p></p>"},{"location":"cm-file/","title":"gitStream Configuration Overview","text":"<p>Continuous Merge automation files have a <code>.cm</code> extension. In a repository,  gitStream loads and parse the <code>.cm</code> directory, which can have multiple automation files, each of which is evaluated independently.</p> <p>You can edit the <code>.cm</code> files and add your own checks and rules. Check out the Automation examples.</p>"},{"location":"cm-file/#automation-rules","title":"Automation rules","text":"<p>There are two types of automation rules: repository level rules and organization level rules.</p> <p>Repository level rules are set by creating a special <code>.cm</code> directory in the repository root. Automation rules are specified in files in this directory, which can have any name but must end with <code>.cm</code>.</p> <p>Organization level rules are defined by creating a special repository named <code>cm</code> in the organization or group. In this repository, you can add CM automation files, which will apply to all the repositories that gitStream app is connected.</p> <p>When organization level rules are defines, repository level automation shall take precedence and override organization automation when having the same identifier.</p> <p>An automation identifier is a composition of the CM file name and the automation name. For example when <code>safe_changes</code> is defined in <code>gitstream.cm</code> then the automation identifier shall be <code>gitstream/safe_changes</code></p> <p>Tip</p> <p>You can select (include or exclude) certain repositories per automation file using the <code>triggers.include.repository</code> and <code>triggers.exclude.repository</code></p>"},{"location":"cm-file/#repository-automation-rules","title":"Repository automation rules","text":"<p>Repository automation rules are set by creating a special <code>.cm</code> directory in your repository root. Automation rules are specified in files in this directory, these files can have any name but must end with <code>.cm</code>. By default, you start with a single automation file <code>.cm/gitstream.cm</code>.</p> <p>Every file is parsed independently, and the parsing results are combined and executed.</p> <p>Specifically:</p> <ol> <li>Automation rules are allowed to have same name in different <code>.cm</code> files</li> <li>The <code>config</code> section is defined per <code>.cm</code> file (except <code>config.admin</code>)</li> <li>Any accessory expression defined in each file scope, therefore cannot be reused in another file (but it can be duplicated)</li> </ol> <p>When configured correctly, your repository directory structure should look like that (for GitHub):</p> Repsository automation rules<pre><code>.\n\u251c\u2500 .cm/\n\u2502  \u2514\u2500 *.cm\n\u251c\u2500 .github/\n\u2502  \u2514\u2500 workflows/\n\u2502     \u2514\u2500 gitstream.yml\n</code></pre> <p>Note</p> <p>The <code>.cm/gitstream.cm</code> is special, as it allows repository-level configuration such as <code>config.admin</code>.</p>"},{"location":"cm-file/#organization-automation-rules","title":"Organization automation rules","text":"<p>Organization automation rules are defined by creating a special repository <code>cm</code> in your organization or group. In this repository, you can add CM automation files, which will apply to all the repositories that gitStream app is connected.</p> <p>When configured correctly, the <code>cm</code> repository directory structure should look like that (for GitHub):</p> Repsository automation rules<pre><code>.\n\u251c\u2500 *.cm\n\u251c\u2500 .github/\n\u2502  \u2514\u2500 workflows/\n\u2502     \u2514\u2500 gitstream.yml\n</code></pre> <p>For each PR the following automation rules are applied:</p> <ol> <li>Repository level rules</li> <li>Organization-level rules, unless with the same identifier as a repository-level automation</li> </ol> <p>When organization level rules are defined, then the CI/CD will be executed on the <code>cm</code> repository on behalf of the PR repository.</p>"},{"location":"cm-file/#setting-up-global-automation-rules","title":"Setting up Global Automation rules","text":"<p>By utilizing the following techniques, you can effectively combine and manage global and repository rules to customize the behavior of your automations to fit the specific requirements of your repositories:</p> <ol> <li>Global rules are defined in the configuration management <code>cm</code> repository and are applied to all repositories that are connected to gitStream.</li> <li>To exclude or run only on specific repositories from a global rule, you can use <code>triggers.include.repository</code> and <code>triggers.exclude.repository</code> in the <code>cm</code> file and add a list of the unwanted or wanted repositories respectfully.</li> <li>To override a global rule for specific automation in a repository, you can duplicate the rule (both the file and automation name) and place it in the desired repository. The locally defined rule will then take precedence over the global rule for that specific repository.</li> </ol>"},{"location":"cm-file/#controlling-organization-level-rules-per-repository","title":"Controlling Organization-Level Rules per Repository","text":"<p>The <code>triggers</code> section in organization-level rules allows you to precisely control which repositories will run specific automations. This is particularly useful for implementing standardized rules across most repositories while exempting specific ones, or for creating specialized automations that only apply to certain repository types.</p>"},{"location":"cm-file/#repository-inclusion-and-exclusion","title":"Repository Inclusion and Exclusion","text":"<p>You can use <code>triggers.include.repository</code> and <code>triggers.exclude.repository</code> to define which repositories should or should not run particular automations:</p> <pre><code># In your organization's 'cm' repository\nmanifest:\nversion: 1.0\n# This automation will run on all repositories EXCEPT those containing 'legacy' in their name\ntriggers:\nexclude:\nrepository:\n- r/legacy/\nautomations:\nenforce_pr_title_format:\nif:\n- {{ not (pr.title | includes(term=\"fix:|feat:|docs:|style:|refactor:|test:|chore:\")) }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nPlease format your PR title according to our [Conventional Commits](https://www.conventionalcommits.org/) standard.\nExample: `feat: implement new login flow`\n</code></pre>"},{"location":"cm-file/#creating-repository-type-specific-rules","title":"Creating Repository-Type Specific Rules","text":"<p>You can also create separate CM files for different types of repositories:</p> <pre><code># backend-rules.cm in your organization's 'cm' repository\nmanifest:\nversion: 1.0\n# This file's automations will ONLY run on repositories with 'api' or 'service' in their name\ntriggers:\ninclude:\nrepository:\n- r/api|service/\nautomations:\nrequire_api_docs:\nif:\n- {{ files | match(regex=r/\\/api\\/.*\\.js|ts$/) | some }}\nrun:\n- action: request-changes@v1\nargs:\ncomment: |\nAPI changes detected. Please ensure you've updated the corresponding documentation.\n</code></pre> <p>This approach allows you to create specialized rule sets for different repository types (frontend, backend, infrastructure, etc.) while maintaining them all in a centralized location.</p>"},{"location":"cm-file/#the-cm-automation-file","title":"The .cm automation file","text":""},{"location":"cm-file/#schema","title":"Schema","text":"<p>The following sections are used in <code>.cm</code> file to describe the desired automations:</p> <ul> <li><code>manifest</code></li> <li><code>config</code></li> <li><code>triggers</code></li> <li><code>automations</code></li> </ul>"},{"location":"cm-file/#manifest","title":"<code>manifest</code>","text":"<p>The first section in a <code>gitstream.cm</code> file is the <code>manifest</code>.</p> <pre><code>manifest:\nversion: 1.0\n</code></pre> <p>The only field required is <code>version</code>.</p> Key Required Type Description <code>manifest</code> Y Map The manifest section root <code>manifest.version</code> Y String Specify the <code>.cm</code> spec version: 0.1, 1.0 <p>The manifest version field is used to parse the <code>.cm</code> file, in the future if breaking changes are introduced to the parser then older automation will be still supported.</p>"},{"location":"cm-file/#config","title":"<code>config</code>","text":"<p>The <code>config</code> section in the <code>.cm</code> file is optional and specifies settings that affect gitStream's operation within a given context.</p> Key Type Default Scope Description <code>config</code> Map - per <code>.cm</code> file Root configuration section, applies to the automations defined in the current file. <code>config.admin.users</code> [String] <code>[]</code> <code>gitstream.cm</code> List of admin users, identified by Git provider usernames. <code>config.git_history_since</code> String - per <code>.cm</code> file Limit git history analysis to commits after the specified date (YYYY-MM-DD). <code>config.ignore_files</code> [String] <code>[]</code> per <code>.cm</code> file Files to exclude from consideration. <code>config.user_mapping</code> [String: String] <code>[]</code> per <code>.cm</code> file Map Git user details to provider account names."},{"location":"cm-file/#configadminusers","title":"<code>config.admin.users</code>","text":"<p>When specified in <code>gitstream.cm</code>, the <code>config.admin.users</code> allows adding admin rights. When a PR changes the <code>*.cm</code> files only, if the user is listed in <code>config.admin.users</code>, the PR will be approved by gitStream. Furthermore, if an admin is defined, they will automatically be requested to review changes in PRs that change rules files and will also be set as a required reviewer, meaning gitStream will block the merge until the admin approves the PR.</p> <p>For example, setting <code>popeye</code> as admin:</p> example<pre><code>config:\nadmin:\nusers: ['popeye']\n</code></pre> <p>This configuration is valid only when used in <code>.cm/gitstream.cm</code>, when defined in other <code>.cm</code> files this configuration is ignored.</p> <p>When you add a user to <code>config.admin.users</code> in your organization's <code>cm</code> repository, they are granted administrative privileges to CM changes across every repository in the organization. gitStream evaluates CM rules in the individual repository and your organization's <code>cm</code> repository to determine admin users.</p> <p>When you add a user to <code>config.admin.users</code> in your repository's <code>.cm/gitstream.cm</code> file, they are granted administrative privileges to CM changes within that specific repository. However, if an organization-level admin is already defined in your organization's <code>cm</code> repository, then the organization-level admin approval is required for that change to take effect.</p>"},{"location":"cm-file/#configignore_files","title":"<code>config.ignore_files</code>","text":"<p>The <code>config.ignore_files</code> supports glob pattern matching that contains a list of files to ignore.</p> <p>Common usage, since some files such as lock files are intentionally not a required part of a review, they would not want to them to be counted in the estimated review time. In such cases, you can add <code>config.ignore_files</code> to the relevant CM file, for example:</p> example<pre><code>config:\nignore_files:\n- 'yarn.lock'\n- 'package-lock.json'\n- 'openapi.json'\n- 'ui/src/**/*Model.d.ts'\n</code></pre>"},{"location":"cm-file/#configuser_mapping","title":"<code>config.user_mapping</code>","text":"<p>Accepts list of key value strings.</p> <p>For example, when using <code>rankByGitBlame</code> or <code>explainRankByGitBlame</code> Git users are mapped to their matching Git provider accounts based on the Git details. The automatic mapping can sometimes result with the wrong account or fail to find a proper mapping, in these cases you can configure the <code>config.user_mapping</code>. This allows you to map confusing Git user into their specific accounts and dump some irrelevant accounts:</p> example<pre><code>config:\nuser_mapping:\n- 'Popeye Man &lt;popeye@invalid.com&gt;': 'popeye-the-salyor-man' # (1)\n- 'Popeye Man &lt;popeye2@invalid.com&gt;': 'popeye-the-salyor-man' # (2)\n- 'olive &lt;olive@invalid.com&gt;': null # (3)\n</code></pre> <ol> <li>Map Git user signature to the correct Git provider user name (e.g. GitHub)</li> <li>Map Git user signature to the correct Git provider user name (e.g. GitHub)</li> <li>Mapping to <code>null</code> removes this Git user from the suggested results</li> </ol> <p>When using <code>rankByGitBlame</code> to assign reviewers automatically with <code>add-reviewers@v1</code> then mapping users to <code>null</code> is a way to prevent the automatic mapping in certain cases, like in your example contributors that are not longer part of the team.</p> <p>On the other hand, when using <code>explainRankByGitBlame</code> with <code>add-comment@v1</code> it still shows these users details in the PR comment suggestion as this info might be valuable by itself.</p> <pre><code>- action: add-reviewers@v1\nargs: # (1)\nreviewers: {{ repo | rankByGitBlame(gt=25) }}\n- action: add-comment@v1\nargs: # (2)\ncomment: |\n{{ repo | explainRankByGitBlame(gt=25) }}\n</code></pre> <ol> <li><code>rankByGitBlame</code> will drop <code>null</code> users</li> <li><code>explainRankByGitBlame</code> will NOT drop <code>null</code> users</li> </ol>"},{"location":"cm-file/#configgit_history_since","title":"<code>config.git_history_since</code>","text":"<p>The <code>config.git_history_since</code> configuration limits how far back gitStream looks in git history when analyzing code expertise and git blame results. This affects filters and actions that rely on git history analysis, including:</p> <ul> <li><code>codeExperts</code> filter</li> <li><code>rankByGitBlame</code> filter  </li> <li><code>explainRankByGitBlame</code> filter</li> <li><code>explain-code-experts</code> action</li> </ul> <p>When <code>git_history_since</code> is configured, gitStream will only consider commits made on or after the specified date when determining code experts and calculating git blame rankings. This is particularly useful for:</p> <ul> <li>Team transitions: When a project changes hands between teams, you can set the date to when the new team took over to ensure only current team members are suggested as reviewers</li> <li>Performance optimization: Large repositories with extensive history can benefit from limiting the analysis scope</li> <li>Relevant expertise: Focus on recent contributions rather than legacy code changes</li> </ul> <p>The value should be specified as a date in <code>YYYY-MM-DD</code> format.</p> example<pre><code>config:\ngit_history_since: '2025-01-01'  # Only consider commits from January 1, 2025 onwards\n</code></pre> <p>Example use case: If your team took over a project on January 1, 2025, and you want to ensure that only current team members are suggested as code experts:</p> .cm/gitstream.cm<pre><code>config:\ngit_history_since: '2025-01-01'\nautomations:\nassign_code_experts:\nif:\n- {{ files | codeExperts(gt=10) | length &gt; 0 }}\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: {{ files | codeExperts(gt=10) }}\n</code></pre> <p>With this configuration, the <code>codeExperts</code> filter will only analyze git blame data from commits made on or after January 1, 2025, effectively filtering out previous team members from reviewer suggestions.</p>"},{"location":"cm-file/#triggers","title":"<code>triggers</code>","text":"<p>The <code>triggers</code> is section specifies when automations are executed, supporting <code>include</code> and <code>exclude</code> lists for branch and repository patterns at the file level. The <code>on</code> keyword can also be used within individual automations to define specific events that trigger those automations.</p> <pre><code>triggers:\non:\n- pr_created\n- commit\nexclude:\nbranch:\n- hotfix\n</code></pre> <p>Read more here: triggers.</p>"},{"location":"cm-file/#automations","title":"<code>automations</code>","text":"<p>The <code>automations</code> section defines the automations and their conditions.</p> <pre><code>automations:\nmark_small_pr:\nif:\n- {{ checks.size.is.xsmall }}\nrun:\n- action: add-label@v1\nargs:\nlabel: xsmall\n</code></pre> <p>Each automation includes its name, and few fields: <code>if</code> and <code>run</code>.</p> Key Required Type Description <code>automations</code> Y Map The automations section root <code>automations.NAME</code> Y Map User defined name of the automation, can be any string <code>automations.NAME.if</code> Y Map List of conditions with AND relationship <code>automations.NAME.run</code> Y Map Actions to run if all conditions are met, invoked one by one <p>The <code>if</code> field includes the list of conditions. The conditions are checked when a pull request is opened or changed, if all the conditions pass, the automation is executed.</p> <p>The <code>run</code> field includes the automation to execute. It includes the following fields:</p> Key Required Type Description <code>action</code> Y String The action pointer <code>engine</code> N String The action engine, default is <code>gitstream</code> <code>args</code> N List The action inputs list <p>For <code>gitstream</code> engine, the action is specified by: <code>name@version</code></p> <p>gitStream supported actions, see actions.</p>"},{"location":"cm-file/#reusing-checks","title":"Reusing checks","text":"<p>You can define an accessory section, e.g. <code>checks</code>, that defines common conditions, and reuse.</p> <pre><code>size:\nis:\nsmall: {{ branch.diff.size &lt; 20 }}\nmedium: {{ branch.diff.size &gt;= 20 and branch.diff.size &lt; 100 }}\nlarge: {{ branch.diff.size &gt;= 100 }}\nautomations:\napprove_small:\nif:\n- {{ size.is.small }}\nrun:\n- action: approve@v1\nmark_small_medium:\nif:\n# Check that the PR is either small or medium size\n- {{ size.is.small or size.is.medium }}\n# AND its less than 5 minutes review (estimated)\n- {{ branch | estimatedReviewTime &lt;= 5 }}\nrun:\n- action: add-label@v1\nargs:\nlabel: 'good-size'\n</code></pre>"},{"location":"cm-syntax/","title":"Cm syntax","text":"<p>Deprecated. See: /how-it-works</p>"},{"location":"context-variables/","title":"Context variables","text":"<p>Context variables are the inputs for the automation conditions or checks.</p> <p>Legend</p> <p>The icons indicate the availability status of each action.</p> <ul> <li> Supported on GitHub</li> <li> Supported on GitLab</li> <li> Supported on Bitbucket</li> <li> Under development and not available yet.</li> <li> Open beta - Under development and currently available for all</li> </ul>"},{"location":"context-variables/#overview","title":"Overview","text":""},{"location":"context-variables/#context","title":"Context","text":"<p>gitStream includes a collection of variables called contexts.</p> <ul> <li><code>actions</code> </li> <li><code>branch</code> </li> <li><code>env</code> </li> <li><code>files</code> </li> <li><code>pr</code> </li> <li><code>repo</code> </li> <li><code>source</code> </li> </ul>"},{"location":"context-variables/#structures","title":"Structures","text":"<p>The following structures are used in the context objects:</p> <ul> <li><code>GitBlame</code></li> <li> <code>Check</code></li> <li><code>Contributor</code></li> <li><code>FileDiff</code></li> <li><code>FileMetadata</code></li> <li><code>Comment</code></li> <li><code>conversations</code></li> </ul> Example of a context object <p>Partial example of a context object for a PR that changed few lines in a <code>README.md</code> file:</p> <pre><code>{\n\"branch\": {\n\"name\": \"new-feature-branch\",\n\"base\": \"main\",\n\"diff\": {\n\"size\": 50,\n\"files_metadata\": [\n{\n\"original_file\": \"README.md\",\n\"new_file\": \"README.md\",\n\"deletions\": 0,\n\"additions\": 2\n}\n]\n},\n\"num_of_commits\": 1\n},\n\"source\": {\n\"diff\": {\n\"files\": [\n{\n\"original_file\": \"README.md\",\n\"new_file\": \"README.md\",\n\"diff\": \"@@ -10,3 +10,5 @@ This project \\n+\\n+## Intro\",\n\"original_content\": \"This project \\n\",\n\"new_content\": \"This project \\n\\n## Intro\"\n}\n]\n}\n},\n\"repo\": {\n\"contributors\": {\n\"popeye\": \"46\",\n\"olive\": \"6\"\n},\n\"owner\": \"acme\"\n},\n\"files\": [\n\"README.md\"\n]\n}\n</code></pre>"},{"location":"context-variables/#reference","title":"Reference","text":""},{"location":"context-variables/#actions","title":"<code>actions</code>","text":"<p>The <code>actions</code> context contains outputs from actions that have been executed in previous automations within the same CM file. This enables creating conditional workflows based on the results of earlier actions.</p> <p>First Action with Outputs</p> <p>Currently, only the <code>code-review</code> action supports outputs. This feature will be expanded to other actions in future releases.</p> Values Type Description <code>actions</code> Map Contains outputs from all completed actions, organized by automation ID <code>actions.&lt;automation_id&gt;</code> Map Outputs from a specific automation (identified by its key in the <code>automations</code> section) <code>actions.&lt;automation_id&gt;.outputs</code> Map All outputs produced by the action(s) in the specified automation <code>actions.&lt;automation_id&gt;.outputs.&lt;output_name&gt;</code> Various Specific output value (type depends on the action - see individual action documentation) <p>Syntax Notes:</p> <ul> <li>Use dot notation for automation names with underscores: <code>actions.ai_code_review.outputs.is_LGTM</code></li> <li>Use bracket notation for automation names with hyphens: <code>actions['ai-code-review'].outputs.is_LGTM</code></li> </ul> <p>Example Usage:</p> <pre><code>automations:\n# First automation: Run AI code review\nai_code_review:\nif:\n- {{ not pr.draft }}\nrun:\n- action: code-review@v1\n# Second automation: Only runs if the AI review found no issues\nauto_approve_on_clean_review:\nif:\n- {{ actions.ai_code_review.outputs.is_LGTM }}\nrun:\n- action: approve@v1\n# Third automation: Add different labels based on review result\nlabel_based_on_review:\nif:\n- true\nrun:\n- action: add-label@v1\nargs:\nlabel: \"{{ 'ai-approved' if actions.ai_code_review.outputs.is_LGTM else 'needs-review' }}\"\n</code></pre> <p>Available Action Outputs:</p> Action Output Type Description <code>code-review@v1</code> <code>is_LGTM</code> Bool <code>true</code> if no issues were found, <code>false</code> if issues were detected"},{"location":"context-variables/#branch","title":"<code>branch</code>","text":"<p>The <code>branch</code> context contains info regarding the branch changes compared to the base branch.</p> <p>Note</p> <p>compared to the <code>source</code> context does not include actual source code.</p> Values Type Description <code>branch</code> Map Includes the info related to the current branch <code>branch.author</code> String The branch author (the user that did first commit in the branch). The formatted like author in <code>git-log</code>, e.g. <code>Popeye &lt;popeye@acme.com&gt;</code> <code>branch.author_name</code> String The branch author name <code>branch.author_email</code> String The branch author email <code>branch.base</code> String The main branch, <code>main</code> <code>branch.commits.messages</code> [String] A list with all the commit messages in this branch <code>branch.diff.size</code> Integer The sum of line changed: additions, edits and deletions <code>branch.diff.files_metadata</code> <code>FileMetadata</code> List of changed files including their relative path <code>branch.name</code> String The current branch, <code>feature-123-branch</code> <code>branch.num_of_commits</code> Integer The number of commits in the branch <p>The branch context doesn't include any source code, but only related metadata.</p> <p>Example for using <code>branch.name</code> and <code>branch.author</code> to automatically approve and merge version bumps.</p> <pre><code>automations:\ndependabot:\nif:\n- {{ branch.name | includes(term=\"dependabot\") }}\n- {{ branch.author | includes(term=\"dependabot\") }}\nrun:\n- action: approve@v1\n- action: add-label@v1\nargs:\nlabel: \"approved-dependabot\"\n- action: merge@v1\nargs:\nwait_for_all_checks: true\nsquash_on_merge: true\n</code></pre> <p>Tip</p> <p>The <code>files</code> context doesn't include deleted file, to identify both modified and deleted files use the <code>branch.diff.files_metadata</code>, for example: <pre><code>{{ branch.diff.files_metadata | match(attr='file', regex=r/\\.md$/) | every }}\n</code></pre></p>"},{"location":"context-variables/#env","title":"<code>env</code>","text":"<p>The <code>env</code> context allows the user to pass data from the repo that is unavailable in the other context variables. Thus, the structure of the variable is not fixed and depends on user configuration.</p> <p>To configure the <code>env</code> variable, add the <code>env</code> field to gitstream's workflow job configurations on <code>.github/workflows/gitstream.yml</code>. For more information, visit GitHub's guide for Using secrets in GitHub Actions</p> examle: add secrets to the env variable<pre><code>...\njobs:\ngitStream:\ntimeout-minutes: 5\nruns-on: ubuntu-latest\nname: gitStream workflow automation\nenv:\nSLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}\n...\n</code></pre> <p>To use the context variable, access to the <code>env</code> variable's fields as configured in <code>gitstream.yml</code></p> example: use slack webhook secret<pre><code>automations:\nsend_slack:\nif:\n- true\nrun:\n- action: send-slack-message@v1\nargs:\nmessage: \"Hello world :tada:.\"\nwebhook_url: \"{{ slack_webhook }}\"\nslack_webhook: {{ env.SLACK_WEBHOOK }}\n</code></pre>"},{"location":"context-variables/#files","title":"<code>files</code>","text":"<p>The <code>files</code> context includes the list of changed files in the branch compared to the main branch.</p> Values Type Description <code>files</code> [String] List of all changed files with their full path <p>For example, a typical <code>files</code> context can look like this:</p> <pre><code>[\n\"README.md\",\n\"package.json\",\n\"src/app.js\",\n\"src/index.js\",\n\"docs/examples.md\"\n]\n</code></pre> <p>Example for checking if certain changes are made:</p> <pre><code>automations:\nui_review:\nif:\n- {{ files | match(list=ui_templates_files) | some }}\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: [GitHubUser1, GitHubUser2]\nui_templates_files:\n- resources/app/ui_template.yml\n- resources/app/role_template.yml\n- resources/app/account_template.yml\n</code></pre>"},{"location":"context-variables/#pr","title":"<code>pr</code>","text":"<p>The <code>pr</code> context includes metadata related to the pull request.</p> Values Type Description <code>pr</code> Map Includes the info related to the PR <code>pr.approvals</code> [String] A list of the of reviewers that approved the PR <code>pr.assignees</code> [String] A list of the people assigned to this pull request <code>pr.author</code> String The PR author name <code>pr.author_is_org_member</code> Bool <code>true</code> if the PR author is a member of the organization where gitStream is installed <code>pr.author_teams</code> String The teams which the PR author is member of <code>pr.checks</code> [<code>Check</code>] List of checks, names and status <code>pr.comments</code> [<code>Comment</code>] List of PR comments objects <code>pr.commit_statuses</code> [<code>CommitStatus</code>] List of commit status check objects from external CI systems. <code>pr.conflicted_files_count</code> Integer The number files in the PR with conflicts <code>pr.conversations</code> [<code>Conversation</code>] List of PR conversation objects, usually when reviewer have comments about the source code <code>pr.created_at</code> String The date and time the PR was created <code>pr.description</code> String The PR description text <code>pr.draft</code> Bool <code>true</code> when the PR is marked as Draft/WIP <code>pr.labels</code> [String] The labels that are attached to the PR <code>pr.number</code> Integer The PR or MR Id number <code>pr.provider</code> String The Git cloud provider name, e.g. <code>GitHub</code>, <code>GitLab</code> etc. <code>pr.requested_changes</code> [String] List of users that requested changes <code>pr.reviewers</code> [String] The list of reviewers set for this PR <code>pr.reviews</code> [<code>Review</code>] List of PR reviews, relevant in GitHub <code>pr.source</code> String The branch from which the PR originates <code>pr.status</code> String The PR status: <code>open</code>, <code>closed</code> and <code>merged</code> <code>pr.target</code> String The branch the PR is intended merged into <code>pr.title</code> String The PR title <code>pr.unresolved_threads</code> Integer The number of open review comments in the PR <code>pr.updated_at</code> String The date and time the PR was last updated <code>pr.url</code> String A link to the PR on <p>Example for checking the PR title includes a Jira ticket:</p> <pre><code>automations:\ncheck_jira_ticket:\nif:\n- {{ not has.jira_ticket }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"missing-ticket\"\ncolor: 'F6443B'\nhas:\njira_ticket: {{ pr.title | includes(regex=r/^\\[?\\w{3,4}-\\d{1,6}\\]?(\\s|-|_).{20,}$/) }}\n</code></pre>"},{"location":"context-variables/#repo","title":"<code>repo</code>","text":"<p>The <code>repo</code> context includes metadata related to the repo.</p> Values Type Description <code>repo</code> Map Includes the info related to the current repo <code>repo.age</code> Integer Number of days since first commit (of any user) <code>repo.author_age</code> Integer number of days since first commit to this repo <code>repo.blame</code> <code>GitBlame</code> The percentage of each user's lines in a file, the list includes all changed files in the branch. The <code>ratio</code> field sorts the list <code>repo.contributors</code> <code>Contributor</code> List of contributors in the repo <code>repo.git_activity</code> <code>GitActivity</code> Per file and user, the number of lines changed every week for the last 52 weeks <code>repo.languages</code> Map Lists the languages used in the specified repository. The returned object is a map of key-value pairs representing a language and the percentage of bytes in that language within the code. <code>repo.name</code> String Repository name <code>repo.owner</code> String Repository owner account name <code>repo.visibility</code> String The visibility of the source branch repo. Value is one of: <code>private</code>, <code>internal</code>, or <code>public</code>"},{"location":"context-variables/#source","title":"<code>source</code>","text":"<p>The <code>source</code> context includes a list of <code>FileDiff</code> objects that can be used to get insights based on code changes. The changes compared to the latest main branch.</p> Values Type Description <code>source.diff.files</code> <code>FileDiff</code> List of changed files with their code changes <p>The source context include all code changes, it is not safe to share it with unknown services.</p>"},{"location":"context-variables/#check-structure","title":"<code>Check</code> structure","text":"<pre><code>{\n\"name\": String, # The check name\n\"status\": String, # The check status: `queued`, `in_progress`, `completed`\n\"conclusion\": String, # The check conclusion: `action_required`, `cancelled`, `failure` `neutral`, `success`, `skipped`, `stale`, `timed_out`\n\"title\": String, # the check title\n\"total_time\": Integer, # the total time the check took, in Seconds\n}\n</code></pre>"},{"location":"context-variables/#comment-structure","title":"<code>Comment</code> structure","text":"<pre><code>{\n\"commenter\": String, # The user that add the comment\n\"content\": String, # The comment body\n\"created_at\": String, # The time on which the comment was created\n\"updated_at\": String, # The time on which the comment was last updated\n}\n</code></pre>"},{"location":"context-variables/#commitstatus-structure","title":"<code>CommitStatus</code> structure","text":"<p>Represents the status of external CI systems like Docker builds or test results. Note gitStream doesn't respond to commit status events, only collects them when other events trigger.</p> <pre><code>{\n\"state\": String, # The status of the check: `pending`, `success`, `failure`, `error`\n\"context\": String, # The identifier for the CI system or check (e.g., \"continuous-integration/jenkins\")\n\"description\": String # Human-readable description of the status (e.g., \"The build succeeded!\")\n}\n</code></pre> <p>Example: <pre><code>[\n{\n\"state\": \"pending\",\n\"context\": \"continuous-integration/jenkins\",\n\"description\": \"The build succeeded!\"\n}\n]\n</code></pre></p>"},{"location":"context-variables/#conversation-structure","title":"<code>Conversation</code> structure","text":"<pre><code>{\n\"commenter\": String, # The user that add the comment\n\"content\": String, # The comment body\n\"created_at\": String, # The time on which the comment was created\n\"updated_at\": String, # The time on which the comment was updated\n\"start_line\": Integer, # The first line marked for this comment\n\"end_line\": Integer, # The last line marked for this comment\n\"is_resolved\": Boolean # `true` when marked as resolved\n}\n</code></pre>"},{"location":"context-variables/#contributor-structure","title":"<code>Contributor</code> structure","text":"<p>The <code>repo.contributors</code> mapping includes a list of <code>Contributor</code>, where the user name is used as dynamic key:</p> <pre><code>{\nUSER_NAME: Integer # Number of commits\n}\n</code></pre>"},{"location":"context-variables/#filediff-structure","title":"<code>FileDiff</code> structure","text":"<p>The <code>source.diff.files</code> mapping includes a list of <code>FileDiff</code>:</p> <pre><code>{\n\"diff\": String, #  The content in diff format `+` for additions, `-` for deletions\n\"new_content\": String, # The new content in this branch\n\"new_file\": String, # The name of the file after the changes, including its path\n\"original_content\": String, #  The content as is in the `main` branch\n\"original_file\": String, #  The name of the file before the changes, including its path\n}\n</code></pre>"},{"location":"context-variables/#filemetadata-structure","title":"<code>FileMetadata</code> structure","text":"<p>The <code>branch.diff.files_metadata</code> mapping includes a list of <code>FileMetadata</code>:</p> <pre><code>{\n\"additions\": Integer, # The number of lines edited or added to the file\n\"deletions\": Integer, # The number of lines removed from the file\n\"file\": String, # The name of the file before the changes, including its path\n}\n</code></pre> <p>For example, sum additions in javascript code files:</p> <pre><code>{{ branch.diff.files_metadata | filter(attr='new_file', regex=r/\\.js$|\\.ts$/) | map(attr='additions') | sum }}\n</code></pre>"},{"location":"context-variables/#gitactivity-structure","title":"<code>GitActivity</code> structure","text":"<p>This structure include per changed file, for every user, the number of lines changed every week for the last 52 weeks.</p> <pre><code>{\nFILE_NAME: # The file name and path\n{\n# The git user identifier (String)\nGIT_USER: {\n\"week_INDEX\": Integer # Number of lines changed that week\n# ... for the last 52 weeks\n}\n}\n}\n</code></pre> <p>For example:</p> <pre><code>{\n\"src/utils/service.js\": {\n\"popeye &lt;popeye@acme.com&gt;\": {\n\"week_1\": 20,\n\"week_2\": 15,\n\"week_10\": 250\n},\n\"olive &lt;olive@acme.com&gt;\": {\n\"week_1\": 3,\n\"week_3\": 50,\n\"week_52\": 250\n}\n},\n\"README.md\": {\n\"popeye &lt;popeye@acme.com&gt;\": {\n\"week_2\": 15,\n\"week_3\": 10\n}\n}\n}\n</code></pre>"},{"location":"context-variables/#gitblame-structure","title":"<code>GitBlame</code> structure","text":"<p>For each file, a list of user's blame ratio.</p> <pre><code>{\nFILE_NAME: # The file name and path\n{\n# The git user identifier (String)\nGIT_USER: Integer, # Precentage 0-100, ratio of user's lines / total lines in file\n}\n}\n</code></pre> <p>For example:</p> <pre><code>{\n\"src/utils/service.js\": {\n\"popeye &lt;popeye@acme.com&gt;\": 78,\n\"olive &lt;olive@acme.com&gt;\": 22,\n},\n\"README.md\": {\n\"popeye &lt;popeye@acme.com&gt;\": 13,\n\"olive &lt;olive@acme.com&gt;\": 22,\n\"brutus &lt;brutus@acme.com&gt;\": 65,\n}\n}\n</code></pre>"},{"location":"context-variables/#review-structure","title":"<code>Review</code> structure","text":"<pre><code>{\n\"commenter\": String, # The user that add the comment\n\"content\": String, # The comment body\n\"created_at\": String, # The time on which the comment was created\n\"state\": String, # Either `approved`, `changes_requested`, `commented`, `pending`, `submitted`\n\"conversations\": [Conversation], # Conversations that are relvant to this Review feedback\n}\n</code></pre>"},{"location":"custom-github-app/","title":"How to Set Up Custom GitHub App and Connect to gitStream Services","text":"<p>Note</p> <p>This guide is for installations on self-hosted GitHub Server. If you are using the gitStream cloud service, please refer to this guide.</p> <p>Tip</p> <p>Multi-org support is also available by creating a <code>cm</code> organization and installing the app there. See step 11 for details on multi-org setup.</p>"},{"location":"custom-github-app/#custom-github-app-for-self-hosted-github-server","title":"Custom GitHub App for Self-Hosted GitHub Server","text":"<p>A GitHub application serves as the link between gitStream and GitHub. It facilitates user authentication via OAuth2 and allows users to select repositories accessible by gitStream.</p> <p>Prerequisites</p> <ol> <li>GitHub Server v3.10 or higher</li> <li>Allowed network connection between the server and the following IPs:<ul> <li>13.56.203.235</li> <li>54.151.81.98</li> </ul> </li> </ol> <p>In this section, we'll guide you through creating a GitHub app for your self-hosted gitStream installation. By the end, you should have noted down the following values:</p> <ul> <li>App ID</li> <li>Private Key</li> </ul> <p>Note</p> <p>Throughout this document, when we refer to a GitHub account, it refers to your own GitHub Server installation.</p>"},{"location":"custom-github-app/#1-connect-github-server-to-linearb","title":"1. Connect GitHub Server to LinearB","text":"<p>First login, or create a free account on the LinearB app.</p> <p>In LinearB, go to Settings -&gt; Git -&gt; click the <code>Connect gitStream</code> button next to your GitHub Server integration. You\u2019ll need to use the Webhook URL and Webhook secret later when setting up the GitHub App.</p> <p></p> <p>Keep this window open and complete the next steps in GitHub. Once you have the App ID and Private Key (.pem file), you can complete the connection in LinearB.</p>"},{"location":"custom-github-app/#2-create-a-new-github-app","title":"2. Create a New GitHub App","text":"<p>Any GitHub account on your self-hosted GitHub Server can own the app, but we recommend creating it under the organization account of the team who will maintain the gitStream installation.</p> <ul> <li>Log in to your GitHub Server and go to your organization account page (e.g., <code>https://&lt;GITHUB_SERVER_URL&gt;/&lt;organization account name&gt;</code>)</li> <li>Navigate to Settings -&gt; Developer Settings -&gt; GitHub Apps -&gt; New GitHub App as shown below</li> <li>Or go directly to <code>https://&lt;GITHUB_SERVER_URL&gt;/settings/apps</code></li> </ul> <p></p>"},{"location":"custom-github-app/#3-set-up-urls-and-general-information","title":"3. Set Up URLs and General Information","text":"<p>Fill in the app information as shown in the screenshot below. For URLs, replace <code>gitstream.&lt;your-domain&gt;.com</code> with the actual endpoint at which you'll be hosting the gitStream application.</p> <p>Warning</p> <ol> <li>Do not forget trailing slashes for the URLs</li> <li>Do not forget to disable the \"Expire user authorization tokens\" checkbox</li> <li>The GitHub App name must contain <code>gitstream</code> in lower case</li> </ol> <p>Tip</p> <p>Use the following texts:</p> <ol> <li>GitHub App name: <code>gitstream app</code></li> <li>Homepage URL: <code>https://gitstream.cm</code></li> </ol> <p></p> <p>Tip</p> <p>Use the following texts:</p> <ol> <li>Webhook URL from LinearB setup page</li> <li>Webhook secret from LinearB setup page</li> </ol> <p></p>"},{"location":"custom-github-app/#4-set-up-permissions","title":"4. Set Up Permissions","text":"<p>We need the following permissions to enable all gitStream functionality:</p> <ul> <li>Write access to dedicated gitStream app files: Used to set up the gitStream workflow files</li> <li>Write access to code: To allow gitStream to approve PRs once all conditions are met</li> <li>Read access to administration, issues, and metadata: To get user team membership and branch protection settings</li> <li>Read and write access to actions, checks, pull requests, and workflows: Trigger workflows, create and update pull requests and their checks, and modify workflow files</li> <li>User email: Used to identify users                                       |</li> </ul> <p>You need to enable these under the permissions section as shown below:</p> <p></p> <p>Tip</p> <p>Add the following Path (content paths to single files the app can access):</p> <ol> <li><code>.cm/gitstream.cm</code></li> <li><code>.github/workflows/gitstream.yml</code></li> </ol> <p> </p>"},{"location":"custom-github-app/#5-webhook-events-and-scope","title":"5. Webhook Events and Scope","text":"<ul> <li>Subscribe to events so gitStream is notified when a PR is created, changed, or commented on, etc</li> </ul> <p>Tip</p> <p>\"Where can this GitHub App be installed?\" choose \"Any account\" so other orgs in your company can use gitStream as well. For on-prem installations that work with github.com, only repositories under your company's org account can be accessed via gitStream.</p> <p></p>"},{"location":"custom-github-app/#6-generate-a-private-key","title":"6. Generate a Private Key","text":"<p>Once the app is created, scroll down and click Generate private key. This will create and download a .pem file for you.</p> <p>Tip</p> <p>Please keep this file safe, we'll need to put it back in LinearB setup.</p> <p></p>"},{"location":"custom-github-app/#7-upload-a-logo","title":"7. Upload a Logo","text":"<p>Download the logo file and upload the logo to your app.</p> <ul> <li>Black logo</li> <li>White logo</li> </ul>"},{"location":"custom-github-app/#8-get-app-configuration","title":"8. Get App Configuration","text":"<p>On your newly created app page, you can find the App ID.</p> <p>Tip</p> <p>Please keep the App ID, we'll need to put it back in LinearB setup.</p> <p></p>"},{"location":"custom-github-app/#9-finish-setup-in-linearb","title":"9. Finish Setup in LinearB","text":"<p>To complete the integration, fill in the App ID and Private Key in the LinearB setup screen.</p> <p>Tip</p> <p>Use the App ID, and Private key (.pem file) to complete the LinearB setup.</p> <p></p>"},{"location":"custom-github-app/#10-connect-github-app-to-your-repositories","title":"10. Connect GitHub App to Your Repositories","text":"<p>Go to your organization settings in GitHub and navigate to Third-party Access to manage GitHub Apps. Select the account where you want to install the gitStream app. Choose the organization you used to create the GitHub app in the previous steps.</p> <p>Alternatively, you can go directly to the app settings at <code>https://&lt;GITHUB_SERVER_URL&gt;/settings/apps/&lt;gitstream-app&gt;/installations</code> and add the app to the relevant organizations.</p> <p></p> <p>Choose the repositories you want to connect.</p> <p>Tip</p> <p>It's recommended to select All repositories, as it covers also future repositories.</p> <p></p>"},{"location":"custom-github-app/#11-finish-setting-up-gitstream","title":"11. Finish Setting Up gitStream","text":"<p>You can now set up gitStream for a single repo, your GitHub organization or across all the organizations in the server. Select the tab below for the instructions you want.</p> Single RepoGitHub OrganizationGitHub Multi Org <p>Single Repo Setup</p> <p>You must implement two main components for gitStream to function for a single GitHub repo. The first is a configuration file that defines the workflow automations to execute for the repo. The second is a GitHub actions configuration file that triggers gitStream when PRs are created or updated.</p> <p>Required Configurations</p> <p>gitStream</p> <p>Create a <code>.cm/gitstream.cm</code> rules file in your repository's default branch (usually <code>master</code> or <code>main</code>). This file will contain a YAML configuration that determines the workflows that run on the repo, and you can name it anything you want as long as it ends in <code>.cm</code></p> <p>Here is an example of a gitStream configuration file you can use to setup some basic workflow automations.</p> <pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlinearb_ai_codereview:\n# Ai Code Review - Triggers only when PR is ready for review, see docs https://docs.gitstream.cm/execution-model/#action-level-execution-control\non: [pr_created, pr_ready_for_review, merge]\nif:\n- {{ not is.bot }}\nrun:\n- action: code-review@v1\nargs:\nguidelines: |\n- Keep suggestions short and actionable.\npr_policy_low_noise:\non: [pr_created, commit]\nif:\n- {{ not pr.draft }}\n- {{ not is.bot }}\nrun:\n# AI description (updates PR body; not a comment)\n- action: describe-changes@v1\nargs:\nconcat_mode: append\n# Quiet labels\n- action: add-label@v1\nargs:\nlabel: \"{{ calc.etr }} min review\"\ncolor: {{ colors.red if (calc.etr &gt;= 20) else (colors.yellow if (calc.etr &gt;= 5) else colors.green) }}\n- action: add-label@v1\nwhen :  {{ pr.unresolved_threads }}\nargs:\nlabel: \"{{ pr.unresolved_threads | default(value=0) }} unresolved thread(s)\"\ncolor: {{ colors.yellow }}\n- action: add-label@v1\nwhen: {{ not (has.jira_ticket_in_title or has.jira_ticket_in_desc) }}\nargs:\nlabel: \"missing-jira\"\ncolor: {{ colors.red }}\n# further automations available with Jira webhook\n# Assign reviewers silently\n- action: add-reviewers@v1\nargs:\nreviewers: {{ who.experts }}\n# ONE consolidated, updatable comment\n- action: add-comment@v1\nargs:\ncomment: |\n## gitStream Summary \u2014 Low Noise (Staff Engineer focus)\n**AI PR Description:** Updated in the PR body above.\n**ETR:** {{ calc.etr }} min review\n**Unresolved threads:** {{ pr.unresolved_threads | default(value=0) }}\n### Suggested Reviewers (auto-assigned)\n{{ who.experts }}\n### Jira Reference\n{{ '\u2705 Found in title/description.' if (has.jira_ticket_in_title or has.jira_ticket_in_desc) else '\u26a0\ufe0f Missing Jira ticket. Please add one (e.g., `ABC-123` or an `atlassian.net/browse/...` link).' }}\n&gt; Labels/reviewers were applied quietly to keep this PR clean.\n# ----------------- config -----------------\ncalc:\netr: {{ branch | estimatedReviewTime }}\nhas:\njira_ticket_in_title: {{ pr.title       | includes(regex=r/\\b[A-Za-z][A-Za-z0-9_]+-\\d+\\b/) }}\njira_ticket_in_desc:  {{ pr.description | includes(regex=r/\\b[A-Za-z][A-Za-z0-9_]+-\\d+\\b/) }}\nwho:\nexperts: {{ repo | codeExperts(gt=10) }}\nis:\nbot: {{ pr.author | match(list=['github-actions','_bot_','[bot]','dependabot','gitstream-cm','prvalidation','aida-bot']) | some }}\ncolors:\nred:    'b60205'\nyellow: 'fbca04'\ngreen:  '0e8a16'\n</code></pre> <p>GitHub Actions Once your gitStream configuration file is setup, you need a GitHub Actions configuration file to trigger gitStream automations. Create a <code>.github/workflows/gitstream.yml</code> file in your repository's default branch (usually <code>master</code> or <code>main</code>) and add the following configuration:</p> <pre><code># Code generated by gitStream GitHub app - DO NOT EDIT\nname: gitStream workflow automation\nrun-name: |\n/:\\ gitStream: PR #${{ fromJSON(fromJSON(github.event.inputs.client_payload)).pullRequestNumber }} from ${{ github.event.inputs.full_repository }}\non:\nworkflow_dispatch:\ninputs:\nclient_payload:\ndescription: The Client payload\nrequired: true\nfull_repository:\ndescription: the repository name include the owner in `owner/repo_name` format\nrequired: true\nhead_ref:\ndescription: the head sha\nrequired: true\nbase_ref:\ndescription: the base ref\nrequired: true\ninstallation_id:\ndescription: the installation id\nrequired: false\nresolver_url:\ndescription: the resolver url to pass results to\nrequired: true\nresolver_token:\ndescription: Optional resolver token for resolver service\nrequired: false\ndefault: ''\njobs:\ngitStream:\ntimeout-minutes: 15\nruns-on: ubuntu-latest\nname: gitStream workflow automation\nsteps:\n- name: Adding PR Url\nrun: |\necho '[${{ fromJSON(fromJSON(inputs.client_payload)).repo }}#${{ fromJSON(fromJSON(inputs.client_payload)).prContext.number }}](${{ fromJSON(fromJSON(inputs.client_payload)).prContext.url }}) - `${{ fromJSON(fromJSON(inputs.client_payload)).branch }}` by ${{ fromJSON(fromJSON(inputs.client_payload)).prContext.author }}' &gt;&gt; $GITHUB_STEP_SUMMARY\n- name: Evaluate Rules\nuses: linear-b/gitstream-github-action@v2\nid: rules-engine\nwith:\nfull_repository: ${{ github.event.inputs.full_repository }}\nhead_ref: ${{ github.event.inputs.head_ref }}\nbase_ref: ${{ github.event.inputs.base_ref }}\nclient_payload: ${{ github.event.inputs.client_payload }}\ninstallation_id: ${{ github.event.inputs.installation_id }}\nresolver_url: ${{ github.event.inputs.resolver_url }}\nresolver_token: ${{ github.event.inputs.resolver_token }}\n</code></pre> <p>Success</p> <p>When finished, you should have the following file structure in your repo.</p> <pre><code>.\n\u251c\u2500 .cm/\n\u2502  \u2514\u2500 gitstream.cm\n\u251c\u2500 .github/\n\u2502  \u2514\u2500 workflows/\n\u2502     \u2514\u2500 gitstream.yml\n</code></pre> <p>GitHub Organization Setup</p> <p>Organization rules are ideal when you want to enforce consistent rules across every repo in your organization. You can define them by creating a special repository named <code>cm</code> in your GitHub organization where you can add automation files that will apply to all repositories within that organization.</p> <p>Prerequisite: Create a cm repo and enable gitStream.</p> <p>Organization-wide automations need to be defined in a repo named \"cm\" inside your GitHub organization. Before continuing, you must create this repo and enable the gitStream app for it.</p> <p>Required Configurations</p> <p>gitStream</p> <p>Create a <code>gitstream.cm</code> rules file in the root directory of your cm repository's default branch (usually <code>master</code> or <code>main</code>). This file will contain a YAML configuration that determines the workflows that run on your organization's repos. You can name it anything you want as long as it ends in <code>.cm</code></p> <p>Configuration files go in the repo's root directory.</p> <p>Unlike the set up instructions for a single repo, your <code>.cm</code> files should be placed in the repository's root directory.</p> <pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlinearb_ai_codereview:\n# Ai Code Review - Triggers only when PR is ready for review, see docs https://docs.gitstream.cm/execution-model/#action-level-execution-control\non: [pr_created, pr_ready_for_review, merge]\nif:\n- {{ not is.bot }}\nrun:\n- action: code-review@v1\nargs:\nguidelines: |\n- Keep suggestions short and actionable.\npr_policy_low_noise:\non: [pr_created, commit]\nif:\n- {{ not pr.draft }}\n- {{ not is.bot }}\nrun:\n# AI description (updates PR body; not a comment)\n- action: describe-changes@v1\nargs:\nconcat_mode: append\n# Quiet labels\n- action: add-label@v1\nargs:\nlabel: \"{{ calc.etr }} min review\"\ncolor: {{ colors.red if (calc.etr &gt;= 20) else (colors.yellow if (calc.etr &gt;= 5) else colors.green) }}\n- action: add-label@v1\nwhen :  {{ pr.unresolved_threads }}\nargs:\nlabel: \"{{ pr.unresolved_threads | default(value=0) }} unresolved thread(s)\"\ncolor: {{ colors.yellow }}\n- action: add-label@v1\nwhen: {{ not (has.jira_ticket_in_title or has.jira_ticket_in_desc) }}\nargs:\nlabel: \"missing-jira\"\ncolor: {{ colors.red }}\n# further automations available with Jira webhook\n# Assign reviewers silently\n- action: add-reviewers@v1\nargs:\nreviewers: {{ who.experts }}\n# ONE consolidated, updatable comment\n- action: add-comment@v1\nargs:\ncomment: |\n## gitStream Summary \u2014 Low Noise (Staff Engineer focus)\n**AI PR Description:** Updated in the PR body above.\n**ETR:** {{ calc.etr }} min review\n**Unresolved threads:** {{ pr.unresolved_threads | default(value=0) }}\n### Suggested Reviewers (auto-assigned)\n{{ who.experts }}\n### Jira Reference\n{{ '\u2705 Found in title/description.' if (has.jira_ticket_in_title or has.jira_ticket_in_desc) else '\u26a0\ufe0f Missing Jira ticket. Please add one (e.g., `ABC-123` or an `atlassian.net/browse/...` link).' }}\n&gt; Labels/reviewers were applied quietly to keep this PR clean.\n# ----------------- config -----------------\ncalc:\netr: {{ branch | estimatedReviewTime }}\nhas:\njira_ticket_in_title: {{ pr.title       | includes(regex=r/\\b[A-Za-z][A-Za-z0-9_]+-\\d+\\b/) }}\njira_ticket_in_desc:  {{ pr.description | includes(regex=r/\\b[A-Za-z][A-Za-z0-9_]+-\\d+\\b/) }}\nwho:\nexperts: {{ repo | codeExperts(gt=10) }}\nis:\nbot: {{ pr.author | match(list=['github-actions','_bot_','[bot]','dependabot','gitstream-cm','prvalidation','aida-bot']) | some }}\ncolors:\nred:    'b60205'\nyellow: 'fbca04'\ngreen:  '0e8a16'\n</code></pre> <p>GitHub Actions</p> <p>Once your gitStream configuration file is set up, you will need to create a GitHub Actions configuration file to trigger gitStream automations. Create a <code>.github/workflows/gitstream.yml</code> file in your <code>cm</code> repository's default branch (usually <code>master</code> or <code>main</code>) and add the following configuration:</p> <pre><code># Code generated by gitStream GitHub app - DO NOT EDIT\nname: gitStream workflow automation\nrun-name: |\n/:\\ gitStream: PR #${{ fromJSON(fromJSON(github.event.inputs.client_payload)).pullRequestNumber }} from ${{ github.event.inputs.full_repository }}\non:\nworkflow_dispatch:\ninputs:\nclient_payload:\ndescription: The Client payload\nrequired: true\nfull_repository:\ndescription: the repository name include the owner in `owner/repo_name` format\nrequired: true\nhead_ref:\ndescription: the head sha\nrequired: true\nbase_ref:\ndescription: the base ref\nrequired: true\ninstallation_id:\ndescription: the installation id\nrequired: false\nresolver_url:\ndescription: the resolver url to pass results to\nrequired: true\nresolver_token:\ndescription: Optional resolver token for resolver service\nrequired: false\ndefault: ''\njobs:\ngitStream:\ntimeout-minutes: 15\nruns-on: ubuntu-latest\nname: gitStream workflow automation\nsteps:\n- name: Adding PR Url\nrun: |\necho '[${{ fromJSON(fromJSON(inputs.client_payload)).repo }}#${{ fromJSON(fromJSON(inputs.client_payload)).prContext.number }}](${{ fromJSON(fromJSON(inputs.client_payload)).prContext.url }}) - `${{ fromJSON(fromJSON(inputs.client_payload)).branch }}` by ${{ fromJSON(fromJSON(inputs.client_payload)).prContext.author }}' &gt;&gt; $GITHUB_STEP_SUMMARY\n- name: Evaluate Rules\nuses: linear-b/gitstream-github-action@v2\nid: rules-engine\nwith:\nfull_repository: ${{ github.event.inputs.full_repository }}\nhead_ref: ${{ github.event.inputs.head_ref }}\nbase_ref: ${{ github.event.inputs.base_ref }}\nclient_payload: ${{ github.event.inputs.client_payload }}\ninstallation_id: ${{ github.event.inputs.installation_id }}\nresolver_url: ${{ github.event.inputs.resolver_url }}\nresolver_token: ${{ github.event.inputs.resolver_token }}\n</code></pre> <p>Success</p> <p>Once finished, all PRs to your organization's repositories will be processed by the GitHub Action in this repo, and your <code>cm</code> repo should have a file directory that looks like this.</p> <p>``` . \u251c\u2500 gitstream.cm \u251c\u2500 .github/ \u2502  \u2514\u2500 workflows/ \u2502     \u2514\u2500 gitstream.yml</p> <p>GitHub Multi Org Setup</p> <p>Multi-org rules are ideal when you want to enforce consistent rules across every repo across multiple organizations on your server. You can define them by creating a special repository named <code>cm</code> under the <code>cm</code> organization in your GitHub Server where you can add automation files that will apply to all repositories across all organizations.</p> <p>Prerequisite: Create a cm repo under the cm org and enable gitStream.</p> <p>Multi-org automations need to be defined in a repo named <code>cm</code> inside the <code>cm</code> organization on your GitHub Server. Before continuing, you must create this repo and enable the gitStream app for it.</p> <p>Required Configurations</p> <p>gitStream</p> <p>Create a <code>gitstream.cm</code> rules file in the root directory of the <code>cm</code> repository's default branch (usually <code>master</code> or <code>main</code>). This file will contain a YAML configuration that determines the workflows that run on your server's repos. You can name it anything you want as long as it ends in <code>.cm</code></p> <p>Configuration files go in the repo's root directory.</p> <p>Unlike the setup instructions for a single repo, your <code>.cm</code> files should be placed in the repository's root directory.</p> <pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlinearb_ai_codereview:\n# Ai Code Review - Triggers only when PR is ready for review, see docs https://docs.gitstream.cm/execution-model/#action-level-execution-control\non: [pr_created, pr_ready_for_review, merge]\nif:\n- {{ not is.bot }}\nrun:\n- action: code-review@v1\nargs:\nguidelines: |\n- Keep suggestions short and actionable.\npr_policy_low_noise:\non: [pr_created, commit]\nif:\n- {{ not pr.draft }}\n- {{ not is.bot }}\nrun:\n# AI description (updates PR body; not a comment)\n- action: describe-changes@v1\nargs:\nconcat_mode: append\n# Quiet labels\n- action: add-label@v1\nargs:\nlabel: \"{{ calc.etr }} min review\"\ncolor: {{ colors.red if (calc.etr &gt;= 20) else (colors.yellow if (calc.etr &gt;= 5) else colors.green) }}\n- action: add-label@v1\nwhen :  {{ pr.unresolved_threads }}\nargs:\nlabel: \"{{ pr.unresolved_threads | default(value=0) }} unresolved thread(s)\"\ncolor: {{ colors.yellow }}\n- action: add-label@v1\nwhen: {{ not (has.jira_ticket_in_title or has.jira_ticket_in_desc) }}\nargs:\nlabel: \"missing-jira\"\ncolor: {{ colors.red }}\n# further automations available with Jira webhook\n# Assign reviewers silently\n- action: add-reviewers@v1\nargs:\nreviewers: {{ who.experts }}\n# ONE consolidated, updatable comment\n- action: add-comment@v1\nargs:\ncomment: |\n## gitStream Summary \u2014 Low Noise (Staff Engineer focus)\n**AI PR Description:** Updated in the PR body above.\n**ETR:** {{ calc.etr }} min review\n**Unresolved threads:** {{ pr.unresolved_threads | default(value=0) }}\n### Suggested Reviewers (auto-assigned)\n{{ who.experts }}\n### Jira Reference\n{{ '\u2705 Found in title/description.' if (has.jira_ticket_in_title or has.jira_ticket_in_desc) else '\u26a0\ufe0f Missing Jira ticket. Please add one (e.g., `ABC-123` or an `atlassian.net/browse/...` link).' }}\n&gt; Labels/reviewers were applied quietly to keep this PR clean.\n# ----------------- config -----------------\ncalc:\netr: {{ branch | estimatedReviewTime }}\nhas:\njira_ticket_in_title: {{ pr.title       | includes(regex=r/\\b[A-Za-z][A-Za-z0-9_]+-\\d+\\b/) }}\njira_ticket_in_desc:  {{ pr.description | includes(regex=r/\\b[A-Za-z][A-Za-z0-9_]+-\\d+\\b/) }}\nwho:\nexperts: {{ repo | codeExperts(gt=10) }}\nis:\nbot: {{ pr.author | match(list=['github-actions','_bot_','[bot]','dependabot','gitstream-cm','prvalidation','aida-bot']) | some }}\ncolors:\nred:    'b60205'\nyellow: 'fbca04'\ngreen:  '0e8a16'\n</code></pre> <p>GitHub Actions</p> <p>Once your gitStream configuration file is set up, you will need to create a GitHub Actions configuration file to trigger gitStream automations. Create a <code>.github/workflows/gitstream.yml</code> file in your <code>cm</code> repository's default branch (usually <code>master</code> or <code>main</code>) and add the following configuration:</p> <pre><code># Code generated by gitStream GitHub app - DO NOT EDIT\nname: gitStream workflow automation\nrun-name: |\n/:\\ gitStream: PR #${{ fromJSON(fromJSON(github.event.inputs.client_payload)).pullRequestNumber }} from ${{ github.event.inputs.full_repository }}\non:\nworkflow_dispatch:\ninputs:\nclient_payload:\ndescription: The Client payload\nrequired: true\nfull_repository:\ndescription: the repository name include the owner in `owner/repo_name` format\nrequired: true\nhead_ref:\ndescription: the head sha\nrequired: true\nbase_ref:\ndescription: the base ref\nrequired: true\ninstallation_id:\ndescription: the installation id\nrequired: false\nresolver_url:\ndescription: the resolver url to pass results to\nrequired: true\nresolver_token:\ndescription: Optional resolver token for resolver service\nrequired: false\ndefault: ''\njobs:\ngitStream:\ntimeout-minutes: 15\nruns-on: ubuntu-latest\nname: gitStream workflow automation\nsteps:\n- name: Adding PR Url\nrun: |\necho '[${{ fromJSON(fromJSON(inputs.client_payload)).repo }}#${{ fromJSON(fromJSON(inputs.client_payload)).prContext.number }}](${{ fromJSON(fromJSON(inputs.client_payload)).prContext.url }}) - `${{ fromJSON(fromJSON(inputs.client_payload)).branch }}` by ${{ fromJSON(fromJSON(inputs.client_payload)).prContext.author }}' &gt;&gt; $GITHUB_STEP_SUMMARY\n- name: Evaluate Rules\nuses: linear-b/gitstream-github-action@v2\nid: rules-engine\nwith:\nfull_repository: ${{ github.event.inputs.full_repository }}\nhead_ref: ${{ github.event.inputs.head_ref }}\nbase_ref: ${{ github.event.inputs.base_ref }}\nclient_payload: ${{ github.event.inputs.client_payload }}\ninstallation_id: ${{ github.event.inputs.installation_id }}\nresolver_url: ${{ github.event.inputs.resolver_url }}\nresolver_token: ${{ github.event.inputs.resolver_token }}\n</code></pre> <p>Success</p> <p>Once finished, the GitHub Action will process all PRs to repositories across all organizations on your server in this repo. Your <code>cm</code> repo under the <code>cm</code> org should have a file directory that looks like this.</p> <pre><code>.\n\u251c\u2500 gitstream.cm\n\u251c\u2500 .github/\n\u2502  \u2514\u2500 workflows/\n\u2502     \u2514\u2500 gitstream.yml\n</code></pre>"},{"location":"custom-github-app/#12-github-enterprise-setup","title":"12. GitHub Enterprise Setup","text":"<p>When running gitStream on GitHub Enterprise, you need to manually \"clone\" the following actions since runners don't connect to the internet:</p> <ol> <li>gitStream action: <code>gitstream-github-action</code></li> <li>Official GitHub actions like: <code>actions/checkout</code>, <code>actions/setup-node</code>, <code>actions/github-script</code>, etc.</li> </ol> <p>You'll need to pull these actions manually so the runner can use them.</p>"},{"location":"dry-run-mode/","title":"How to Test Your Automation","text":"<p>Testing your gitStream automations ensures they work as expected before applying them to your live pull requests. gitStream provides two easy ways to safely test your automations:</p>"},{"location":"dry-run-mode/#1-dry-run-mode","title":"1. Dry Run Mode","text":"<p>Dry Run mode is automatically enabled whenever you open a PR that modifies any of your <code>.cm</code> automation files. In Dry Run mode:</p> <ul> <li>gitStream evaluates automations based on code changes made to non-automation files (your repository's codebase).</li> <li>Automations are evaluated without being executed.</li> <li>Results are added as comments on your pull request, showing exactly what actions would have occurred.</li> <li>Each new commit triggers an updated comment describing the changes.</li> </ul> <p></p> <p>Note</p> <p>While in Dry Run mode, no automation changes actually take effect. To apply your automations, merge your PR after validation.</p> <p>If you encounter issues while testing, refer to our Troubleshooting page for guidance.</p>"},{"location":"dry-run-mode/#2-using-the-playground","title":"2. Using the Playground","text":"<p>You can also test automations interactively using the gitStream Playground. The Playground offers an intuitive environment to preview how automations behave, allowing you to instantly adjust and perfect your rules.</p> <p>Select the method most convenient for your workflow, or use both methods together for comprehensive testing. Once satisfied with the results, merge your <code>.cm</code> changes into the main branch to enable the new automations.</p>"},{"location":"examples/","title":"gitStream Quickstart","text":"<p>This page contains common gitStream configurations that are a great place to begin adopting a continuous merge mindset with gitStream. If you haven't already, you'll need to install gitStream to your GitHub or GitLab organization before you can use these automations.</p> <p>Build your first gitStream automation in as little as two minutes.</p> <p>These examples are complete gitStream configuration files that you can download directly via the buttons below the examples and upload to the <code>.cm</code> directory of your repo. Alternatively, you can copy and paste the individual automations, but make sure you include all required declarations and any related custom expressions from the configuration to ensure everything works properly. </p>"},{"location":"examples/#improve-pr-context-with-label-automation","title":"Improve PR Context with Label Automation","text":"<p>This CM automation contains a collection of workflows to automatically apply labels to provide deeper context to code reviewers to help them more quickly triage and address incoming requests for reviews. Ideally, you should implement these automations across your entire git organization to maximize developer usage. </p> <p>The following example includes workflow automations to do the following:</p> <ul> <li>Apply color-coded labels that estimate how long it takes to review the PR.</li> <li>Flag PRs that lack required references to Jira tickets. Check out the gitStream integrations page for more examples of third-party project management tools gitStream integrates with.</li> <li>Label PRs that have unresolved change requests, or delete code.</li> </ul> <p></p> <p>Label Management with gitStream</p> <p><pre><code># -*- mode: yaml -*-\n# +----------------------------------------------------------------------------+\n# | /:\\ gitStream: Workflow automation for the code review process.            |\n# +----------------------------------------------------------------------------+\n# | This file contains one or more /:\\ gitStream automations:                  |\n# | https:// docs.gitstream.cm                                                 |\n# |                                                                            |\n# | gitStream uses YAML syntax with nunjucks templating via Jinja 2.           |\n# |                                                                            |\n# | Automations follow an \"if this, then that\" execution format.               |\n# | More info here: https://docs.gitstream.cm/how-it-works/                    |\n# |                                                                            |\n# +----------------------------------------------------------------------------+\n# /:\\ gitStream Reference Docs: \n#    Context Variables: https://docs.gitstream.cm/context-variables/\n#    Filter Functions: https://docs.gitstream.cm/filter-functions/\n#    Automation Actions: https://docs.gitstream.cm/automation-actions/\nmanifest:\nversion: 1.0\n# +----------------------------------------------------------------------------+\n# | Automations\n# +----------------------------------------------------------------------------+\nautomations:\n# Apply color coded labels to PRs based on the estimated time to review.\n# https://docs.gitstream.cm/automations/provide-estimated-time-to-review/\nestimated_time_to_review:\nif:\n- true\nrun:\n- action: add-label@v1\nargs:\nlabel: \"{{ calc.etr }} min review\"\ncolor: {{ colors.red if (calc.etr &gt;= 20) else ( colors.yellow if (calc.etr &gt;= 5) else colors.green ) }}\n# Flag PRs that are missing a Jira ticket reference in the title or description.\n# https://docs.gitstream.cm/integrations/jira/\nlabel_missing_jira_info:\nif:\n- {{ not (has.jira_ticket_in_title or has.jira_ticket_in_desc) }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"missing-jira\"\ncolor: {{ colors.red }}\n# Flag PRs that have unresolved comment threads.\n# https://docs.gitstream.cm/automations/standard/label-management/label-unresolved-threads/\nlabel_unresolved_threads:  if:\n- {{ pr.status == 'open' }}\n- {{ pr.unresolved_threads &gt; 0 }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \ud83d\udea8 {{ pr.unresolved_threads }} Unresolved Thread(s)\ncolor: {{ colors.yellow }}  # Flag PRs that delete files to highlight potential refactors that need extra scrutiny.\n# https://docs.gitstream.cm/automations/label-deleted-files/\nflag_deleted_files:\nif:\n- {{ has.deleted_files }}\nrun: - action: add-label@v1\nargs:\nlabel: \ud83d\uddd1\ufe0f Deleted files\ncolor: {{ colors.orange }}\n# +----------------------------------------------------------------------------+\n# | Custom Expressions                                                         |\n# | https://docs.gitstream.cm/how-it-works/#custom-expressions                 |\n# +----------------------------------------------------------------------------+\n# https://docs.gitstream.cm/filter-functions/#estimatedreviewtime\ncalc:\netr: {{ branch | estimatedReviewTime }}\nhas:\njira_ticket_in_title: {{ pr.title | includes(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\njira_ticket_in_desc: {{ pr.description | includes(regex=r/atlassian.net\\/browse\\/\\w{1,}-\\d{3,4}/) }}\ndeleted_files: {{ source.diff.files | map(attr='new_file') | match(term='/dev/null') | some }}\n# These are all of the colors in GitHub's default label color palette.\ncolors:\nred: 'b60205'\norange: 'd93f0b'\nyellow: 'fbca04'\ngreen: '0e8a16'\nblue: '1d76db'\npurple: '5319e7'\n</code></pre>  Download this example as a CM file. </p>"},{"location":"examples/#automatically-route-pr-reviews","title":"Automatically Route PR Reviews","text":"<p>If you're ready to begin automatically routing PRs for review, the best solution is to classify PRs according to the amount of risk they create. This next example classifies PRs into one of three categories based on the changes they contain and automatically establishes review criteria.</p> <p>The following example includes workflow automations to do the following:</p> <ul> <li>Recommend the most knowledgeable code experts to review the PR.</li> <li>Automatically approve low-risk PRs to docs, testing, or code formatting.</li> <li>Define criteria for when PRs need one or more reviews.</li> <li>Label PRs that are available to be cherry picked to merge into the next release.</li> </ul> <p></p> <p>Review Routing with gitStream</p> <p><pre><code># -*- mode: yaml -*-\n# +----------------------------------------------------------------------------+\n# | WARNING: This file controls repo automations, use caution when modifying   |\n# +----------------------------------------------------------------------------+\n# | This file contains one or more /:\\ gitStream automations:                  |\n# | https:// docs.gitstream.cm                                                 |\n# |                                                                            |\n# | gitStream uses YAML syntax with nunjucks templating via Jinja 2.           |\n# |                                                                            |\n# | Automations follow an \"if this, then that\" execution format.               |\n# | More info here: https://docs.gitstream.cm/how-it-works/                    |\n# |                                                                            |\n# +----------------------------------------------------------------------------+\n# /:\\ gitStream Reference Docs: \n#    Context Variables: https://docs.gitstream.cm/context-variables/\n#    Filter Functions: https://docs.gitstream.cm/filter-functions/\n#    Automation Actions: https://docs.gitstream.cm/automation-actions/\nmanifest:\nversion: 1.0\n# +----------------------------------------------------------------------------+\n# | Customize This Section                                                     |\n# +----------------------------------------------------------------------------+\n# Change review_team to match your organization or repo's primary review team. \n# The format is Git Organization Name / Team Name\nreview_team: 'my-org/team-name'\n# List of files that should trigger a sensitive file change review.\nsensitive:\n- App.tsx\n- AppRoot.tsx\n# Files to exclude from gitStream automations.\nconfig:\nignore_files:\n- 'yarn.lock'\n- 'ios/*.lock'\n- 'android/*.lock'\n# Set long_review_threshold to the number of minutes that should trigger extra review requirements.\nlong_review_threshold: 5\n# +----------------------------------------------------------------------------+\n# | Automations\n# +----------------------------------------------------------------------------+\nautomations:\n# Post a comment that recommends reviewers based on their knowledge of the files in the PR.\n# https://docs.gitstream.cm/automations/standard/explain-code-experts/\nexplain_code_experts:\n# Alternatively, if you only want to trigger when the slash command `/gitstream suggest-reviewers` is included in a comment,\n# change '- true' to '- {{ (pr.comments | match(attr='content', term='/gitstream suggest-reviewers') | some) }}'\nif:\n- true\nrun:\n- action: explain-code-experts@v1 args:\ngt: 10\n# Automatically approve changes that only affect formatting, documentation, tests, or images\n# https://docs.gitstream.cm/automations/approve-safe-changes/\napprove_safe_changes:\nif:\n- {{ is.safe_change }}\n# Apply a safe change label, approve the PR and explain why in a comment.\nrun: - action: add-label@v1\nargs:\nlabel: 'Safe Change'\ncolor: {{ colors.green }}\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR is considered a safe change and has been automatically approved.\n# Set criteria for PRs that only need one reviewer.\n# This helps reduce the review burden for low-risk PRs.\nrequire_one_review:\nif:\n- {{ not has.sensitive_files }}\n- {{ is.quick_review }}\n- {{ approvals.zero }}\nrun:\n- action: add-label@v1\nargs: label: \u23f3 Waiting for 1 reviewer\ncolor: {{ colors.yellow }}\n- action: add-reviewers@v1\nargs:\nreviewers: [{{ review_team }}]\nunless_reviewers_set: true\n- action: set-required-approvals@v1\nargs:\napprovals: 1\n# Set criteria for PRs that need extra reviewers.\n# This helps bring in extra scrutiny for large PRs or PRs that touch sensitive parts of the code.\nrequire_two_reviews:\nif:\n- {{ is.long_review or has.sensitive_files }}\n- {{ approvals.ltTwo }}\nrun:\n- action: add-label@v1\nargs: label: {{ '\u23f3 Waiting for 2 reviewers' if (approvals.zero) else '\u23f3 Waiting for 1 reviewer' }}\ncolor: {{ colors.yellow }}\n- action: add-reviewers@v1\nargs:\nreviewers: [{{ review_team }}]\nunless_reviewers_set: true\n- action: set-required-approvals@v1\nargs:\napprovals: 2\n# Flag low-risk PRs that are ready to merge.\nflag_quick_review_merge:\nif:\n- {{ not has.sensitive_files }}\n- {{ is.quick_review }}\n- {{ not has.do_not_merge_label }}\n- {{ approvals.gtZero }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \u270c\ufe0f Ready to merge\ncolor: {{ colors.green }}\n# Flag higher risk PRs that are ready to merge.\nflag_large_review_merge:\nif:\n- {{ is.long_review or has.sensitive_files }}\n- {{ approvals.gtOne }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \u270c\ufe0f Ready to merge\ncolor: {{ colors.green }}\n# +----------------------------------------------------------------------------+\n# | Custom Expressions                                                         |\n# | https://docs.gitstream.cm/how-it-works/#custom-expressions                 |\n# +----------------------------------------------------------------------------+\n# https://docs.gitstream.cm/filter-functions/#estimatedreviewtime\ncalc:\netr: {{ branch | estimatedReviewTime }}\nhas:\nsensitive_files: {{ files | match(list=sensitive) | some }}\ndo_not_merge_label: {{ pr.labels | match(term='Do not merge') | some }}\nis:\nsafe_change: {{ (source.diff.files | isFormattingChange) or (files | allDocs) or (files | allTests) or (files | allImages) }}\nquick_review: {{ files | length &lt;= 7 and calc.etr &lt;= long_review_threshold }}\nlong_review: {{ files | length &gt; 7 or calc.etr &gt; long_review_threshold }}\napprovals:\nzero: {{ pr.approvals | length == 0 }}\ngtZero: {{ pr.approvals | length &gt; 0 }}\ngtOne: {{ pr.approvals | length &gt; 1 }}\nltTwo: {{ pr.approvals | length &lt; 2 }}\n# These are all of the colors in GitHub's default label color palette.\ncolors:\nred: 'b60205'\norange: 'd93f0b'\nyellow: 'fbca04'\ngreen: '0e8a16'\nblue: '1d76db'\npurple: '5319e7'\n</code></pre>  Download this example as a CM file. </p>"},{"location":"examples/#next-step","title":"Next Step","text":"<p>For a more detailed list of automations, check out the gitStream integrations page or automation library.</p>"},{"location":"execution-model/","title":"Trigger Control","text":"<p>Platform Limitations</p> <p>Explicit triggers (using <code>on</code>, <code>triggers.on</code>, <code>triggers.include</code>, and <code>triggers.exclude</code> parameters) are only supported on GitHub . </p> <p>Using explicit triggers in GitLab or Bitbucket will cause the automation to fail with an error. For GitLab and Bitbucket, simply omit trigger configuration to use implicit triggers automatically.</p> <p>However, other execution control concepts covered in this document, such as action-level execution control, apply to all supported platforms (GitHub, GitLab, and Bitbucket).</p> <p>gitStream is triggered on new pull requests (PRs) for repositories that have gitStream installed. Upon triggering, gitStream collects context variables and evaluates the automation rules to determine which ones are relevant.</p>"},{"location":"execution-model/#organization-level-rules-and-repository-rules","title":"Organization-level rules and repository rules","text":"<p>When a central <code>cm</code> repository is set with the CI/CD runner, the events for PRs from all installed repositories shall be evaluated in the <code>cm</code> repository pipeline, considering the organization-level and PR repository rules.</p>"},{"location":"execution-model/#execution-behavior-for-free-accounts","title":"Execution behavior for free accounts","text":"<p>Free accounts have a monthly limit on the number of PRs that can trigger automations. Once this limit is reached:</p> <ul> <li>PRs will still be created, but gitStream will skip automations for them.</li> <li>The gitStream check on these PRs will be concluded as <code>Skipped</code>, to ensure that gitStream will not block the PR from merging.</li> <li>A warning is displayed in PR comments when the organization reaches 90% of its quota.</li> <li>The limit resets at the start of each month.</li> </ul> <p>To remove automation limits, Contact LinearB and upgrade to a paid plan. \ud83d\udd17 Learn more: Automation Limits</p>"},{"location":"execution-model/#triggering-mechanism","title":"Triggering Mechanism","text":"<p>gitStream automations are triggered by events related to pull requests (PRs). You can specify triggers to fine-tune which events should initiate automations.</p>"},{"location":"execution-model/#implicit-triggers","title":"Implicit triggers","text":"<p>By default, gitStream evaluates any new commit pushed to the PR, triggering automation evaluation.</p> <p>Additionally, if any of the automation rules reference the following <code>pr</code> context variables: <code>pr.comments</code>, <code>pr.title</code>, <code>pr.description</code>, or <code>pr.labels</code>, gitStream shall trigger and will initiate automation rules evaluation where there are changes to the PR comments, title, description, or labels respectively.</p> <p>This allows for greater flexibility in the automation process, ensuring that the relevant automation rules are evaluated and triggered when necessary. The execution model ensures the automation process is streamlined, efficient, and effective.</p>"},{"location":"execution-model/#explicit-triggers","title":"Explicit triggers","text":"<p>gitstream supports an explicit triggering mechanism. When using explicit triggers, the automations will run only according to the defined triggers, which means the Implicit triggers will not work. Automations triggered by explicit triggers will also be invoked on <code>draft</code> PRs</p> <p>Triggers can be defined globally at the file level or specifically for each automation. Triggers are applied only to the file(s) where they are declared.</p> <p>When Implicit Triggers Are Disabled</p> <p>Implicit triggers are disabled ONLY when using <code>triggers.on</code> (file-level) or <code>on</code> (automation-level) - these parameters define explicit triggering events and completely override the default implicit trigger behavior.</p> <p>When using ONLY <code>triggers.include</code> or <code>triggers.exclude</code> implicit triggers remain active - these parameters filter which branches/repositories run automations but do not change the triggering events themselves.</p> <p>Combining File-Level and Automation-Level Triggers</p> <p>When both file-level explicit triggers and automation-level explicit triggers exist, the actual triggers used will be the result of unifying both lists. This means the automation will be triggered by any event specified in either the file-level triggers or the automation-level triggers.</p>"},{"location":"execution-model/#triggers-section","title":"<code>triggers</code> section","text":"<p>The <code>triggers</code> section in gitStream gives you precise control over when automations execute. It allows you to define conditions based on pull request events using <code>include</code> and <code>exclude</code> lists to specify branch, repository, and user patterns. These lists determine which branches, repositories, or users trigger or bypass automation but do not affect the events initiating automations - implicit triggers remain active when using only <code>include</code> and <code>exclude</code>.</p> <p>Additionally, the <code>on</code> keyword defines specific events that trigger automations. It can be added at the file level (under the <code>triggers</code> section) or within individual automations for greater customization. When <code>on</code> is used, it switches from implicit to explicit triggering mode, meaning only the specified events will trigger automations. Multiple triggers can be stacked, meaning gitStream will execute the automation for each matching triggering event, allowing flexibility in defining automation behavior</p> Key Type Description <code>triggers.on</code> [String] Specifies the explicit triggers that initiate the automations. <code>triggers.include.branch</code> [String or regex] Branches that match will trigger the automation. <code>triggers.exclude.branch</code> [String or regex] Branches that match will not trigger the automation. <code>triggers.include.repository</code> [String or regex] Repositories that match will trigger the automation. <code>triggers.exclude.repository</code> [String or regex] Repositories that match will not trigger the automation. <code>triggers.include.user</code> [String or regex] Users that match will trigger the automation. <code>triggers.exclude.user</code> [String or regex] Users that match will not trigger the automation. <p>Default Behavior</p> <ul> <li>Implicit triggers are the default behavior if the automation doesn't have explicit triggers configured.</li> <li>The automation runs for all branches, repositories, and users if neither include nor exclude is specified.</li> </ul>"},{"location":"execution-model/#trigger-events","title":"Trigger Events","text":"<p>The table below lists supported explicit triggers, categorized into those enabled by default and those that require manual activation.</p> Triggering event Explicit Trigger  Default Conditions Checks finished - <code>on</code> when an automation uses the <code>wait_for_all_checks</code> action Comment added <code>comment_added</code> <code>on</code> when <code>pr</code> context is used in <code>.cm</code> Comment edited  - <code>on</code> when <code>pr</code> context is used in <code>.cm</code> Commit pushed <code>commit</code> <code>on</code> Creating a PR <code>pr_created</code> <code>on</code> when not a draft Description changed - <code>on</code> when <code>pr</code> context is used in <code>.cm</code> Label added <code>label_added</code> <code>on</code> when <code>pr</code> context is used in <code>.cm</code> Label removed <code>label_removed</code> <code>on</code> when <code>pr</code> context is used in <code>.cm</code> Merging the PR  <code>merge</code> <code>off</code> Title changed - <code>on</code> when <code>pr</code> context is used in <code>.cm</code> Transition from draft to ready for review <code>pr_ready_for_review</code> <code>on</code> Transition from any state to closed  <code>pr_closed</code> <code>off</code> Transition from closed to open  <code>pr_reopened</code> <code>off</code> Transition from any state to approved  <code>pr_approved</code> <code>on</code> when actions <code>require-reviewers</code>, <code>set-required-approvals</code>, or <code>merge</code> are used, or when <code>pr</code> context is used in <code>.cm</code> <p>Explicit triggers (using <code>on</code>) are set independently per each automation block and can be configured at the file level, specific to each automation separately or in combination. If triggers are listed at the file level and specific automation, the automation will be triggered according to both triggers. If an automation block does not have the <code>on</code> parameter configured (explicit triggers), it will be triggered according to the default (implicit) triggers, even if <code>triggers.include</code> or <code>triggers.exclude</code> are used at the file level.</p> <p>Note</p> <p>The <code>on</code> parameter can be used within individual automation blocks, while <code>triggers.include</code> and <code>triggers.exclude</code> can only be defined at the file level.</p>"},{"location":"execution-model/#branch-filtering","title":"Branch Filtering","text":"<p>Branch filtering allows you to control which branches can trigger automations based on branch name patterns.</p> <p>Note on Matching:</p> <ul> <li>When using a <code>String</code> as the matching type, the values in <code>triggers.include.branch</code> and <code>triggers.exclude.branch</code> require exact matches. This means that the names of branches must exactly match the specified string to either trigger or prevent triggering the automation.</li> <li>For more precise control, use a regular expression (regex) format: <code>r/REGEX_PATTERN/</code>.</li> </ul>"},{"location":"execution-model/#repository-filtering","title":"Repository Filtering","text":"<p>Repository filtering allows you to control which repositories can trigger automations based on repository name patterns.</p> <p>Note on Matching:</p> <ul> <li>When using a <code>String</code> as the matching type, the values in <code>triggers.include.repository</code> and <code>triggers.exclude.repository</code> require exact matches. This means that the names of repositories must exactly match the specified string to either trigger or prevent triggering the automation.</li> <li>For more precise control, use a regular expression (regex) format: <code>r/REGEX_PATTERN/</code>.</li> </ul> <p>Exclude/Include prioritization</p> <ul> <li> <p>Exclude overrides the include option. Thus, a repo will be excluded when it matches the include and exclude lists.</p> <p>In the following example, the automations in the file will be triggered for all repositories that contain the string <code>feature</code>, except for the repository <code>my_feature</code> <pre><code>triggers:\ninclude:\nrepository:\n- r/feature/\nexclude:\nrepository:\n- my_feature\n</code></pre></p> </li> </ul>"},{"location":"execution-model/#user-filtering","title":"User Filtering","text":"<p>User filtering allows you to control which users can trigger automations, enabling you to exclude bot accounts or include only specific team members. This helps reduce noise from automated tools and optimize automation quota usage.</p> <p>User Identification: The user is matched against the event actor:</p> <ul> <li>For commits: the commit author</li> <li>For PR creation: the PR author  </li> <li>For label changes: the user who added/removed the label</li> <li>For comments: the commenter</li> <li>For approvals: the approver</li> </ul> <p>Common Use Cases:</p> <ul> <li>Exclude bots: Prevent automations from running when triggered by SonarQube, Dependabot, Renovate, or security scanners</li> <li>Include specific users: Run automations only for specific team members or service accounts</li> <li>Reduce noise: Filter out automated tool activity that doesn't require gitStream processing</li> </ul> <p>Note on Matching:</p> <ul> <li>When using a <code>String</code> as the matching type, the values in <code>triggers.include.user</code> and <code>triggers.exclude.user</code> require exact matches. This means that the names of users must exactly match the specified string to either trigger or prevent triggering the automation.</li> <li>For more precise control, use a regular expression (regex) format: <code>r/REGEX_PATTERN/</code>.</li> </ul>"},{"location":"execution-model/#action-level-execution-control","title":"Action-Level Execution Control","text":"<p>gitStream provides intelligent action-level execution control that automatically skips certain actions based on the original triggering event. This feature helps reduce noise and ensures that AI-powered and code-related actions only execute when there are actual code changes, improving efficiency across all supported providers (GitLab, Bitbucket, and GitHub).</p>"},{"location":"execution-model/#how-it-works","title":"How It Works","text":"<p>When an automation is triggered, gitStream evaluates each action individually against the original triggering event. Some actions are automatically skipped if the triggering event is not relevant to their purpose.</p> <p>Explicit Triggers Override</p> <p>When explicit triggers are configured (using the <code>on</code> or <code>triggers</code> parameters), they take precedence over the automatic skip mechanism. This means actions will execute for all explicitly defined triggers, regardless of the action-level execution rules below.</p>"},{"location":"execution-model/#action-execution-rules","title":"Action Execution Rules","text":"<p>The following table shows which actions are restricted to code-related triggering events:</p> Action Executes Only On Behavior on Other Triggers <code>add-code-comment</code> Commit pushed, Creating a PR (not draft), PR ready for review Skipped <code>code-review</code> Commit pushed, Creating a PR (not draft), PR ready for review Skipped <code>describe-changes</code> Commit pushed, Creating a PR (not draft), PR ready for review Skipped <code>explain-code-experts</code> Commit pushed, Creating a PR (not draft), PR ready for review Skipped All other actions Current defaults (no restrictions) Executed"},{"location":"execution-model/#examples","title":"Examples","text":""},{"location":"execution-model/#scenario-ai-code-review-with-explicit-triggers","title":"Scenario: AI Code Review with Explicit Triggers","text":"<pre><code>automations:\nai_code_review:\non:\n- commit\n- label_added\nif:\n- true\nrun:\n- action: code-review@v1        # Executes on both commit and label_added (explicit triggers override skip rules)\n- action: add-label@v1          # Executes on both commit and label_added\nargs:\nlabel: \"reviewed\"\n</code></pre> <p>In this example with explicit triggers: - When triggered by a <code>commit</code> event: both actions execute - When triggered by a <code>label_added</code> event: both actions execute (explicit triggers take precedence)</p>"},{"location":"execution-model/#scenario-no-explicit-triggers","title":"Scenario: No Explicit Triggers","text":"<pre><code>automations:\nsmart_review:\nif:\n- {{ files | length &gt; 5 }}\nrun:\n- action: describe-changes@v1   # Only executes on code-related events\n- action: add-reviewers@v1      # Executes on all default triggers\nargs:\nreviewers: [\"expert1\", \"expert2\"]\n</code></pre> <p>With implicit triggers (no explicit triggers configured), <code>describe-changes</code> will only execute when the automation is triggered by code changes, while <code>add-reviewers</code> follows the current default behavior.</p>"},{"location":"execution-model/#examples_1","title":"Examples","text":""},{"location":"execution-model/#enable-ai-actions-on-draft-prs","title":"Enable AI Actions on Draft PRs","text":"<p>By default, AI actions like <code>code-review</code> don't run on draft PRs. To enable it, use explicit triggers with <code>pr_created</code> and <code>commit</code>:</p> <pre><code>automations:\nai_review_on_drafts:\non:\n- pr_created\n- commit\nif:\n- true\nrun:\n- action: code-review@v1\n</code></pre> <p>This allows developers to get AI feedback during the coding process before marking the PR as ready for review.</p>"},{"location":"execution-model/#dependabot-and-renovate","title":"Dependabot and Renovate","text":"<p>For example, you can have your normal automations that help developers with their PRs and a separate automation that automates Dependabot or Renovate version bumps. Both automations serve distinctly different purposes: the first helps your developers streamline their PRs, while the other reduces developers' toil by auto-approving version bumps. You will not want to unnecessarily trigger gitStream for Dependabot or Renovate, so you can configure the triggers to exclude these bot users.</p> <p>In your default automation file, you should exclude bot users like Dependabot or Renovate:</p> gitstream.cm<pre><code>manifest:\nversion: 1.0\n# Disable triggering when the PR is created by bots\n# Note: Only using triggers.exclude means implicit triggers remain active\n# (automations will still trigger on commits, PR creation, etc.)\ntriggers:\nexclude:\nuser:\n- dependabot[bot]\n- renovate[bot] - r/(bot|dependabot|renovate)/\n# The default automations for developers below\nautomations:\nestimated_time_to_review:\nif:\n- true\nrun:\n- action: add-label@v1\nargs:\nlabel: \"{{ calc.etr }} min review\"\n...\n</code></pre> <p>And the other automations file is set to automate Dependabot PRs:</p> dependabot.cm<pre><code>manifest:\nversion: 1.0\n# Note: triggers.include still allows implicit triggers  \n# However, the automations below use 'on' which switches to explicit mode\ntriggers:\ninclude:\nuser:\n- dependabot[bot]\n- renovate[bot]\nautomations:\nbump_minor:\non:\n- pr_created\n- commit\nif:\n- {{ bump == 'minor' }}\n- {{ branch.name | includes(term=\"dependabot\") }}\n- {{ branch.author | includes(term=\"dependabot\") }}\nrun:\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nDependabot `minor` version bumps are approved automatically.\nbump_patch:\non:\n- pr_created\n- commit\nif:\n- {{ bump == 'patch' }}\n- {{ branch.name | includes(term=\"dependabot\") }}\n- {{ branch.author | includes(term=\"dependabot\") }}\nrun:\n- action: approve@v1\n- action: merge@v1\n- action: add-comment@v1\nargs:\ncomment: |\nDependabot `patch` version bumps are approved and merged automatically.\nbump: {{ pr.description | checkDependabot | checkSemver }}\n</code></pre>"},{"location":"execution-model/#assign-code-expert","title":"Assign code expert","text":"<p>Assign code expert reviewer when the PR is created and after each commit. Ignore branches with the string \"hotfix\" in them.</p> <pre><code>triggers:\non:\n- pr_created\n- commit\nexclude:\nbranch:\n- hotfix\nautomations:\nassign_code_experts:\nif:\n- true\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: {{ repo | codeExperts(gt=10) }}\n</code></pre>"},{"location":"execution-model/#explain-code-experts","title":"Explain code experts","text":"<p>Explain code experts only if the label \u201csuggest-reviewer\u201d exists. The automation will be triggered after each commit and after each label addition. If the label \u201csuggest-reviewer\u201d exists, it will trigger the <code>explain-code-experts</code> automation.</p> <pre><code>triggers:\non:\n- commit\nautomations:\nexplain_code_experts:\non:\n- label_added\nif:\n- {{ pr.labels | match(term='suggest-reviewer') | some }}\nrun:\n- action: explain-code-experts@v1\nargs:\ngt: 10\n</code></pre>"},{"location":"execution-model/#user-filtering-examples","title":"User Filtering Examples","text":"<p>Exclude specific bot users from triggering automations while allowing all other users:</p> exclude-bots.cm<pre><code>manifest:\nversion: 1.0\n# Exclude bot users from triggering automations\ntriggers:\nexclude:\nuser:\n- sonar\n- dependabot[bot]\n- renovate[bot]\n- r/(bot|scanner)/\nautomations:\nreview_requirements:\nif:\n- true\nrun:\n- action: set-required-approvals@v1\nargs:\napprovals: 2\n</code></pre> <p>Include only specific team members for sensitive automations:</p> team-only.cm<pre><code>manifest:\nversion: 1.0\n# Only allow specific team members to trigger these automations\ntriggers:\ninclude:\nuser:\n- john-doe\n- jane-smith\n- r/team-lead-.*/\nautomations:\nsecurity_review:\nif:\n- {{ files | match(regex=r/\\.(env|key|pem)$/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: security-review-required\n</code></pre>"},{"location":"execution-model/#branch-regex-pattern","title":"Branch regex pattern","text":"<p>Trigger only specific automations branch pattern A, and trigger other automation for all other branches except those that fit the pattern REGEX_PATTERN.</p> <p><pre><code># Automation in this file will trigger only for branch pattern REGEX_PATTERN\ntriggers:\ninclude:\nbranch:\n- r/REGEX_PATTERN/\n</code></pre> <pre><code># Automations in this file will trigger for all branches except pattern REGEX_PATTERN\ntriggers:\nexclude:\nbranch:\n- r/REGEX_PATTERN/\n</code></pre></p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#what-permissions-are-needed","title":"What permissions are needed?","text":"<p>In your repo permissions, make sure GitHub actions are permitted:</p> <p>Go to Repo's settings &gt; Actions &gt; General &gt; Actions permissions</p> <p>Choose which repositories are permitted to use GitHub Actions.</p> <p>[x] Allow all actions and reusable workflows</p>"},{"location":"faq/#does-gitstream-services-have-access-to-my-code","title":"Does gitStream services have access to my code?","text":"<p>Like any other CI/CD automation, the source code is being scanned in the repo and is not shared with any external services. Only metadata related to and affecting the workflow is shared to allow rule-based automation on the repo.</p>"},{"location":"faq/#why-does-gitstream-require-permission-to-write-code","title":"Why does gitStream require permission to write code?","text":"<p>To support automations that either Approve or Merge PRs, the git providers require code write scope.</p>"},{"location":"faq/#what-repos-are-supported","title":"What repos are supported?","text":"<p>gitStream supports repositories in GitHub, GitLab, and Bitbucket. Note that the <code>add-label</code> action is not supported in Bitbucket as it does not have a native labeling feature.</p>"},{"location":"faq/#are-there-limits-on-gitstream-automations-for-free-accounts","title":"Are there limits on gitStream automations for free accounts?","text":"<p>Yes. Free accounts have a monthly limit on the number of pull requests that can trigger automations. It is limited to 250 pull requests each month per Git owner or organization.</p> <ul> <li>When the organization reaches 90% of the limit, a warning will appear in PR comments.</li> <li>Once the limit is exceeded, new PRs will not trigger automations and will be marked as \"Skipped.\"</li> <li>The limit resets at the start of each month.</li> </ul> <p>To remove automation limits, Contact LinearB and upgrade to a paid plan. \ud83d\udd17 Learn more: Automation Limits</p>"},{"location":"faq/#can-i-use-gitstream-with-merge-queues","title":"Can I use gitStream with Merge Queues?","text":"<p>Yes. When a merge queue is used, and gitStream is set as a required check, gitStream automation will be invoked with the merge event. The automation will set gitStream to a <code>Completed</code> status and <code>Skipped</code> conclusion to allow the PR merge. </p>"},{"location":"faq/#is-there-cm-syntax-highlighting","title":"Is there .cm syntax highlighting?","text":"<p>The <code>.cm</code> file uses YAML with JINJA2. For your favorite editor to automatically choose the right syntax, you can use modelines.</p> <p>Add the following line to the top of the <code>.cm</code> file (the default has it already):</p> <pre><code># -*- mode: yaml -*-\n</code></pre> <p>Get a plug-in that enables modelines. Popular ones are:</p> <ul> <li>VS Code: Modelines</li> <li>Sublime Text: CM syntax for ST4 or Emacs-like Sublime Modeline</li> <li>Vim Modeline magic</li> </ul>"},{"location":"faq/#i-have-an-issue-i-cant-seem-to-solve-what-should-i-do","title":"I have an issue I can't seem to solve. What should I do?","text":"<p>If you encounter an issue, please visit our Troubleshooting page for guidance and solutions to common problems. </p> <p>If your issue persists and you cannot find a resolution, contact our support team directly by emailing support@linearb.io. We're here to help!</p>"},{"location":"filter-function-plugins/","title":"Filter Function Plugin Library","text":"<p>JavaScript plugins that enable custom filter functions for gitStream. To learn how to use these examples, read our guide on how to use gitStream plugins.</p> <p></p>"},{"location":"filter-function-plugins/#askai","title":"askAI","text":"<p>The AskAI plugin allows gitStream workflows to interact with external AI services, enabling advanced automation capabilities such as code analysis, test case generation, and PR summarization. This plugin requires a valid API token for the AI service, which must be securely provided as an environment variable.</p> <p>Security note</p> <p>The <code>AskAI</code> plugin integrates with an external AI model and requires your API token for authorization. Ensure you provide a valid token through the <code>env.OPEN_AI_TOKEN</code> parameter or similar configuration. This may also incur API costs.</p> <p>When using the <code>AskAI</code> plugin, the provided context and prompt will be shared with the configured AI service. Ensure that no sensitive or proprietary information is included unless your organization's policies permit it. </p> <p></p> <p>Returns: <code>Object</code> -  Returns the AI-generated response based on the provided context and prompt. License: MIT</p> Param Type Description context <code>Object</code> The context that needs to be sent to the AI model for analysis. role <code>string</code> Free text. If not empty, Defines the role or persona for the AI to adopt while generating the response. prompt <code>string</code> The specific request or question you want the AI to respond to, after the context has been provided. token <code>Object</code> The token to the AI model <p>Example</p> <pre><code>{{ source | askAI(\"QA tester\", \"Based on the given context, search for new functions without tests and suggest the tests to add.\u00a0If all functions are covered completely, return 'no tests to suggest.'\", env.OPEN_AI_TOKEN) }}\n</code></pre> Plugin Code: askAI <p><pre><code>/**\n * @module askAI\n * @description A gitStream plugin to interact with AI models. Currently works with `ChatGPR-4o-mini`.\n * @param {Object} context - The context that will be attached to the prompt .\n * @param {string} role - Role instructions for the conversation.\n * @param {string} prompt - The prompt string.\n * @param {Object} token - The token to the AI model.\n * @returns {Object} Returns the response from the AI model.\n * @example {{ branch | generateDescription(pr, repo, source) }}\n * @license MIT\n * */\nconst MAX_TOKENS = 4096;\nconst OPEN_AI_ENDPOINT = 'https://api.openai.com/v1/chat/completions';\nconst LOCK_FILES = [\n'package-lock.json',\n'yarn.lock',\n'npm-shrinkwrap.json',\n'Pipfile.lock',\n'poetry.lock',\n'conda-lock.yml',\n'Gemfile.lock',\n'composer.lock',\n'packages.lock.json',\n'project.assets.json',\n'pom.xml',\n'Cargo.lock',\n'mix.lock',\n'pubspec.lock',\n'go.sum',\n'stack.yaml.lock',\n'vcpkg.json',\n'conan.lock',\n'ivy.xml',\n'project.clj',\n'Podfile.lock',\n'Cartfile.resolved',\n'flake.lock',\n'pnpm-lock.yaml',\n'uv.lock'\n];\nconst EXCLUDE_EXPRESSIONS_LIST = [\n'.*\\\\.(ini|csv|xls|xlsx|xlr|doc|docx|txt|pps|ppt|pptx|dot|dotx|log|tar|rtf|dat|ipynb|po|profile|object|obj|dxf|twb|bcsymbolmap|tfstate|pdf|rbi|pem|crt|svg|png|jpeg|jpg|ttf)$',\n'.*(package-lock|packages\\\\.lock|package)\\\\.json$',\n'.*(yarn|gemfile|podfile|cargo|composer|pipfile|gopkg)\\\\.lock$',\n'.*gradle\\\\.lockfile$',\n'.*lock\\\\.sbt$',\n'.*dist/.*\\\\.js',\n'.*public/assets/.*\\\\.js',\n'.*ci\\\\.yml$'\n];\nconst IGNORE_FILES_REGEX_LIST = [\n...LOCK_FILES.map(f =&gt; f.replace('.', '\\\\.')),\n...EXCLUDE_EXPRESSIONS_LIST\n];\nconst EXCLUDE_PATTERN = new RegExp(IGNORE_FILES_REGEX_LIST.join('|'));\n/**\n * @description Check if a file should be excluded from the context like \"package-lock.json\"\n * @param {*} fileObject\n * @returns returns true if the file should be excluded\n */\nconst shouldExcludeFile = fileObject =&gt; {\nconst shouldExludeByName = EXCLUDE_PATTERN.test(fileObject.original_file);\nconst shouldExludeBySize = (fileObject.diff?.split(' ').length ?? 0) &gt; 1000;\nreturn shouldExludeByName || shouldExludeBySize;\n};\n/**\n * @description Check if a file should be included in the context\n * @param {*} fileObject\n * @returns returns true if the file should be included\n */\nconst shouldIncludeFile = fileObject =&gt; {\nreturn !shouldExcludeFile(fileObject);\n};\nconst buildContextForGPT = context =&gt; {\nif (Array.isArray(context)) {\nreturn context.filter(element =&gt;\ntypeof element !== 'object' ? true : context.filter(shouldIncludeFile)\n);\n}\nif (context?.diff?.files) {\nconst files = context.diff.files.filter(shouldIncludeFile);\nreturn files;\n}\nreturn context;\n};\nconst askAI = async (context, role, prompt, token, callback) =&gt; {\nconst formattedContext = buildContextForGPT(context);\nif (!formattedContext?.length) {\nconst message = `There are no context files to analyze.\\nAll ${context?.diff?.files?.length} files were excluded by pattern or size.`;\nconsole.log(message);\nreturn callback(null, message);\n}\nconst response = await fetch(OPEN_AI_ENDPOINT, {\nmethod: 'POST',\nheaders: {\n'Content-Type': 'application/json',\nAuthorization: `Bearer ${token}`\n},\nbody: JSON.stringify({\nmodel: 'gpt-4o-2024-08-06',\nmessages: [\n{\nrole: 'system',\ncontent: `You are a ${role}. Answer only to the request, without any introductory or conclusion text.`\n},\n{\nrole: 'user',\ncontent: JSON.stringify(formattedContext)\n},\n{ role: 'user', content: prompt }\n],\nmax_tokens: MAX_TOKENS\n})\n});\nconst data = await response.json();\nif (data?.error?.message) {\nconsole.error(data.error.message);\nreturn callback(null, data.error.message);\n}\nconst suggestion =\ndata.choices?.[0]?.message?.content ??\n'context was too big for api, try with smaller context object';\nreturn callback(null, suggestion);\n};\nmodule.exports = {\nasync: true,\nfilter: askAI\n};\n</code></pre> </p> gitStream CM Example: askAI <p><pre><code>triggers:\nexclude:\nbranch:\n- r/dependabot/\nautomations:\ngenerate_pr_desc_on_new_pr:\non:\n- pr_created\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\n{{ source | askAI(\"Experienced developer\", \"Summarize in simple terms the changes in this PR using bullet points.\", env.OPEN_AI_TOKEN) }}\ngenerate_pr_desc_on_ask_ai_label:\non:\n- label_added\nif:\n- {{ pr.labels | match(term=\"/ask-ai qa\") | some }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\n{{ source | askAI(\"qa tester\", \"Based on the given context, search for new functions without tests and suggest the tests to add.\u00a0If all functions are covered completely, return 'no tests to suggest.'\", env.OPEN_AI_TOKEN) }}\n</code></pre> </p> <p>Download Source Code</p> <p></p>"},{"location":"filter-function-plugins/#checklist","title":"checklist","text":"<p>Automatically check PRs against a checklist of conditions. This is useful if you want to ensure that PRs meet certain criteria before they can be merged.</p> <p>Returns: <code>string</code> - Returns a formatted GitHub comment with a checklist of conditions that the PR meets. License: MIT  </p> Param Type Description Input <code>string</code> A blank string (no input variable is required) branch <code>object</code> The branch context variable. files <code>object</code> The files context variable. pr <code>object</code> The pr context variable. repo <code>object</code> The repo context variable. env <code>object</code> The env context variable. source <code>object</code> The source context variable. <p>Example <pre><code>- action: add-comment@v1\nargs:\ncomment: {{ \"\" | checklist(branch, files, pr, repo, env, source) }}\n</code></pre></p> <p>With this plugin, you can easily customize the checklist using the object in the JavaScript code. To add a new check to the list, just add a new object with a descriptive <code>title</code> for your own benefit, a <code>label</code> that'll get posted in the comment, and the <code>condition</code> that, if true, would cause the entry in the checklist to be checked off.</p> Plugin Code: checklist <p><pre><code>/**\n * @module checklist\n * @description Automatically check PRs against a checklist of conditions.\n * This is useful if you want to ensure that PRs meet certain criteria before they can be merged. \n * @param {string} Input - A blank string (no input variable is required)\n * @param {object} branch - The branch context variable.\n * @param {object} files - The files context variable.\n * @param {object} pr - The pr context variable.\n * @param {object} repo - The repo context variable.\n * @param {object} env - The env context variable.\n * @param {object} source - The source context variable.\n * @returns {string} Returns a formatted GitHub comment with a checklist of conditions that the PR meets.\n * @example       \n * - action: add-comment@v1\n        args:\n            comment: {{ \"\" | checklist(branch, files, pr, repo, env, source) }}\n * @license MIT\n**/\nconst checklistFilter = async (empty, branch, files, pr, repo, env, source, callback) =&gt; { // made sync temporarily\nconst checks = [\n{\ntitle: \"low-risk\",\nlabel: \"The PR is a low-risk change\",\n// our sample definition of a low-risk change is a docs-only PR from designated docs writers\ncondition: files.every(file =&gt; /docs\\//.test(file)) &amp;&amp; pr.author_teams.includes(\"tech-writers\")\n},\n{\ntitle: \"has-jira\",\nlabel: \"The PR has a Jira reference in the title\",\ncondition: /\\b[A-Za-z]+-\\d+\\b/.test(pr.title)\n},\n{\ntitle: \"updates-tests\",\nlabel: \"The PR includes updates to tests\",\ncondition: files.some(file =&gt; /[^a-zA-Z0-9](spec|test|tests)[^a-zA-Z0-9]/.test(file))\n},\n{\ntitle: \"includes-docs\",\nlabel: \"The PR includes changes to the documentation\",\ncondition: files.some(file =&gt; /docs\\//.test(file))\n},\n{\ntitle: \"first-time\",\nlabel: \"The PR author is a first-time contributor\",\ncondition: repo.author_age &lt; 1 &amp;&amp; repo.age &gt; 0 // if the PR author made their first contirbution on the current day\n},\n{\ntitle: \"requires-opsec\",\nlabel: \"The PR doesn't expose any secrets\",\ncondition: source.diff.files\n.map(file =&gt; file.new_content)\n.every(file_content =&gt; [\n\"MY_SECRET_ENVIRONMENT_VARIABLE\"\n].every(env_var =&gt; !file_content.includes(env_var)) // nothing added to any file during this comment contains any of the secret environment variables in this array\n)\n}\n];\nconst comment = await Promise.resolve(checks\n.map(check =&gt; `- [${check.condition ? \"x\" : \" \"}] ${check.label}`)\n.join(\"\\n\"));\nreturn callback(\nnull, JSON.stringify(comment)\n);\n};\nmodule.exports = {\nasync: true,\nfilter: checklistFilter\n}\n</code></pre> </p> gitStream CM Example: checklist <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nchecklist: if:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: {{ \"\" | checklist(branch, files, pr, repo, env, source) }}\n</code></pre> </p> <p>Download Source Code</p> <p></p>"},{"location":"filter-function-plugins/#comparemultisemver","title":"compareMultiSemver","text":"<p>Processes a list of pairs of semantic version numbers and determines the most significant change among them.</p> <p>Returns: <code>string</code> - It returns a string of either: 'major' if any pair has a major version increment. 'minor' if no pair has a major version increment but has a minor version increment. 'patch' if no pair has major or minor version increments but has a patch version increment. 'downgrade' if no pairs have a higher version. 'equal' if all pairs are equal. 'error' if the comparison is abnormal or cannot be determined.</p> <p>License: MIT</p> Param Type Default Description listOfPairs <code>Array.&lt;Array&gt;</code> An array of version pairs, where each pair is an array of two semantic version strings. <p>Example <pre><code>{{ [[\"1.2.3\", \"0.2.1\"], [\"1.3.1\", \"1.2.3\"]] | compareMultiSemver  == \"major\" }}\n</code></pre></p> Plugin Code: compareMultiSemver <p><pre><code>/**\n * @module compareMultiSemver\n * @description Processes a list of pairs of semantic version numbers and determines the most significant change among them.\n * Each pair consists of two versions to be compared.\n * @param {string[][]} listOfPairs - An array of version pairs, where each pair is an array of two semantic version strings.\n * @returns {string} It returns a string of either:\n * 'major' if any pair has a major version increment.\n * 'minor' if no pair has a major version increment but has a minor version increment.\n * 'patch' if no pair has major or minor version increments but has a patch version increment.\n * 'downgrade' if no pairs have a higher version.\n * 'equal' if all pairs are equal.\n * 'error' if the comparison is abnormal or cannot be determined.\n * @example {{ [[\"1.2.3\", \"1.2.1\"], [\"1.3.1\", \"1.2.3\"]] | compareMultiSemver  == \"minor\" }}\n * @license MIT\n */\nconst compareSemver = require('../compareSemver/index.js');\nmodule.exports = (listOfPairs) =&gt; {\nconst priority = {\n'major': 3,\n'minor': 2,\n'patch': 1,\n'downgrade': 0,\n'equal': -1,\n'error': -2\n};\nlet mostSignificantChange = 'equal';\nlistOfPairs.forEach(pair =&gt; {\nconst result = compareSemver(pair);\nif (priority[result] &gt; priority[mostSignificantChange]) {\nmostSignificantChange = result;\n}\n});\nreturn mostSignificantChange;\n}\nconst compareMultiSemver = require('./index.js');\nconsole.assert(compareMultiSemver([[\"1.2.3\", \"1.2.1\"], [\"1.3.1\", \"1.2.3\"]]) === 'minor', `compareSemver([[\"1.2.3\", \"1.2.1\"], [\"1.3.1\", \"1.2.3\"]]) == 'minor'`);\nconsole.assert(compareMultiSemver([[\"1.2.3\", \"0.2.1\"], [\"1.3.1\", \"1.2.3\"]]) === 'major', `compareMultiSemver([[\"1.2.3\", \"0.2.1\"], [\"1.3.1\", \"1.2.3\"]]) === 'major'`);\nconsole.assert(compareMultiSemver([[\"2.2.3\", \"0.2.1\"], [\"1.3.1\", \"1.2.3\"]]) === 'major', `compareMultiSemver([[\"2.2.3\", \"0.2.1\"], [\"1.3.1\", \"1.2.3\"]]) === 'major'`);\nconsole.assert(compareMultiSemver([[\"1.2.3\", \"1.2.1\"], [\"1.2.4\", \"1.2.3\"]]) === 'patch', `compareMultiSemver([[\"1.2.3\", \"1.2.1\"], [\"1.2.4\", \"1.2.3\"]]) === 'patch'`);\n</code></pre> </p> gitStream CM Example: compareMultiSemver <p><pre><code>manifest:\nversion: 1.0\nautomations:\nbump_minor:\nif:\n- {{ bump == 'minor' }}\nrun:\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nbot `minor` version bumps are approved automatically.\nbump_patch:\nif:\n- {{ bump == 'patch' }}\nrun:\n- action: approve@v1\n- action: merge@v1\n- action: add-comment@v1\nargs:\ncomment: |\nbot `patch` version bumps are approved and merged automatically.\nbump: {{ [[\"1.2.3\", \"1.2.1\"], [\"1.3.1\", \"1.2.3\"]] | compareMultiSemver }}\n</code></pre> </p> <p>Download Source Code</p>"},{"location":"filter-function-plugins/#comparesemver","title":"compareSemver","text":"<p>compareSemver \u2192 checkSemver</p> <p>This plugin is now supported by a native filter function <code>checkSemver</code>. The native implementation provides better performance and doesn't require plugin installation.</p>"},{"location":"filter-function-plugins/#extractdependabotversionbump","title":"extractDependabotVersionBump","text":"<p>extractDependabotVersionBump \u2192 checkDependabot</p> <p>This plugin is now supported by a native filter function <code>checkDependabot</code>. The native implementation provides better performance and doesn't require plugin installation.</p> <p></p>"},{"location":"filter-function-plugins/#extractrenovateversionbump","title":"extractRenovateVersionBump","text":"<p>Extract version bump information from Renovate PRs description</p> <p>Returns: <code>Array.&lt;string&gt;</code> - V1 (to) and V2 (from) License: MIT</p> Param Type Description description <code>string</code> the PR description <p>Example <pre><code>{{ pr.description | extractRenovateVersionBump | compareMultiSemver }}\n</code></pre></p> Plugin Code: extractRenovateVersionBump <p><pre><code>/**\n * @module extractRenovateVersionBump\n * @description Extract version bump information from Renovate PRs description\n * @param {string} description - the PR description\n * @returns {string[]} V1 (to) and V2 (from)\n * @example {{ pr.description | extractRenovateVersionBump | compareMultiSemver }}\n * @license MIT\n**/\nmodule.exports = (desc) =&gt; {\nconst results = [];\nif (desc &amp;&amp; desc !== '\"\"' &amp;&amp; desc !== \"''\") {\nconst regex =\n/\\[[\\\\]*`([\\d\\.]+[A-Za-z\u03b1\u00df]*)[\\\\]*` -&gt; [\\\\]*`([\\d\\.]+[A-Za-z\u03b1\u00df]*)[\\\\]*`\\]/g;\nlet matches = null;\ndo {\nmatches = regex.exec(desc);\nif (matches?.length === 3) {\nlet [_, from, to] = matches;\n// remove trailing dot on to\nif (to.at(-1) === \".\") {\nto = to.slice(0, -1);\n}\nresults.push([to, from]);\n}\n} while (matches !== null);\n}\nreturn results;\n}\n</code></pre> </p> gitStream CM Example: extractRenovateVersionBump <p><pre><code>manifest:\nversion: 1.0\nautomations:\nbump_minor:\nif:\n- {{ bump == 'minor' }}\n- {{ branch.name | includes(term=\"renovate\") }}\n- {{ branch.author | includes(term=\"renovate\") }}\nrun:\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nRenovate `minor` version bumps are approved automatically.\nbump_patch:\nif:\n- {{ bump == 'patch' }}\n- {{ branch.name | includes(term=\"renovate\") }}\n- {{ branch.author | includes(term=\"renovate\") }}\nrun:\n- action: approve@v1\n- action: merge@v1\n- action: add-comment@v1\nargs:\ncomment: |\nRenovate `patch` version bumps are approved and merged automatically.\nbump: {{ pr.description | extractRenovateVersionBump | compareMultiSemver }}\n</code></pre> </p> <p>Download Source Code</p> <p></p>"},{"location":"filter-function-plugins/#extractsnykversionbump","title":"extractSnykVersionBump","text":"<p>Extract version bump information from Snyk PRs description</p> <p>Returns: <code>Array.&lt;string&gt;</code> - V1 (to) and V2 (from) License: MIT</p> Param Type Description description <code>string</code> the PR description <p>Example <pre><code>{{ pr.description | extractSnykVersionBump | checkSemver }}\n</code></pre></p> Plugin Code: extractSnykVersionBump <p><pre><code>/**\n * @module extractSnykVersionBump\n * @description Extract version bump information from Snyk PRs description\n * @param {string} description - the PR description\n * @returns {string[]} V1 (to) and V2 (from)\n * @example {{ pr.description | extractSnykVersionBump | checkSemver }}\n * @license MIT\n**/\nmodule.exports = (desc) =&gt; {\nif (desc &amp;&amp; desc !== '\"\"' &amp;&amp; desc !== \"''\" ) {\nconst matches = /Upgrade.*from ([\\d\\.]+[A-Za-z\u03b1\u00df]*) to ([\\d\\.]+[A-Za-z\u03b1\u00df]*)/.exec(desc);\nif (matches &amp;&amp; matches.length == 3) {\nvar [_, from, to] = matches;\n// remove trailing dot on to\nif (to[to.length - 1] === \".\") {\nto = to.slice(0, -1);\n}\nreturn [to, from];\n}\n}\nreturn null;\n}\n</code></pre> </p> gitStream CM Example: extractSnykVersionBump <p><pre><code>manifest:\nversion: 1.0\nautomations:\nbump_minor:\nif:\n- {{ bump == 'minor' }}\n- {{ branch.name | includes(term=\"snyk-update\"\") }}\n      - {{ branch.author | includes(term=\"snyk-update\"\") }}\nrun:\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nSnyk `minor` version bumps are approved automatically.\nbump_patch:\nif:\n- {{ bump == 'patch' }}\n- {{ branch.name | includes(term=\"snyk-update\"\") }}\n      - {{ branch.author | includes(term=\"snyk-update\"\") }}\nrun:\n- action: approve@v1\n- action: merge@v1\n- action: add-comment@v1\nargs:\ncomment: |\nSnyk `patch` version bumps are approved and merged automatically.\nbump: {{ pr.description | extractSnykVersionBump | checkSemver }}\n</code></pre> </p> <p>Download Source Code</p> <p></p>"},{"location":"filter-function-plugins/#extractorcafindings","title":"extractOrcaFindings","text":"<p>Extract security issues information from Orca PR reviews</p> <p>Returns: <code>Object</code> - Findings Findings.infrastructure_as_code: { count: null, priority: '' }, Findings.vulnerabilities: { count: null, priority: '' }, Findings.secrets: { count: null, priority: '' }, License: MIT  </p> Param Type Description PR <code>Object</code> the gitStream's PR context variable <p>Example <pre><code>{{ pr | extractOrcaFindings }}\n</code></pre></p> <p>Usage example, that adds lables based on Orca Secuirty findings.</p> Plugin Code: extractOrcaFindings <p><pre><code>/**\n * @module extractOrcaFindings\n * @description Extract security issues information from Orca PR reviews\n * @param {Object} pr - the gitStream's PR context variable\n * @returns {Object} Findings\n * Findings.infrastructure_as_code: { count: null, priority: '' },\n * Findings.vulnerabilities: { count: null, priority: '' },\n * Findings.secrets: { count: null, priority: '' },\n * @example {{ pr | extractOrcaFindings }}\n * @license MIT\n**/\nfunction getOrcaPropertyRating(lines, lineIdentifierRegex, findingsCellIndex) {\nconst matches = lines.filter(x =&gt; x.match(lineIdentifierRegex));\nconst [firstMatch] = matches;\nconst cells = firstMatch.split('|');\nconst [_, high, medium, low, info] = /\"High\"&gt; ([\\d]+).*\"Medium\"&gt; ([\\d]+).*\"Low\"&gt; ([\\d]+).*\"Info\"&gt; ([\\d]+)/\n.exec(cells[findingsCellIndex])\n.map(x =&gt; parseInt(x));\nreturn {high, medium, low, info};\n}\nmodule.exports = (pr) =&gt; {\nlet orcaObject = {\ninfrastructure_as_code: { count: null, priority: '' },\nvulnerabilities: { count: null, priority: '' },\nsecrets: { count: null, priority: '' },\n};\n// Orca comments are added as PR review\nconst orcaComment = pr.reviews.filter(x =&gt; x.commenter.includes('orca-security'));\nif (orcaComment.length) {\nconst orcaCommentArray = orcaComment[orcaComment.length - 1].content.split('\\n');\nvar priority = getOrcaPropertyRating(orcaCommentArray, /Infrastructure as Code/, 3);\norcaObject.infrastructure_as_code = {\ncount: priority.high + priority.medium + priority.low + priority.info,\npriority,\n};\nvar priority = getOrcaPropertyRating(orcaCommentArray, /Vulnerabilities/, 3);\norcaObject.vulnerabilities = {\ncount: priority.high + priority.medium + priority.low + priority.info,\npriority,\n};\nvar priority = getOrcaPropertyRating(orcaCommentArray, /Secrets/, 3);\norcaObject.secrets = {\ncount: priority.high + priority.medium + priority.low + priority.info,\npriority,\n};\n}\nreturn JSON.stringify(orcaObject);\n}\n</code></pre> </p> gitStream CM Example: extractOrcaFindings <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in reports %}\nlabel_orca_{{ item.name }}:\nif:\n- {{ item.count &gt; 0 }}\nrun:\n- action: add-label@v1\nargs:\nlabel: 'orca:{{ item.name }}'\n{% endfor %}\norca: {{ pr | extractOrcaFindings }}\nreports:\n- name: introduced-cves\ncount: {{ orca.vulnerabilities.count }}\n- name: iac-misconfigurations\ncount: {{ orca.infrastructure_as_code.count }}\n- name: exposed-secrets count: {{ orca.secrets.count }}\ncolors:\nred: 'b60205'\n</code></pre> </p> <p>Download Source Code</p> <p></p>"},{"location":"filter-function-plugins/#generatedescription","title":"generateDescription","text":"<p>A gitStream plugin to auto-generate pull request descriptions based on commit messages and other criteria.</p> <p></p> <p>Returns: <code>Object</code> - Returns the generated PR description. License: MIT</p> Param Type Description branch <code>Object</code> The current branch object. pr <code>Object</code> The pull request object. repo <code>Object</code> The repository object. source <code>Object</code> The source object containing diff information. callback <code>function</code> The callback function. <p>Example <pre><code>{{ branch | generateDescription(pr, repo, source) }}\n</code></pre></p> Plugin Code: generateDescription <p><pre><code>/**\n * @module generateDescription\n * @description A gitStream plugin to auto-generate pull request descriptions based on commit messages and other criteria.\n * @param {Object} branch - The current branch object.\n * @param {Object} pr - The pull request object.\n * @param {Object} repo - The repository object.\n * @param {Object} source - The source object containing diff information.\n * @param {function} callback - The callback function.\n * @returns {Object} Returns the generated PR description.\n * @example {{ branch | generateDescription(pr, repo, source) }}\n * @license MIT\n**/\n// Parse commit messages\nfunction parseCommitMessages(messages) {\nconst commitTypes = {\nfeat: [],\nfix: [],\nchore: [],\ndocs: [],\nstyle: [],\nrefactor: [],\nperf: [],\ntest: [],\nbuild: [],\nci: [],\nother: [],\n};\nmessages\n.filter((message) =&gt; !message.includes(\"Merge branch\"))\n.forEach((message) =&gt; {\nconst match = message.match(\n/^(feat|fix|chore|docs|style|refactor|perf|test|build|ci):/,\n);\nif (match) {\ncommitTypes[match[1]].push(message.replace(`${match[1]}:`, \"\").trim());\n} else {\ncommitTypes.other.push(message);\n}\n});\nreturn commitTypes;\n}\n// Format commit section\nfunction formatCommitSection(type, commits) {\nreturn commits.length\n? `&gt; - **${type}:**\\n${commits.map((msg) =&gt; `&gt;     - ${msg}`).join(\"\\n\")}\\n`\n: \"\";\n}\nfunction containsNewTests(files) {\nconst testPattern = /(test_|spec_|__tests__|_test|_tests|\\.test|\\.spec)/i;\nconst testDirectoryPattern = /[\\\\/]?(tests|test|__tests__)[\\\\/]/i;\nconst testKeywords = /describe\\(|it\\(|test\\(|expect\\(/i; // Common test keywords for JavaScript\nfor (const file of files) {\nconst { new_file, diff, new_content } = file;\n// Check if the filename indicates it's a test file\nif (testPattern.test(new_file) || testDirectoryPattern.test(new_file)) {\nreturn true;\n}\n// Check if the diff or new content contains test-related code\nif (testKeywords.test(diff) || testKeywords.test(new_content)) {\nreturn true;\n}\n}\nreturn false;\n}\nfunction extractUserAdditions(description) {\nconst match = description.match(\n/&lt;!--- user additions start ---&gt;([\\s\\S]*?)&lt;!--- user additions end ---&gt;/,\n);\nreturn match ? match[1].trim() : description.trim();\n}\n// Generate PR description\nasync function generateDescription(branch, pr, repo, source, callback) {\nif (process.env[__filename]) {\nreturn callback(null, process.env[__filename]);\n}\nconst commitTypes = parseCommitMessages(branch.commits.messages);\nconst addTests = containsNewTests(source.diff.files) ? \"X\" : \" \";\nconst codeApproved = pr.approvals &gt; 0 ? \"X\" : \" \";\nconst changes = Object.entries(commitTypes)\n.map(([type, commits]) =&gt; formatCommitSection(type, commits))\n.join(\"\");\nconst changesWithoutLastBr = changes.slice(0, -1);\nconst userAdditions = extractUserAdditions(pr.description);\nconst result = `\n&lt;!--- user additions start ---&gt;\n${userAdditions}\n&lt;!--- user additions end ---&gt;\n**PR description below is managed by gitStream**\n&lt;!--- Auto-generated by gitStream---&gt;\n&gt; #### Commits Summary\n&gt; This pull request includes the following changes:\n${changesWithoutLastBr}\n&gt; #### Checklist\n&gt; - [${addTests}] Add tests\n&gt; - [${codeApproved}] Code Reviewed and approved\n&lt;!--- Auto-generated by gitStream end ---&gt;\n`;\nprocess.env[__filename] = result.split(\"\\n\").join(\"\\n            \");\nreturn callback(null, process.env[__filename]);\n}\nmodule.exports = { filter: generateDescription, async: true };\n</code></pre> </p> gitStream CM Example: generateDescription <p><pre><code>triggers:\nexclude:\nbranch:\n- r/dependabot/\nautomations:\ngenerate_pr_desc:\nif:\n- true\nrun:\n- action: update-description@v1\nargs:\ndescription: |\n{{ branch | generateDescription(pr, repo, source) }}\n</code></pre> </p> <p>Download Source Code</p> <p></p>"},{"location":"filter-function-plugins/#getcodeowners","title":"getCodeowners","text":"<p>Resolves the PR's code owners based on the repository's CODEOWNERS file</p> <p>Returns: <code>Array.&lt;string&gt;</code> - user names License: MIT  </p> Param Type Description files <code>Array.&lt;string&gt;</code> the gitStream's files context variable pr <code>Object</code> the gitStream's pr context variable token <code>string</code> access token with repo:read scope, used to read the CODEOWNERS file <p>Example <pre><code>{{ files | getCodeowners(pr, env.CODEOWNERS_TOKEN) }}\n</code></pre></p> <p>When used, create a secret TOKEN, and add it to the workflow file, in GitHub:</p> <pre><code>jobs:\n  gitStream:\n    ...\n    env:\n      CODEOWNERS: ${{ secrets.GITSTREAM_CODEOWNERS }}\n    steps:\n      - name: Evaluate Rules\n        uses: linear-b/gitstream-github-action@v2\n</code></pre> Plugin Code: getCodeowners <p><pre><code>/**\n * @module getCodeowners\n * @description Resolves the PR's code owners based on the repository's CODEOWNERS file\n * @param {string[]} files - the gitStream's files context variable\n * @param {Object} pr - the gitStream's pr context variable\n * @param {string} token - access token with repo:read scope, used to read the CODEOWNERS file\n * @returns {string[]} user names\n * @example {{ files | getCodeowners(pr, env.CODEOWNERS_TOKEN) }}\n * @license MIT\n**/\nconst { Octokit } = require(\"@octokit/rest\");\nconst ignore = require('./ignore/index.js');\nasync function loadCodeownersFile(owner, repo, auth) {\nconst octokit = new Octokit({\nrequest: { fetch },\nauth,\n});\nconst res = await octokit.repos.getContent({\nowner,\nrepo,\npath: 'CODEOWNERS'\n});\nreturn Buffer.from(res.data.content, 'base64').toString()\n}\nfunction codeownersMapping(data) {\nreturn data\n.toString()\n.split('\\n')\n.filter(x =&gt; x &amp;&amp; !x.startsWith('#'))\n.map(x =&gt; x.split(\"#\")[0])\n.map(x =&gt; {\nconst line = x.trim();\nconst [path, ...owners] = line.split(/\\s+/);\nreturn {path, owners};\n});\n}\nfunction resolveCodeowner(mapping, file) {\nconst match = mapping\n.slice()\n.reverse()\n.find(x =&gt;\nignore()\n.add(x.path)\n.ignores(file)\n);\nif (!match) return false;\nreturn match.owners;\n}\nmodule.exports = {\nasync: true,\nfilter: async (files, pr, token, callback) =&gt; {\nconst fileData = await loadCodeownersFile(pr.author, pr.repo, token);\nconst mapping = codeownersMapping(fileData);\nconst resolved = files\n.map(f =&gt; resolveCodeowner(mapping, f))\n.flat()\n.filter(i =&gt; typeof i === 'string')\n.map(u =&gt; u.replace(/^@/, \"\"));\nconst unique = [...new Set(resolved)];\nreturn callback(null, unique); },\n}\n</code></pre> </p> gitStream CM Example: getCodeowners <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nsenior_review:\nif:\n- true\nrun:\n- action: explain-code-experts@v1\nargs:\ngt: 10\n- action: add-reviewers@v1\nargs:\nreviewers: {{ experts | intersection(list=owners) }}\nexperts: {{ repo | codeExperts(gt=10) }}\nowners: {{ files | getCodeowners(pr, env.CODEOWNERS) }}\n</code></pre> </p> <p>Download Source Code</p> <p></p>"},{"location":"filter-function-plugins/#hasjiraissue","title":"hasJiraIssue","text":"<p>Check to see if the input string matches a specified field for one or more Jira issues.</p> <p>Returns: <code>boolean</code> - Returns true if the input string matches a Jira task title. License: MIT  </p> Param Type Description input <code>string</code> The string to search for a Jira task title. password <code>string</code> Your Jira API token key <code>string</code> The Jira key to search for matches against the input string. jiraSpaceName <code>string</code> The name of the Jira space to search for tasks. email <code>string</code> The email address associated with the Jira API token. <p>Example <pre><code>{{ \"https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\" | hasJiraIssue(password, key, jiraSpaceName, email) }}\n</code></pre></p> <p>Prerequisite Configuration</p> <p>You will need to complete the following steps to use this plugin:</p> <ol> <li>Create an API token for your Jira account.</li> <li>Make the token available to gitStream via an environment variable.</li> </ol> Plugin Code: hasJiraIssue <p><pre><code>/**\n * @module hasJiraIssue\n * @description Check to see if the input string matches a specified field for one or more Jira issues.\n * @param {string} input - The string to search for a Jira task title.\n * @param {string} password - Your Jira API token\n * @param {string} key - The Jira key to search for matches against the input string.\n * @param {string} jiraSpaceName - The name of the Jira space to search for tasks.\n * @param {string} email - The email address associated with the Jira API token.\n * @returns {boolean} Returns true if the input string matches a Jira task title. \n * @example {{ \"https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\" | hasJiraIssue(password, key, jiraSpaceName, email) }}\n * @license MIT\n */\nmodule.exports = {\nasync: true,\nfilter: async (inputString, password, key, jiraSpaceName, email, callback) =&gt; {\nconst jql = `\"${key}\" = \"${inputString}\"`;\nconst resp = await fetch(`https://${jiraSpaceName}.atlassian.net/rest/api/2/search`, {\nmethod: 'POST',\nheaders: {\n'Content-Type': 'application/json',\n'Authorization': 'Basic ' + btoa(`${email}:${password}`)\n},\nbody: JSON.stringify({\n'jql': jql,\n'maxResults': 1,\n\"fieldsByKeys\": true,\n'fields': [ 'assignee' ]\n})\n});\nconst results = await resp.json();\nreturn callback(null,  !!results.issues?.length);\n}\n}\n</code></pre> </p> gitStream CM Example: hasJiraIssue <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\n###### ** Configure This Section ** ######\n# Configure this for your Jira instance and the email associated with your API key.\n# You can safely use these values because only your API key is sensitive. \njiraSpaceName: \"my-company\" # e.g. my-company.atlassian.net\nemail: \"my.email@example.com\"\n# If you're concerned about exposing this information,\n# we recommend using environment variables for your production environment.\n# -----------\n# Pass the API token associated with the email above to gitStream via an environment variable.\njiraAuth: {{ env.JIRA_API_TOKEN }}\n# Learn more about env: https://docs.gitstream.cm/context-variables/#env\n# -----------\n# Change this to the Jira field you want to match the input string against.\njiraField: \"myField\"\n# If you want to search a custom field, you should provide the ID like so:\n# jiraField: \"cf[XXXXX]\"\n# Replace XXXXX with the ID of the custom field you want to search.\n# More information:\n# Using JQL to search the Jira API: https://support.atlassian.com/jira-service-management-cloud/docs/jql-fields/\n# How to find the ID of a custom field: https://confluence.atlassian.com/jirakb/how-to-find-any-custom-field-s-ids-744522503.html\n# -----------\nprUrl: \"https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"\nhas_jira_issue: {{ prUrl  | hasJiraIssue(jiraAuth, jiraField, jiraSpaceName, email) }}\nautomations:\nhas_jira_issue: if:\n- {{ not has_jira_issue }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: \"This PR is missing a related issue in Jira. Please create a Jira task.\"\n</code></pre> </p> <p>Download Source Code</p> <p></p>"},{"location":"filter-function-plugins/#isflaggeduser","title":"isFlaggedUser","text":"<p>Returns true if the username that is passed to this function is specified in a predefined list of users.  This is useful if you want gitStream automations to run only for specified users.</p> <p>Returns: <code>boolean</code> - Returns true if the user is specified in the flaggedUsers list, otherwise false. License: MIT  </p> Param Type Description Input <code>string</code> The GitHub username to check. <p>Example <pre><code>{{ pr.author | isFlaggedUser }}\n</code></pre></p> Plugin Code: isFlaggedUser <p><pre><code>// Add users who you want to add to the flag list.\nconst flaggedUsers = [\"user1\", \"user2\"];\n/**\n * @module isFlaggedUser\n * @description Returns true if the username that is passed to this function is specified in a predefined list of users. \n * This is useful if you want gitStream automations to run only for specified users.\n * @param {string} Input - The GitHub username to check.\n * @returns {boolean} Returns true if the user is specified in the flaggedUsers list, otherwise false.\n * @example {{ pr.author | isFlaggedUser }}\n * @license MIT\n */\nfunction isFlaggedUser(username) {\nif (flaggedUsers.includes(username)) {\nreturn true;\n} else {\nreturn false;\n}\n};\nfunction containsString(arr, str) {\nreturn arr.includes(str);\n};\nmodule.exports = isFlaggedUser;\n</code></pre> </p> gitStream CM Example: isFlaggedUser <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\ndetect_flagged_user:\nif:\n- {{ pr.author | isFlaggedUser }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: {{ pr.author }} is a gitStream user.\n</code></pre> </p> <p>Download Source Code</p> <p></p>"},{"location":"filter-function-plugins/#readmarkdownwithlinks","title":"readMarkdownWithLinks","text":"<p>Reads a markdown file and follows internal links to create a comprehensive document view. Prevents circular references and supports configurable depth limits.</p> <p>Returns: <code>string</code> - Combined content of the file and all linked files with headers, or structured object if structured option is true License: MIT  </p> Param Type Default Description filePath <code>string</code> Path to the markdown file to read [options] <code>Object</code> <code>{}</code> Configuration options for link following [options.followLinks] <code>boolean</code> <code>true</code> Whether to follow internal markdown links [options.maxDepth] <code>number</code> <code>3</code> Maximum depth to follow links to prevent excessive recursion [options.structured] <code>boolean</code> <code>false</code> Return structured data instead of combined text <p>Example <pre><code>{{ \"docs/README.md\" | readMarkdownWithLinks }}\n</code></pre> Example <pre><code>{{ \"docs/README.md\" | readMarkdownWithLinks(maxDepth=2) }}\n</code></pre></p> Plugin Code: readMarkdownWithLinks <p><pre><code>const fs = require('fs');\nconst path = require('path');\n/**\n * Safely read file with path traversal protection\n * @param {string} filePath - Path to file to read\n * @returns {string|null} File content or null if error/invalid path\n */\nfunction readFile(filePath) {\n// Whitelist: only allow relative paths within current directory\nconst normalizedPath = path.normalize(filePath);\nif (path.isAbsolute(normalizedPath) || normalizedPath.includes('..')) {\nconsole.log(`Invalid path: ${filePath}`);\nreturn null;\n}\ntry {\nreturn fs.readFileSync(normalizedPath, 'utf8');\n} catch (error) {\nconsole.log(`Error reading file ${filePath}: ${error.message}`);\nreturn null;\n}\n}\n/**\n * Extract internal markdown links from content\n * Matches patterns like [text](./file.md) or [text](../file.md) or [text](file.md)\n * @param {string} content - The markdown content to scan for links\n * @param {string} basePath - Base directory path for resolving relative links\n * @returns {Array} Array of link objects with text, path, and resolvedPath\n */\nfunction extractInternalLinks(content, basePath) {\nconst linkRegex = /\\[([^\\]]+)\\]\\(([^)]+)\\)/g;\nconst internalLinks = [];\nlet match;\nwhile ((match = linkRegex.exec(content)) !== null) {\nconst linkText = match[1];\nconst linkPath = match[2];\n// Check if it's an internal link (not http/https and ends with .md)\nif (!linkPath.startsWith('http') &amp;&amp; linkPath.endsWith('.md')) {\nconst resolvedPath = path.join(basePath, linkPath);\ninternalLinks.push({\ntext: linkText,\npath: linkPath,\nresolvedPath: resolvedPath\n});\n}\n}\nreturn internalLinks;\n}\n/**\n * Read markdown file and follow internal links\n * @param {string} filePath - Path to the markdown file\n * @param {Object} options - Configuration options\n * @param {boolean} options.followLinks - Whether to follow internal links (default: true)\n * @param {number} options.maxDepth - Maximum depth to follow links (default: 3)\n * @param {Set} options.visited - Internal set to track visited files (prevent cycles)\n * @param {number} options.currentDepth - Current depth (internal)\n * @returns {Object} Object containing content and linked files\n */\nfunction readMarkdown(filePath, options = {}) {\nconst {\nfollowLinks = true,\nmaxDepth = 3,\nvisited = new Set(),\ncurrentDepth = 0\n} = options;\nconst normalizedPath = path.normalize(filePath);\n// Check if we've already visited this file (prevent cycles)\nif (visited.has(normalizedPath)) {\nreturn {\npath: normalizedPath,\ncontent: null,\nerror: 'Circular reference detected',\nlinkedFiles: []\n};\n}\n// Check depth limit\nif (currentDepth &gt;= maxDepth) {\nreturn {\npath: normalizedPath,\ncontent: readFile(normalizedPath),\nerror: null,\nlinkedFiles: [],\ndepthLimitReached: true\n};\n}\n// Mark this file as visited\nvisited.add(normalizedPath);\n// Read the main file content\nconst content = readFile(normalizedPath);\nif (content === null) {\nreturn {\npath: normalizedPath,\ncontent: null,\nerror: 'File not found or could not be read',\nlinkedFiles: []\n};\n}\nconst result = {\npath: normalizedPath,\ncontent: content,\nerror: null,\nlinkedFiles: []\n};\n// If we should follow links, extract and process them\nif (followLinks) {\nconst basePath = path.dirname(normalizedPath);\nconst internalLinks = extractInternalLinks(content, basePath);\nfor (const link of internalLinks) {\nconst linkedFileResult = readMarkdown(link.resolvedPath, {\nfollowLinks,\nmaxDepth,\nvisited: new Set(visited), // Create a new set for each branch\ncurrentDepth: currentDepth + 1\n});\nresult.linkedFiles.push({\nlinkText: link.text,\noriginalPath: link.path,\n...linkedFileResult\n});\n}\n}\nreturn result;\n}\n/**\n * @module readMarkdownWithLinks\n * @description Reads a markdown file and follows internal links to create a comprehensive document view. \n * Prevents circular references and supports configurable depth limits.\n * @param {string} filePath - Path to the markdown file to read\n * @param {Object} [options={}] - Configuration options for link following\n * @param {boolean} [options.followLinks=true] - Whether to follow internal links\n * @param {number} [options.maxDepth=3] - Maximum depth to follow links  \n * @param {boolean} [options.structured=false] - Return structured data instead of combined text\n * @returns {string} Combined content of the file and all linked files with headers\n * @example {{ \"docs/README.md\" | readMarkdownWithLinks }}\n * @example {{ \"docs/README.md\" | readMarkdownWithLinks(maxDepth=2) }}\n * @license MIT\n */\nfunction readMarkdownWithLinks(filePath, options = {}) {\nconst {\nfollowLinks = true,\nmaxDepth = 3,\nstructured = false\n} = options;\nconst result = readMarkdown(filePath, {\nfollowLinks,\nmaxDepth,\nvisited: new Set(),\ncurrentDepth: 0\n});\n// Return structured data if requested\nif (structured) {\nreturn result;\n}\n// Otherwise return combined content\nfunction combineContent(fileResult, depth = 0) {\nconst indent = '  '.repeat(depth);\nlet combined = '';\nif (fileResult.content) {\ncombined += `${indent}=== ${path.basename(fileResult.path)} ===\\n`;\ncombined += fileResult.content + '\\n\\n';\n}\nif (fileResult.linkedFiles) {\nfor (const linkedFile of fileResult.linkedFiles) {\ncombined += combineContent(linkedFile, depth + 1);\n}\n}\nreturn combined;\n}\nreturn combineContent(result);\n}\nmodule.exports = readMarkdownWithLinks;\n// ============================================================================\n// TESTS (for local development only)\n// ============================================================================\nif (require.main === module) {\nconst fs = require('fs');\nfunction assert(condition, message) {\nif (!condition) { console.error(`\u274c ${message}`); process.exit(1); }\nconsole.log(`\u2705 ${message}`);\n}\n// Setup\nfs.mkdirSync('./test-files/sub', { recursive: true });\nfs.writeFileSync('./test-files/main.md', '# Main\\n[Related](./related.md)\\n[Another](./another.md)\\n[External](https://example.com)');\nfs.writeFileSync('./test-files/related.md', '# Related\\n[Sub](./sub/subdoc.md)');\nfs.writeFileSync('./test-files/another.md', '# Another');\nfs.writeFileSync('./test-files/sub/subdoc.md', '# Sub\\n[Main](../main.md)');\nconsole.log('\ud83e\uddea Running tests\\n');\n// Test 1: Basic reading\nlet r = readMarkdown('./test-files/main.md', { followLinks: false });\nassert(r.content?.includes('# Main'), 'Basic file reading');\n// Test 2: Link following\nr = readMarkdown('./test-files/main.md', { maxDepth: 2 });\nconsole.log(r.linkedFiles[0])\nassert(r.linkedFiles.length === 2, 'Follows 2 links');  assert(r.linkedFiles[0].linkedFiles.length === 1, 'Nested link following');\n// Test 3: Circular reference\nr = readMarkdown('./test-files/main.md', { maxDepth: 5 });\nconst circularRef = r.linkedFiles[0].linkedFiles[0].linkedFiles[0];\nassert(circularRef?.error === 'Circular reference detected', 'Circular reference detection');\n// Test 4: Depth limit\nr = readMarkdown('./test-files/main.md', { maxDepth: 1 });\nassert(r.linkedFiles[0].linkedFiles.length === 0, 'Depth limit respected');\n// Test 5: Non-existent file\nr = readMarkdown('./test-files/missing.md');\nassert(r.error === 'File not found or could not be read', 'Non-existent file handling');\n// Test 6: Combined output\nconst combined = readMarkdownWithLinks('./test-files/main.md', { maxDepth: 1 });\nassert(combined.includes('=== main.md ==='), 'Combined format includes headers');\nassert(combined.includes('  === related.md ==='), 'Nested files indented');\n// Test 7: Path traversal blocked\nr = readMarkdown('../../../etc/passwd');\nassert(r.content === null, 'Path traversal blocked');\nassert(r.error === 'File not found or could not be read', 'Path traversal returns error');\n// Test 8: Absolute path blocked\nconst content1 = readFile('/etc/passwd');\nassert(content1 === null, 'Absolute Unix path blocked');\nconst content2 = readFile('C:\\\\Windows\\\\System32\\\\config');\nassert(content2 === null, 'Absolute Windows path blocked');\n// Test 9: Empty file handling\nfs.writeFileSync('./test-files/empty.md', '');\nr = readMarkdown('./test-files/empty.md');\nassert(r.content === '', 'Empty file handled');\nassert(r.linkedFiles.length === 0, 'Empty file has no links');\nconsole.log('\\n\ud83c\udf89 All tests passed!');\nfs.rmSync('./test-files', { recursive: true });\n}\n</code></pre> </p> gitStream CM Example: readMarkdownWithLinks <p><pre><code># -*- mode: yaml -*-\n# Example gitStream configuration using readMarkdownWithLinks for LinearB AI code reviews\n# This shows how to enhance AI code reviews with comprehensive documentation context\nmanifest:\nversion: 1.0\nautomations:\n# Enhanced AI code review with comprehensive documentation context\nai_review_with_full_docs:\nif:\n- {{ not pr.draft }}\n- {{ pr.files | match(regex=r\".*\\.(js|ts|py|go|java|cpp|cs)\") | some }}\nrun:\n- action: code-review@v1\nargs:\nguidelines: |\nCode Review Guidelines:\n{{ \"REVIEW_RULES.md\" | readMarkdownWithLinks | dump }}\nProject Documentation Context:\n{{ \"README.md\" | readMarkdownWithLinks(maxDepth=2) | dump }}\nArchitecture and Design:\n{{ \"docs/ARCHITECTURE.md\" | readMarkdownWithLinks(maxDepth=1) | dump }}\n# Context-aware reviews based on changed file areas\ncontextual_ai_review:\nif:\n- {{ not pr.draft }}\nrun:\n- action: code-review@v1\nargs:\nguidelines: |\nBase Review Guidelines:\n{{ \"REVIEW_RULES.md\" | readMarkdownWithLinks | dump }}\n{% if pr.files | match(regex=r\"src/api/.*\") | some %}\nAPI-Specific Guidelines and Documentation:\n{{ \"docs/api/README.md\" | readMarkdownWithLinks | dump }}\n{% endif %}\n{% if pr.files | match(regex=r\".*test.*\") | some %}\nTesting Standards and Guidelines:\n{{ \"docs/testing/README.md\" | readMarkdownWithLinks | dump }}\n{% endif %}\n{% if pr.files | match(regex=r\".*security.*\") | some %}\nSecurity Guidelines:\n{{ \"docs/security/GUIDELINES.md\" | readMarkdownWithLinks | dump }}\n{% endif %}\n# Large PR reviews with extensive context\ncomprehensive_review_large_prs:\nif:\n- {{ not pr.draft }}\n- {{ pr.files | length &gt; 10 }}  # Large changes\nrun:\n- action: code-review@v1\nargs:\nguidelines: |\nComprehensive Review Guidelines for Large Changes:\n{{ \"REVIEW_RULES.md\" | readMarkdownWithLinks | dump }}\nFull Project Context:\n{{ \"README.md\" | readMarkdownWithLinks(maxDepth=1) | dump }}\nContributing Guidelines:\n{{ \"CONTRIBUTING.md\" | readMarkdownWithLinks | dump }}\nArchitecture Documentation:\n{{ \"docs/ARCHITECTURE.md\" | readMarkdownWithLinks(maxDepth=2) | dump }}\n</code></pre> </p> <p>Download Source Code</p>"},{"location":"filter-functions/","title":"Filter functions","text":"<p>Filters can change the look and format of the source data, or even generate new data derived from the input values. What's important is that the original data is replaced by the result of transformations, and that's what ends up in rendered templates.</p> <p>Note</p> <ul> <li>Items marked with  are under development and are not available yet.</li> <li>Items marked with  are available exclusively for paid accounts. To unlock this feature, contact our sales team.</li> </ul>"},{"location":"filter-functions/#overview","title":"Overview","text":"<p>The following functions are supported in addition to the built-in functions provided by Nunjucks.</p>"},{"location":"filter-functions/#low-level-functions","title":"Low level functions","text":"Function Input Args Output <code>capture</code>Find and return the first occurrence of a regex in the input string String <code>regex</code> String <code>difference</code>Given two lists, keep only items that are in the 1st list but not in the 2nd. [Objects] <code>list</code> [Objects] <code>every</code>Checks whether all elements in the list are <code>true</code> [Bool] - Bool <code>filter</code>Reduce list of items into a list of same items that match the specified term [String][Object] <code>regex</code>, <code>term</code>, <code>list</code>, <code>attr</code> [String][Object] <code>includes</code>Check if substring match String <code>regex</code>, <code>term</code>, <code>list</code> Bool <code>intersection</code>Given two lists, keep only items that are in both lists. [Objects] <code>list</code> [Objects] <code>map</code>Maps each object in a list into their specified attribute value [Object] <code>attr</code> [Object] <code>match</code>Maps list of items into a list of booleans that match the specified term [String][Object] <code>regex</code>, <code>term</code>, <code>list</code> <code>attr</code> [Bool] <code>nope</code>Checks whether all elements in the list are <code>false</code> [Bool] - Bool <code>reject</code>Inverse of <code>filter</code>, the result list contains non-matching items [String][Object] <code>regex</code>, <code>term</code>, <code>list</code>, <code>attr</code> [String][Object] <code>some</code>Checks whether at least one element in the list is <code>true</code> [Bool] - Bool"},{"location":"filter-functions/#high-level-functions","title":"High level functions","text":"Function Input Args Output <code>allDocs</code>Checks if the list includes only documents <code>files</code> - Bool <code>allImages</code>Checks the list includes only images <code>files</code> - Bool <code>allTests</code>Checks the list includes only tests <code>files</code> - Bool <code>checkDependabot</code>Extract version bump information from Dependabot PRs description String - PR description - [String] <code>checkSemver</code>Compare two software version numbers and determine the type of version change [String] - Array with [to, from] versions <code>lexicographical</code>, <code>zeroExtend</code> String <code>codeExperts</code>Get list of contributors based on expert reviewer model results <code>repo</code> <code>gt</code>, <code>lt</code> [String] <code>decode</code>Decode Base64 encoded string into an object String (Base64 encoded) - Object <code>encode</code>Encode data into Base64 encoded string Object - String (Base64 encoded) <code>estimatedReviewTime</code>Estimated review time in minutes <code>branch</code> - Integer <code>extensions</code>Lists all the unique file extensions [String] - [String] <code>extractJitFindings</code> Get an object with a summary of the findings found by the Jit scan <code>pr</code> - Object <code>extractSonarFindings</code> Get an object with a summary of the findings found by the SonarCloud scan <code>pr</code> - Object <code>explainRankByGitBlame</code>Short markdown text explaining rankByGitBlame results <code>repo</code> <code>gt</code>, <code>lt</code> [String] <code>isFirstCommit</code>Checks if it's the author's first commit in the repo <code>repo.contributors</code> String Bool <code>isFormattingChange</code>Checks that only formatting changed [<code>FileDiff</code> ] - Bool <code>mapToEnum</code>return the enum value that matches the input key String Enum object Object <code>matchDiffLines</code>Match every line in diff [<code>FileDiff</code> ] <code>regex</code>, <code>ignoreWhiteSpaces</code> [Bool] <code>rankByGitActivity</code>Get list of contributors based on <code>git-commit</code> activity <code>repo</code> <code>gt</code>, <code>lt</code> [String] <code>rankByGitBlame</code>Get list of contributors based on <code>git-blame</code> results <code>repo</code> <code>gt</code>, <code>lt</code> [String] <code>readFile</code>Reads the contents of a file from the current branch or \"cm\" folder String - The file path String (optional) - the file type. <code>txt</code> or <code>json</code> String"},{"location":"filter-functions/#named-arguments","title":"Named arguments","text":"<p>Some functions support named arguments, many of these repeat in different functions.</p> <p><code>term</code> - a single string, used as a substring to match with the matched item.</p> <p><code>list</code> - a list of strings, trying to match any of the listed substrings with the matched item.</p> <p><code>regex</code> - a single string, used as a regular expression with the matched item. A regular expression can be created just like JavaScript, but needs to be prefixed with r, for example, <code>r/^foo.*/g</code>, for more info see Nunjucks.</p> <p><code>attr</code> - a key in the element to use when doing the requested operation.</p> <p>For example, the following expressions provide an identical result:</p> <pre><code>- {{ 'something' | includes(regex=r/^some.*/) }}\n- {{ 'something' | includes(term='some') }}\n- {{ 'something' | includes(list=['some']) }}\n</code></pre>"},{"location":"filter-functions/#reference","title":"Reference","text":""},{"location":"filter-functions/#capture","title":"<code>capture</code>","text":"<p>Extract the first match of the regex in the input string. If no match is found, the function returns an empty string.</p> Argument Usage Type Description - Input String The string to find the match in <code>regex</code> Input String Search term to match with the input string - Output String The first substring that matches the provided regex <p>For example, the following line will extract the substring \"hello wo\" from the input</p> <pre><code>{{ \"hello world\" | capture(regex=r/he.+o/) }}\n</code></pre>"},{"location":"filter-functions/#difference","title":"<code>difference</code>","text":"<p>Given two lists, keep only items that are in the 1st list but not in the 2nd.</p> Argument Usage Type Description - Input [Objects] List of objects to inspect. list Input [Objects] List of objects to exclude. - Output [Objects] Returns a list of objects containing items that exist in one input, but not in the other."},{"location":"filter-functions/#every","title":"<code>every</code>","text":"<p>Checks whether all elements in the list are\u00a0<code>true</code>. In case the list of elements is empty, it will return <code>false</code>.</p> Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns <code>true</code> when all list items are <code>true</code> <p>For example, check that all changes are in either 'src' or 'dest' directories:</p> <pre><code>{{ files | match(list=['src', 'dest']) | every }}\n</code></pre>"},{"location":"filter-functions/#filter","title":"<code>filter</code>","text":"<p>Creates a shallow copy of a portion of a given list, filtered down to just the elements that match the given term. You can use either a single term, regex, or a list of terms to match with.</p> Argument Usage Type Description - Input [String][Object] The list of strings to match, or list of objects if <code>attr</code> is used <code>term</code><code>regex</code><code>list</code> Input (either) StringString[String] Search term to match with the input items <code>attr</code> Input  (optional) String match a named attribute in the input object - Output [String][Object] The list with only the matching items <p>Examples: Check if all changes to JavaScript files are in the tests directory:</p> <pre><code>{{ files | filter(regex=r/\\.js$/) | match(regex=r/tests\\//) | every }}\n</code></pre> <p>Check if all changes to JavaScript files are formatting:</p> <pre><code>{{ source.diff.files | filter(attr='new_file', regex=r/\\.js$/) | isFormattingChange }}\n</code></pre> <p>Check if the PR has new Python files: <pre><code>{{ branch.diff.files_metadata | filter(attr='original_file', regex=r/^$/) | filter(attr='new_file', regex=r/\\.py$/) | some }}\n</code></pre></p>"},{"location":"filter-functions/#includes","title":"<code>includes</code>","text":"<p>Determines whether a string includes a certain substring. You can use either a single term, regex, or a list of terms to match with.</p> Argument Usage Type Description - Input String The string you want to check for matching substrings <code>term</code><code>regex</code><code>list</code> Input (either) StringString[String] Substring term to match - Output Bool <code>true</code> if search terms matches <p>Check string matches either of the terms:</p> <pre><code>{{ 'something' | includes(list=['any', 'thing']) }}\n</code></pre>"},{"location":"filter-functions/#intersection","title":"<code>intersection</code>","text":"<p>Given two lists, keep only items that are in both lists.</p> Argument Usage Type Description - Input [Objects] List of objects to inspect. list Input [Objects] List of objects to check for intersection. - Output [Objects] Returns a list of objects containing items that intersect between the two lists."},{"location":"filter-functions/#map","title":"<code>map</code>","text":"<p>Creates a new list populated with the values of the selected attribute of every element in the input list.</p> Argument Usage Type Description - Input [Object] The list of objects to map, see context for valid inputs <code>attr</code> Input String Object attribute to select - Output [Object] List of the selected object attributes <p>For example, the <code>source.diff.files</code> context holds a list of <code>FileDiff</code> , each has <code>new_file</code> attribute. You can create a list of all the new file names by mapping to the <code>new_file</code> attribute and then check if there are changes to any <code>handler.js</code> file:</p> <pre><code>{{ source.diff.files | map(attr='new_file') | match(term='handler.js') | some }}\n</code></pre>"},{"location":"filter-functions/#match","title":"<code>match</code>","text":"<p>Return <code>true</code> for each element in the list that match the search term.</p> Argument Usage Type Description - Input [String][Object] The list of strings or if <code>attr</code> used the list of objects <code>term</code><code>regex</code><code>list</code> Input (either) StringString[String] Search term to match <code>attr</code> Input String match a named attribute in the input object - Output [Bool] <code>true</code> for every matching item <p>Examples:</p> <p>Check if all code changes are in the <code>tests</code> directory:</p> <pre><code>{{ files | match(regex=r/tests\\//) | every }}\n</code></pre> <p>Check if there are code changes with specific function call:</p> <pre><code>{{ source.diff.files | match(attr='diff', term='myFunction') | some }}\n</code></pre>"},{"location":"filter-functions/#nope","title":"<code>nope</code>","text":"<p>The inverse of <code>every</code>, checks whether all elements in the list are\u00a0<code>false</code>. In case the list of elements is empty, it will return <code>true</code>.</p> Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns <code>true</code> when all list items are <code>false</code> <p>For example, check that no changes in either 'src' or 'dest' directories:</p> <pre><code>{{ files | match(list=['src', 'dest']) | nope }}\n</code></pre>"},{"location":"filter-functions/#reject","title":"<code>reject</code>","text":"<p>Creates a shallow copy of a portion of a given list, filtered down to just the elements that do not match the given term. You can use either a single term, regex, or a list of terms to match with.</p> Argument Usage Type Description - Input [String][Object] The list of strings to match, or list of objects if <code>attr</code> is used <code>term</code><code>regex</code><code>list</code> Input (either) StringString[String] Search term to match with the input items <code>attr</code> Input  (optional) String match a named attribute in the input object - Output [String][Object] The list with only the non-matching items <p>Examples:</p> <p>Check if all changes, but JavaScript files are in tests directory:</p> <pre><code>{{ files | reject(regex=r/\\.js$/) | match(regex=r/tests\\//') | every }}\n</code></pre> <p>Check if all changes except for <code>config.json</code> files are formatting:</p> <pre><code>{{ source.diff.files | reject(attr='new_file', regex=r/config\\.json$/) | isFormattingChange }}\n</code></pre>"},{"location":"filter-functions/#some","title":"<code>some</code>","text":"<p>Checks whether any element in the list is\u00a0<code>true</code>. In case the list of elements is empty it will return <code>false</code>.</p> Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns <code>true</code> when any of the items is <code>true</code> <pre><code>{{ files | match(list=['src', 'dest']) | some }}\n</code></pre>"},{"location":"filter-functions/#alldocs","title":"<code>allDocs</code>","text":"<p>Return <code>true</code> if the input list includes only documents based on file extensions.</p> <p>Doc files extensions are: <code>md</code>, <code>mkdown</code>, <code>txt</code>, <code>rst</code>, <code>adoc</code>, except for <code>requirements.txt</code>.</p> Argument Usage Type Description - Input <code>files</code> The list of changed files with their path - Output Bool <code>true</code> if all file extensions are of docs <pre><code>{{ files | allDocs }}\n</code></pre> <p>In case you want to exclude more files, like all <code>txt</code> under the <code>requirements</code> directory, add another check:</p> <pre><code>{{ (files | allDocs) and (files | match(regex=r/requirements\\/.*\\.txt$/) | nope ) }}\n</code></pre>"},{"location":"filter-functions/#allimages","title":"<code>allImages</code>","text":"<p>Return <code>true</code> if the input list includes only images based on file extensions.</p> <p>Image file extensions are: <code>svg</code>, <code>png</code>, <code>gif</code>.</p> Argument Usage Type Description - Input <code>files</code> The list of changed files with their path - Output Bool <code>true</code> if all file extensions are of images <pre><code>{{ files | allImages }}\n</code></pre>"},{"location":"filter-functions/#alltests","title":"<code>allTests</code>","text":"<p>Return <code>true</code> if the input list includes only tests based on the file's path and name.</p> <p>To identify as test the file must include the word <code>test</code> or <code>spec</code> in its name or path, it is checked using this regex: <code>[^a-zA-Z0-9](spec|test|tests)[^a-zA-Z0-9]</code>.</p> Argument Usage Type Description - Input <code>files</code> The list of changed files with their path - Output Bool <code>true</code> if all file tests are based on name and path <pre><code>{{ files | allTests }}\n</code></pre>"},{"location":"filter-functions/#checkdependabot","title":"<code>checkDependabot</code>","text":"<p>Extract version bump information from Dependabot PRs description. This filter parses Dependabot PR descriptions to identify version changes and returns an array containing the \"to\" and \"from\" versions.</p> Argument Usage Type Description - Input String The PR description from a Dependabot pull request - Output [String] Array with [to, from] versions, or null if no version info found <p>Examples:</p> <p>Check if a Dependabot PR is a minor version bump and auto-approve:</p> <pre><code>automations:\nauto_approve_dependabot_minor:\nif:\n- {{ pr.description | checkDependabot | checkSemver == 'minor' }}\n- {{ branch.name | includes(term=\"dependabot\") }}\n- {{ branch.author | includes(term=\"dependabot\") }}\nrun:\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nDependabot minor version bump approved automatically.\n</code></pre> <p>Auto-merge patch updates:</p> <pre><code>automations:\nauto_merge_dependabot_patch:\nif:\n- {{ pr.description | checkDependabot | checkSemver == 'patch' }}\n- {{ branch.name | includes(term=\"dependabot\") }}\nrun:\n- action: approve@v1\n- action: merge@v1\n</code></pre>"},{"location":"filter-functions/#checksemver","title":"<code>checkSemver</code>","text":"<p>Compare two software version numbers and determine the type of version change. This filter takes an array of two version strings and returns the type of change between them.</p> Argument Usage Type Description - Input [String] Array with [to, from] versions in semver format <code>lexicographical</code> Input (optional) Boolean Compare lexicographically instead of naturally (default: false) <code>zeroExtend</code> Input (optional) Boolean Pad shorter version with zeros (default: true) - Output String Returns 'major', 'minor', 'patch', 'downgrade', 'equal', or 'error' <p>Examples:</p> <p>Compare version arrays directly:</p> <pre><code>{{ [\"1.2.3\", \"1.2.1\"] | checkSemver }}  # Returns \"patch\"\n</code></pre> <p>Use with Dependabot to classify version bumps:</p> <pre><code>bump_type: {{ pr.description | checkDependabot | checkSemver }}\nautomations:\nhandle_major_bump:\nif:\n- {{ bump_type == 'major' }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"major-version-bump\"\n- action: request-changes@v1\nargs:\ncomment: \"Major version bumps require manual review\"\n</code></pre>"},{"location":"filter-functions/#codeexperts","title":"<code>codeExperts</code>","text":"<p>When requesting a review for a pull request, it's important to select a reviewer who has a deep understanding of the relevant code area, the domain problem, and the framework being used. This ensures that the reviewer can provide specific and informed feedback, rather than general comments that may not take into account the context in which the issue was solved.</p> <p>The filter provides the list of most qualified contributors based on <code>git-blame</code> and <code>git-commit</code> results to determine who has been most active in the relevant code area, and then combines this information into a score between 0 and 100. The commit activity is scored higher for recent commits, which ensures that those who are actively contributing to the codebase are given higher priority as potential reviewers. The result will be limited to 2 users and shall not include the PR author.</p> <p>The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the <code>git-blame</code> output. When gitStream cannot map the Git user to a Git provider user it will be dropped from the output list, hence the list may contain less than 100% of the lines.</p> <p>Note</p> <p>The <code>codeExperts</code> filter function calls gitStream app API with the <code>repo</code> context to calculate the experts.</p> Argument Usage Type Description - Input <code>repo</code> The <code>repo</code> context variable <code>lt</code> Input Integer Filter the user list, keeping those below the specified threshold <code>gt</code> Input Integer Filter the user list, keeping those above the specified threshold - Output [String] Up to 2 users, sorted by best match first (it won't include the PR author) <p>For example:</p> <pre><code>automations:\ncode_experts:\nif:\n- true\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: {{ repo | codeExperts(gt=10) }}\n</code></pre> <p>Limit git history for code experts</p> <p>Use the <code>config.git_history_since</code> configuration to limit the git history analysis to commits after a specific date. This is useful for team transitions or when you want to focus on recent contributors only.</p>"},{"location":"filter-functions/#decode","title":"<code>decode</code>","text":"<p>Decode Base64 encoded string into an object. Encoded strings are formatted: <code>\"base64: &lt;encoded_string&gt;\"</code></p> Argument Usage Type Description - Input String Base64 encoded string prefixed <code>\"Base64: \"</code> - Output Object Decoded objet <pre><code>{{ \"base64: SGVsbG8gV29ybGQ=\" | decode }} # Output: \"Hello World\"\n</code></pre>"},{"location":"filter-functions/#encode","title":"<code>encode</code>","text":"<p>Encode data into Base64 encoded string. When an encoded string is passed as input for <code>add-comment</code>, the action automatically detects and decodes it.</p> Argument Usage Type Description - Input Object The input object to encode - Output String (Base64) Base64 encoding of the object <pre><code>{{ \"Hello World\" | encode }} # Output: \"base64: SGVsbG8gV29ybGQ=\"\n</code></pre>"},{"location":"filter-functions/#estimatedreviewtime","title":"<code>estimatedReviewTime</code>","text":"<p>Returns the estimated review time in minutes based on an ML model. The model estimation is computed based on the PR metadata data (e.g. branch name, commits) and mainly by the number of additions and deletions for each type of change (Code, Data, Configuration, etc..)</p> <p>Note</p> <p>The <code>estimatedReviewTime</code> filter function calls gitStream app API with the <code>branch</code> context to calculate the estimated review time value.</p> Argument Usage Type Description - Input <code>branch</code> Branch meta data - Output Integer the estimated time for review in minutes <pre><code>{{ branch | estimatedReviewTime }}\n</code></pre> <p>The following files are automatically excluded from the estimated review time calculation.</p> File type Filter type Values Data Extension <code>ini</code> <code>csv</code> <code>xls</code> <code>xlsx</code> <code>xlr</code> <code>doc</code> <code>docx</code> <code>txt</code> <code>pps</code> <code>ppt</code> <code>pptx</code> <code>dot</code> <code>dotx</code> <code>log</code> <code>tar</code> <code>rtf</code> <code>dat</code> <code>ipynb</code> <code>po</code> <code>profile</code> <code>object</code> <code>obj</code> <code>dxf</code> <code>twb</code> <code>bcsymbolmap</code> <code>tfstate</code> <code>pdf</code> <code>rbi</code> <code>pem</code> <code>crt</code> <code>svg</code> <code>png</code> <code>jpeg</code> <code>jpg</code> <code>ttf</code> Data Regex <code>.*dist/.*\\.js$</code> <code>.*public/assets/.*\\.js$</code> Pipeline Regex <code>.*ci\\.yml$</code> Lock File Name Programming Language Package Manager <code>package-lock.json</code> JavaScript npm <code>yarn.lock</code> JavaScript Yarn <code>npm-shrinkwrap.json</code> JavaScript npm <code>Pipfile.lock</code> Python pipenv <code>poetry.lock</code> Python Poetry <code>conda-lock.yml</code> Python conda <code>Gemfile.lock</code> Ruby Bundler <code>composer.lock</code> PHP Composer <code>packages.lock.json</code> .NET NuGet <code>project.assets.json</code> .NET .NET Core <code>pom.xml</code> Java Maven <code>Cargo.lock</code> Rust Cargo <code>mix.lock</code> Elixir Mix <code>pubspec.lock</code> Dart/Flutter pub <code>go.sum</code> Go Go modules <code>stack.yaml.lock</code> Haskell Stack <code>vcpkg.json</code> C++ vcpkg <code>conan.lock</code> C++ Conan <code>ivy.xml</code> Scala sbt/Ivy <code>project.clj</code> Clojure Leiningen <code>Podfile.lock</code> Swift/Objective-C CocoaPods <code>Cartfile.resolved</code> Swift/Objective-C Carthage <code>flake.lock</code> Nix Nix <p>Tip</p> <p>You can also filter more files, using <code>config.ignore_files</code>.</p>"},{"location":"filter-functions/#extensions","title":"<code>extensions</code>","text":"<p>Expects <code>files</code> and provide a list of all unique file extensions.</p> Argument Usage Type Description - Input <code>files</code> The list of changed files with their path - Output [String] List of all unique file extensions <p>For example, check that only one file type was changed:</p> <pre><code>{{ files | extensions | length == 1 }}\n</code></pre>"},{"location":"filter-functions/#extractjitfindings","title":"<code>extractJitFindings</code>","text":"<p> Available in GitHub only</p> <p>This filter is currently available only in GitHub</p> <p>Get an object with a summary of the findings found by Jit scan. This filter is relevant only for repos that use Jit to scan PRs</p> <p>The <code>pr</code> context includes all the reviews in the pull request, including the reviews written by the Jit bot, along with all the comments (conversations) to the review.</p> <p>This filter reads and parses the reviews with Jit's findings, making them available for use inside the <code>.cm</code> file automations.</p> <p>The output is an object of the following format: <pre><code>{\n\"vulnerabilities\": [{\n\"security_control\": 'string',\n\"type\": 'string',\n\"description\": 'string',\n\"severity\": 'string',\n\"summary\": 'string'\n}],\n\"metrics\": {\n\"HIGH\": number,\n\"MEDIUM\": number,\n\"LOW\": number,\n\"INFO\": number\n}\n}\n</code></pre></p> Argument Usage Type Description - Input <code>pr</code> The <code>pr</code> context variable - Output Object The object contains the summary of Jit's scan <p>Example of the filter output <pre><code>{\n\"vulnerabilities\": [\n{\n\"security_control\": \"Static Code Analysis Js\",\n\"type\": \"Codsec.Javascriptnosql-Injection.Nosql-Injection\",\n\"description\": \"Putting request data into a mongo query can leadto a NoSQL Injection. Be sure to properly sanitize thedata if you absolutely must pass request data into a query.\",\n\"severity\": \"HIGH\",\n\"summary\": \"Jit Bot commands and options (e.g., ignore issue)\"\n},\n{\n\"security_control\": \"Secret Detection\",\n\"type\": \"Private-Key\",\n\"description\": \"Private Key\",\n\"severity\": \"HIGH\",\n\"summary\": \"Jit Bot commands and options (e.g., ignore issue)\"\n}\n],\n\"metrics\": {\n\"HIGH\": 2,\n\"MEDIUM\": 0,\n\"LOW\": 0,\n\"INFO\": 0\n}\n}\n</code></pre></p> <p>Assign the output to a variable</p> <pre><code>jit: {{ pr | extractJitFindings }}\n</code></pre> <p>Add a label if Jit detected secrets in the PR</p> <pre><code>automations:\nadd_bugs_label:\nif:\n- {{ jit.metrics.HIGH &gt; 0 }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"Vulnerable code!\"\"\n</code></pre>"},{"location":"filter-functions/#extractsonarfindings","title":"<code>extractSonarFindings</code>","text":"<p> Available in GitHub only</p> <p>This filter is currently available only in GitHub</p> <p>Get an object with a summary of the findings found by the SonarCloud scan. This filter is relevant only for repos that use SonarCloud to scan PRs</p> <p>The <code>pr</code> context includes all the comments added to the pull request, including the comment written by the SonarCloud bot that holds a summary of its scan.</p> <p>This filter reads and parses the comment with SonarCloud's scan summary and makes them available to use inside the <code>.cm</code> file automations.</p> <p>The output is an object of the following format: <pre><code>{\n\"bugs\": {\n\"count\": number,\n\"rating\": 'string' //('A'-'E')\n},\n\"code_smells\": {\n\"count\": number,\n\"rating\": 'string' //('A'-'E')\n},\n\"vulnerabilities\": {\n\"count\": number,\n\"rating\": 'string' //('A'-'E')\n},\n\"security_hotspots\": {\n\"count\": number,\n\"rating\": 'string' //('A'-'E')\n},\n\"duplications\": number,\n\"coverage\": number\n}\n</code></pre></p> Argument Usage Type Description - Input <code>pr</code> The <code>pr</code> context variable - Output Object The object contains the summary of SonCloud's scan <p>Example of the filter output <pre><code>{\n\"bugs\": {\n\"count\": 1,\n\"rating\": 'B'\n},\n\"code_smells\": {\n\"count\": 2,\n\"rating\": 'B'\n},\n\"vulnerabilities\": {\n\"count\": 2,\n\"rating\": 'E'\n},\n\"security_hotspots\": {\n\"count\": 0,\n\"rating\": 'A'\n},\n\"duplications\": 3,\n\"coverage\": 70\n}\n</code></pre></p> <p>Assign the output to a variable</p> <pre><code>sonar: {{ pr | extractSonarFindings }}\n</code></pre> <p>Add a label with the number of bugs if the bugs rating is other than 'A', and use mapToEnum to set its color</p> <pre><code>automations:\n# Add Bugs label\nshow_bugs_count:\nif:\n- {{ sonar.bugs.count &gt; 0}}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83d\udc1e x {{ sonar.bugs.count }} Bugs'\ncolor: {{ sonar.bugs.rating | mapToEnum(enum = colors) }}\ncolors:\nA: '05AA02'\nB: 'B6D146'\nC: 'EABE05'\nD: 'DF8339'\nE: 'D4343F'\n</code></pre>"},{"location":"filter-functions/#explainrankbygitblame","title":"<code>explainRankByGitBlame</code>","text":"<p>This filter helps to explain the results of <code>rankByGitBlame</code>, the output is in Markdown format that can be used in a PR comment.</p> <p>The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the <code>git-blame</code> output. Git users that could not be automatically mapped are marked with <code>*</code>. To map these users, you can add <code>user_mapping</code> see instructions here.</p> Argument Usage Type Description - Input <code>repo</code> The <code>repo</code> context variable <code>lt</code> Input Integer Filter the user list, keeping those below the specified threshold <code>gt</code> Input Integer Filter the user list, keeping those above the specified threshold - Output String Explaining <code>rankByGitBlame</code> results in markdown format <p>Note</p> <p>Each contributor's result is rounded down to the nearest integer, so the total may add up to less than 100%.</p> <p>For example:</p> <pre><code>automations:\nthe_right_reviewer:\nif:\n- true\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: {{ repo | rankByGitBlame(gt=50) }}\n- action: add-comment@v1\nargs:\ncomment: |\n{{ repo | explainRankByGitBlame(gt=50) }}\n</code></pre> <p>Note the comment starts with <code>|</code> and a <code>new-line</code> as <code>explainRankByGitBlame</code> generates a multiline comment.</p>"},{"location":"filter-functions/#isfirstcommit","title":"<code>isFirstCommit</code>","text":"<p>Return <code>true</code> if it's the author's first commit in the repo.</p> Argument Usage Type Description - Input <code>repo.contributors</code> List of contributors in the repo - Input String The contributor name - Output Bool <code>true</code> if it's the author's first commit of the selected contributor <pre><code>if:\n- {{ repo.contributors | isFirstCommit(branch.author) }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: \"Welcome {{branch.author}}!\"\n</code></pre>"},{"location":"filter-functions/#isformattingchange","title":"<code>isFormattingChange</code>","text":"<p>Return <code>true</code> if all file diffs are validated as formatting changes. This filter function works for JavaScript, TypeScript, Python, JSON, YAML and HTML.</p> <p>gitStream determines formatting changes by minifying the source code for the incoming changes and the existing code and comparing them. If they are identical, this filter function returns <code>true</code>. If any unsupported languages are contained in the PR, gitStream will return <code>false</code>.</p> Argument Usage Type Description - Input <code>source.diff.files</code> List of file diffs - Output Bool <code>true</code> if the all code changes are non functional <pre><code>{{ source.diff.files | isFormattingChange }}\n</code></pre>"},{"location":"filter-functions/#maptoenum","title":"<code>mapToEnum</code>","text":"<p>Get the enum value matches to the input key</p> Argument Usage Type Description - Input String The key name <code>enum</code> Input Enum Object The enum object to which the input string should be matched - Output Object The value of the input key in the input enum object <p>For example, set a label color according to names in the enum:</p> <pre><code>automations:\nlabel_color:\nif:\n- true\nrun:\n- action: add-label@v1\nargs:\nlabel: 'Blue label'\ncolor: {{ \"blue\" | mapToEnum(enum = colors) }}\ncolors:\nred: 'FF0000'\ngreen: '00FF00'\nblue: '0000FF'\nyellow: 'FFFF00'\n</code></pre>"},{"location":"filter-functions/#matchdifflines","title":"<code>matchDiffLines</code>","text":"<p>Checks diff for matching lines.</p> Argument Usage Type Description - Input [Object] The list of objects <code>regex</code> Input String Regex term to match with the input items, use <code>\\\\</code> for <code>\\</code> <code>ignoreWhiteSpaces</code> Input Bool <code>false</code> by default, match a named attribute in the input object <code>caseSensitive</code> Input Bool <code>true</code> by default, ignore case when matching terms - Output [Bool] <code>true</code> for every matching object <p>For example, to check if all the changes are of adding prints and ignore white spaces:</p> <pre><code>{{ source.diff.files | matchDiffLines(regex=r/^\\+.*console\\.log/, ignoreWhiteSpaces=true) | every }}\n</code></pre>"},{"location":"filter-functions/#rankbygitactivity","title":"<code>rankByGitActivity</code>","text":"<p>Get list of contributors based on <code>git-commit</code> activity.</p> <p>The <code>repo</code> context includes all the changed files, for each file it includes each contributor number of lines changed every week over the last 52 weeks, based on <code>git-commit</code>.</p> <p>These functions compare each contributor changes per week and yield an average percentage of contribution for any given file. For example, in a certain week a file had 500 line changed, 200 by a first user, while 3 other users changed 100 lines each. So the score for the first user in that week will be 40 (200/500 in %). The function then average the score for each user for the selected time period.</p> <p>Then you can use the thresholds to get the right reviewer.</p> Argument Usage Type Description - Input <code>repo</code> The <code>repo</code> context variable <code>weeks</code> Input Integer The number of last weeks to include <code>lt</code> Input Integer Filter the user list, keeping those below the specified threshold <code>gt</code> Input Integer Filter the user list, keeping those above the specified threshold - Output [String] The list of users based on their code score comparison <p>Check if the branch author is a rookie</p> <pre><code>active_coders: {{ repo | rankByGitActivity(gt=50, weeks=12) }}\n</code></pre>"},{"location":"filter-functions/#rankbygitblame","title":"<code>rankByGitBlame</code>","text":"<p>Get list of contributors based on <code>git-blame</code> results</p> <p>The <code>repo</code> context includes all the changed files, for each file it includes the contributors' percentage of lines in the file, based on <code>git-blame</code>.</p> <p>This function sums all these percentages per user and yield an average percentage of contribution. Then you can use the thresholds to get the right reviewer.</p> <p>The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the <code>git-blame</code> output. When gitStream cannot map the Git user to a Git provider user it will be dropped from the output list, hence the list may contain less than 100% of the lines.</p> Argument Usage Type Description - Input <code>repo</code> The <code>repo</code> context variable <code>lt</code> Input Integer Filter the user list, keeping those below the specified threshold <code>gt</code> Input Integer Filter the user list, keeping those above the specified threshold - Output [String] The list of users based on their code score comparison, sorted by rank - first has highest score <p>Example of the filter output, note the output are GitHub users in the example: <pre><code>[\n\"PopeyeUser\",\n\"olive_user\",\n\"BRUTUS_USER\"\n]\n</code></pre></p> <p>Get the most significant contributors for the PR files:</p> <pre><code>contributors: {{ repo | rankByGitBlame(gt=30) }}\n</code></pre> <p>Check if the branch author is a rookie</p> <pre><code>is_rookie: {{ repo | rankByGitBlame(lt=15) | match(term=branch.author) | some }}\n</code></pre>"},{"location":"filter-functions/#readfile","title":"<code>readFile</code>","text":"<p>Reads the contents of a file from the current branch or the <code>cm</code> repo and returns it as a string.</p> Argument Usage Type Description - Input String The relative file path in the current repo. Prepend <code>../cm/</code> to get files from the <code>cm</code> repo <code>output</code> Input String The content type. Optional, <code>txt</code> by default. Allowed options are <code>txt</code> or <code>json</code>. When using <code>json</code>, the output will be returned as a stringified Object - Output String The contents of the file as a String. In case of <code>json</code> output, the result will be <code>JSON.stringified</code> <p>Examples:</p> <p>Add a comment with a file's content:</p> <pre><code>automations:\nadd_readme_comment:\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\n{{ README_CONTENT }}\nREADME_CONTENT: {{ \"./README.md\" | readFile() }}\n</code></pre> <p>Read JSON configuration file from the <code>cm</code> repo and use some of the properties in a comment: <pre><code>automations:\n  describe_teams:\n    if:\n      - {{ true }}\n    run:\n      - action: add-comment@v1\n        args:\n          comment: |\n              We have {{ TEAMS | length }} teams with {{ TEAMS.front.members | length + TEAMS.back.members | length }} members in total:\n              FrontEnd: include {{ TEAMS.front.members | length }} members\n              BackEnd: include {{ TEAMS.back.members | length }} members\n\nTEAMS: {{ \"../cm/TEAMS.json\" | readFile(output=\"json\") }}\n</code></pre></p> <p>Configuration file example: <pre><code>{\n\"front\": {\n\"name\": \"Frontend\",\n\"description\": \"Frontend team\",\n\"members\": [\n\"John\",\n\"Jane\"\n]\n},\n\"back\": {\n\"name\": \"Backend\",\n\"description\": \"Backend team\",\n\"members\": [\n\"Alice\",\n\"Bob\"\n]\n}\n}\n</code></pre></p>"},{"location":"gitStream-playground/","title":"Playground","text":"<p>Welcome to gitStream Playground! This platform allows you to thoroughly test gitStream automations before deploying them into the <code>.cm</code> rule file on any GitHub pull request of your choice. </p> <p>Playground </p>"},{"location":"gitStream-playground/#getting-started","title":"Getting Started","text":""},{"location":"gitStream-playground/#accessing-gitstream-playground","title":"Accessing gitStream Playground","text":"<p>To access gitStream Playground, visit https://app.gitstream.cm/playground.  To be able to test automations of private repository PRs, log in with your GitHub account credentials.</p>"},{"location":"gitStream-playground/#interface-overview","title":"Interface Overview","text":"<p>The gitStream Playground interface consists of the following sections: </p> <ol> <li> Login \\ User icon:  supports  the following actions<ul> <li>Login</li> <li>Logout</li> <li>View user</li> <li>Change organization</li> </ul> </li> <li>Pull Request Link: An input textbox for a link to the pull request</li> <li>cm editor:  Code input box where you can write automations to be executed by the playground.  <code>estimated_time_to_review</code> and <code>safe_changes</code> are provided by default.</li> <li>Output section, with the following tabs:<ul> <li><code>Output</code> - shows syntax errors when the <code>.cm</code> automation syntax is wrong. After running gitStream - it shows the expected result of the automation on the chosen Pull Request.</li> <li><code>Context Variables</code> - Shows the values of all Context variables of the chosen Pull Request.</li> </ul> </li> </ol>"},{"location":"gitStream-playground/#testing-automations","title":"Testing Automations","text":""},{"location":"gitStream-playground/#selecting-a-pull-request","title":"Selecting a Pull Request","text":"<p>On GitHub, navigate to any pull request, copy its link, and paste it onto the \"Pull request link\" box. If the PR is part of a private repo, you must also log in to the playground with a GitHub user accessible to this repository.</p>"},{"location":"gitStream-playground/#running-gitstream","title":"Running gitStream","text":"<ol> <li>Add the desired automations to the editor. Make sure there are no syntax errors</li> <li>Click \"Run gitStream.\"</li> <li>The rule engine loads the PR and runs the automations defined in the <code>.cm</code> editor.</li> </ol>"},{"location":"gitStream-playground/#viewing-results","title":"Viewing Results","text":"<p>The automation results will be shown in the \"Output\" tab at the bottom of the interface. Context Variables will be shown in the \"Context Variables\" tab.</p>"},{"location":"gitStream-playground/#feedback-and-support","title":"Feedback and Support","text":"<p>For additional assistance or to provide feedback, please open an issue on our GitHub issues page</p>"},{"location":"github-installation/","title":"How to Setup gitStream with GitHub","text":"<p>Prerequisites</p> <p>Allowed network connection between the runners and the following IPs:</p> <ul> <li>13.56.203.235</li> <li>54.151.81.98</li> </ul> Understanding IP Allowlisting for gitStream <p>When setting up IP allowlists in GitHub, you're specifying which source IP addresses are permitted to interact with your repositories and APIs. This affects both gitStream and your CI/CD runners.</p> <p>There are two primary cases where this matters for gitStream:</p> <ol> <li>Webhook Event Handling by gitStream    When GitHub triggers a webhook event (e.g., a pull request opened), gitStream may need to make follow-up API calls to GitHub. This can include fetching additional metadata, posting comments to the PR, or performing other actions. These calls are made from the LinearB/gitStream service, which uses a fixed set of IP addresses. These IPs must be added to your GitHub allowlist to ensure proper operation.</li> <li>Outbound Requests from Your CI Runner    When your pipeline runs gitStream (e.g., via a GitHub Action), that runner might also make outbound calls to GitHub\u2014for example, to clone a repository or retrieve commit history. These requests will originate from the runner's IP address.</li> </ol> <p>If you encounter errors due to blocked IPs during your CI runs, it's likely that the runner is using an IP that is not part of the configured allowlist. This is a common issue with GitHub-hosted runners, as their IPs can be dynamic and change frequently.</p> <p>Recommended Solution To ensure reliability:</p> <ul> <li>Add LinearB/gitStream service IPs to your GitHub allowlist (listed above).</li> <li>Use self-hosted runners or runners with static IPs so you can manage and allowlist their addresses explicitly.</li> </ul> <p>This combination ensures that both gitStream's internal operations and your CI runners' interactions with GitHub function without network restrictions.</p> <p>Install gitStream</p> <p>Before you can complete the gitStream setup process, you need to install the gitStream app to your GitHub organization.</p>"},{"location":"github-installation/#setup","title":"Setup","text":"<p>You can set up gitStream for a single repo or your entire GitHub organization. Select the tab below for the instructions you want.</p> Single RepoGitHub Organization <p>Single Repo Setup</p> <p>You must implement two main components for gitStream to function for a single GitHub repo. The first is a configuration file that defines the workflow automations to execute for the repo. The second is a GitHub actions configuration file that triggers gitStream when PRs are created or updated.</p> <p>Required Configurations</p> <p>gitStream</p> <p>Create a <code>.cm/gitstream.cm</code> rules file in your repository's default branch (usually <code>master</code> or <code>main</code>). This file will contain a YAML configuration that determines the workflows that run on the repo, and you can name it anything you want as long as it ends in <code>.cm</code></p> <p>Here is an example of a gitStream configuration file you can use to setup some basic workflow automations.</p> <pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlinearb_ai_codereview:\n# Ai Code Review - Triggers only when PR is ready for review, see docs https://docs.gitstream.cm/execution-model/#action-level-execution-control\non: [pr_created, pr_ready_for_review, merge]\nif:\n- {{ not is.bot }}\nrun:\n- action: code-review@v1\nargs:\nguidelines: |\n- Keep suggestions short and actionable.\npr_policy_low_noise:\non: [pr_created, commit]\nif:\n- {{ not pr.draft }}\n- {{ not is.bot }}\nrun:\n# AI description (updates PR body; not a comment)\n- action: describe-changes@v1\nargs:\nconcat_mode: append\n# Quiet labels\n- action: add-label@v1\nargs:\nlabel: \"{{ calc.etr }} min review\"\ncolor: {{ colors.red if (calc.etr &gt;= 20) else (colors.yellow if (calc.etr &gt;= 5) else colors.green) }}\n- action: add-label@v1\nwhen :  {{ pr.unresolved_threads }}\nargs:\nlabel: \"{{ pr.unresolved_threads | default(value=0) }} unresolved thread(s)\"\ncolor: {{ colors.yellow }}\n- action: add-label@v1\nwhen: {{ not (has.jira_ticket_in_title or has.jira_ticket_in_desc) }}\nargs:\nlabel: \"missing-jira\"\ncolor: {{ colors.red }}\n# further automations available with Jira webhook\n# Assign reviewers silently\n- action: add-reviewers@v1\nargs:\nreviewers: {{ who.experts }}\n# ONE consolidated, updatable comment\n- action: add-comment@v1\nargs:\ncomment: |\n## gitStream Summary \u2014 Low Noise (Staff Engineer focus)\n**AI PR Description:** Updated in the PR body above.\n**ETR:** {{ calc.etr }} min review\n**Unresolved threads:** {{ pr.unresolved_threads | default(value=0) }}\n### Suggested Reviewers (auto-assigned)\n{{ who.experts }}\n### Jira Reference\n{{ '\u2705 Found in title/description.' if (has.jira_ticket_in_title or has.jira_ticket_in_desc) else '\u26a0\ufe0f Missing Jira ticket. Please add one (e.g., `ABC-123` or an `atlassian.net/browse/...` link).' }}\n&gt; Labels/reviewers were applied quietly to keep this PR clean.\n# ----------------- config -----------------\ncalc:\netr: {{ branch | estimatedReviewTime }}\nhas:\njira_ticket_in_title: {{ pr.title       | includes(regex=r/\\b[A-Za-z][A-Za-z0-9_]+-\\d+\\b/) }}\njira_ticket_in_desc:  {{ pr.description | includes(regex=r/\\b[A-Za-z][A-Za-z0-9_]+-\\d+\\b/) }}\nwho:\nexperts: {{ repo | codeExperts(gt=10) }}\nis:\nbot: {{ pr.author | match(list=['github-actions','_bot_','[bot]','dependabot','gitstream-cm','prvalidation','aida-bot']) | some }}\ncolors:\nred:    'b60205'\nyellow: 'fbca04'\ngreen:  '0e8a16'\n</code></pre> <p>GitHub Actions</p> <p>Once your gitStream configuration file is setup, you need a GitHub Actions configuration file to trigger gitStream automations. Create a <code>.github/workflows/gitstream.yml</code> file in your repository's default branch (usually <code>master</code> or <code>main</code>) and add the following configuration:</p> <pre><code># Code generated by gitStream GitHub app - DO NOT EDIT\nname: gitStream workflow automation\nrun-name: |\n/:\\ gitStream: PR #${{ fromJSON(fromJSON(github.event.inputs.client_payload)).pullRequestNumber }} from ${{ github.event.inputs.full_repository }}\non:\nworkflow_dispatch:\ninputs:\nclient_payload:\ndescription: The Client payload\nrequired: true\nfull_repository:\ndescription: the repository name include the owner in `owner/repo_name` format\nrequired: true\nhead_ref:\ndescription: the head sha\nrequired: true\nbase_ref:\ndescription: the base ref\nrequired: true\ninstallation_id:\ndescription: the installation id\nrequired: false\nresolver_url:\ndescription: the resolver url to pass results to\nrequired: true\nresolver_token:\ndescription: Optional resolver token for resolver service\nrequired: false\ndefault: ''\njobs:\ngitStream:\ntimeout-minutes: 15\nruns-on: ubuntu-latest\nname: gitStream workflow automation\nsteps:\n- name: Adding PR Url\nrun: |\necho '[${{ fromJSON(fromJSON(inputs.client_payload)).repo }}#${{ fromJSON(fromJSON(inputs.client_payload)).prContext.number }}](${{ fromJSON(fromJSON(inputs.client_payload)).prContext.url }}) - `${{ fromJSON(fromJSON(inputs.client_payload)).branch }}` by ${{ fromJSON(fromJSON(inputs.client_payload)).prContext.author }}' &gt;&gt; $GITHUB_STEP_SUMMARY\n- name: Evaluate Rules\nuses: linear-b/gitstream-github-action@v2\nid: rules-engine\nwith:\nfull_repository: ${{ github.event.inputs.full_repository }}\nhead_ref: ${{ github.event.inputs.head_ref }}\nbase_ref: ${{ github.event.inputs.base_ref }}\nclient_payload: ${{ github.event.inputs.client_payload }}\ninstallation_id: ${{ github.event.inputs.installation_id }}\nresolver_url: ${{ github.event.inputs.resolver_url }}\nresolver_token: ${{ github.event.inputs.resolver_token }}\n</code></pre> <p>  Download gitstream.yml (regular version) </p> <p>Large Repository Support (Lite Version)</p> <p>If you're working with a large repository (typically monorepos) and experience timeout issues during GitHub Actions execution, you can use the lite version of gitStream that performs a shallow clone to reduce execution time:</p> <pre><code>jobs:\ngitStream:\ntimeout-minutes: 15\nruns-on: ubuntu-latest\nname: gitStream workflow automation\nsteps:\n- name: Evaluate Rules\nuses: linear-b/gitstream-github-action@v2-lite\nid: rules-engine\n</code></pre> <p>Important: The lite version has limitations - automations that rely on Git history (such as code-experts) may not work properly due to the shallow clone.</p> <p>  Download gitstream.yml (lite version) </p> <p>Success</p> <p>When finished, you should have the following file structure in your repo.</p> <pre><code>.\n\u251c\u2500 .cm/\n\u2502  \u2514\u2500 gitstream.cm\n\u251c\u2500 .github/\n\u2502  \u2514\u2500 workflows/\n\u2502     \u2514\u2500 gitstream.yml\n</code></pre> <p>GitHub Organization Setup</p> <p>Organization rules are ideal when you want to enforce consistent rules across every repo in your organization. You can define them by creating a special repository named <code>cm</code> in your GitHub organization where you can add automation files that will apply to all repositories within that organization.</p> <p>Prerequisite: Create a cm repo and enable gitStream.</p> <p>Organization-wide automations need to be defined in a repo named \"cm\" inside your GitHub organization. Before continuing, you must create this repo and enable the gitStream app for it.</p> <p>Required Configurations</p> <p>gitStream</p> <p>Create a <code>gitstream.cm</code> rules file in the root directory of your cm repository's default branch (usually <code>master</code> or <code>main</code>). This file will contain a YAML configuration that determines the workflows that run on your organization's repos. You can name it anything you want as long as it ends in <code>.cm</code></p> <p>Configuration files go in the repo's root directory.</p> <p>Unlike the set up instructions for a single repo, your <code>.cm</code> files should be placed in the repository's root directory.</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlinearb_ai_codereview:\n# Ai Code Review - Triggers only when PR is ready for review, see docs https://docs.gitstream.cm/execution-model/#action-level-execution-control\non: [pr_created, pr_ready_for_review, merge]\nif:\n- {{ not is.bot }}\nrun:\n- action: code-review@v1\nargs:\nguidelines: |\n- Keep suggestions short and actionable.\npr_policy_low_noise:\non: [pr_created, commit]\nif:\n- {{ not pr.draft }}\n- {{ not is.bot }}\nrun:\n# AI description (updates PR body; not a comment)\n- action: describe-changes@v1\nargs:\nconcat_mode: append\n# Quiet labels\n- action: add-label@v1\nargs:\nlabel: \"{{ calc.etr }} min review\"\ncolor: {{ colors.red if (calc.etr &gt;= 20) else (colors.yellow if (calc.etr &gt;= 5) else colors.green) }}\n- action: add-label@v1\nwhen :  {{ pr.unresolved_threads }}\nargs:\nlabel: \"{{ pr.unresolved_threads | default(value=0) }} unresolved thread(s)\"\ncolor: {{ colors.yellow }}\n- action: add-label@v1\nwhen: {{ not (has.jira_ticket_in_title or has.jira_ticket_in_desc) }}\nargs:\nlabel: \"missing-jira\"\ncolor: {{ colors.red }}\n# further automations available with Jira webhook\n# Assign reviewers silently\n- action: add-reviewers@v1\nargs:\nreviewers: {{ who.experts }}\n# ONE consolidated, updatable comment\n- action: add-comment@v1\nargs:\ncomment: |\n## gitStream Summary \u2014 Low Noise (Staff Engineer focus)\n**AI PR Description:** Updated in the PR body above.\n**ETR:** {{ calc.etr }} min review\n**Unresolved threads:** {{ pr.unresolved_threads | default(value=0) }}\n### Suggested Reviewers (auto-assigned)\n{{ who.experts }}\n### Jira Reference\n{{ '\u2705 Found in title/description.' if (has.jira_ticket_in_title or has.jira_ticket_in_desc) else '\u26a0\ufe0f Missing Jira ticket. Please add one (e.g., `ABC-123` or an `atlassian.net/browse/...` link).' }}\n&gt; Labels/reviewers were applied quietly to keep this PR clean.\n# ----------------- config -----------------\ncalc:\netr: {{ branch | estimatedReviewTime }}\nhas:\njira_ticket_in_title: {{ pr.title       | includes(regex=r/\\b[A-Za-z][A-Za-z0-9_]+-\\d+\\b/) }}\njira_ticket_in_desc:  {{ pr.description | includes(regex=r/\\b[A-Za-z][A-Za-z0-9_]+-\\d+\\b/) }}\nwho:\nexperts: {{ repo | codeExperts(gt=10) }}\nis:\nbot: {{ pr.author | match(list=['github-actions','_bot_','[bot]','dependabot','gitstream-cm','prvalidation','aida-bot']) | some }}\ncolors:\nred:    'b60205'\nyellow: 'fbca04'\ngreen:  '0e8a16'\n</code></pre> GitHub Actions</p> <p>Once your gitStream configuration file is set up, you will need to create a GitHub Actions configuration file to trigger gitStream automations. Create a <code>.github/workflows/gitstream.yml</code> file in your <code>cm</code> repository's default branch (usually <code>master</code> or <code>main</code>) and add the following configuration:</p> <pre><code># Code generated by gitStream GitHub app - DO NOT EDIT\nname: gitStream workflow automation\nrun-name: |\n/:\\ gitStream: PR #${{ fromJSON(fromJSON(github.event.inputs.client_payload)).pullRequestNumber }} from ${{ github.event.inputs.full_repository }}\non:\nworkflow_dispatch:\ninputs:\nclient_payload:\ndescription: The Client payload\nrequired: true\nfull_repository:\ndescription: the repository name include the owner in `owner/repo_name` format\nrequired: true\nhead_ref:\ndescription: the head sha\nrequired: true\nbase_ref:\ndescription: the base ref\nrequired: true\ninstallation_id:\ndescription: the installation id\nrequired: false\nresolver_url:\ndescription: the resolver url to pass results to\nrequired: true\nresolver_token:\ndescription: Optional resolver token for resolver service\nrequired: false\ndefault: ''\njobs:\ngitStream:\ntimeout-minutes: 15\nruns-on: ubuntu-latest\nname: gitStream workflow automation\nsteps:\n- name: Adding PR Url\nrun: |\necho '[${{ fromJSON(fromJSON(inputs.client_payload)).repo }}#${{ fromJSON(fromJSON(inputs.client_payload)).prContext.number }}](${{ fromJSON(fromJSON(inputs.client_payload)).prContext.url }}) - `${{ fromJSON(fromJSON(inputs.client_payload)).branch }}` by ${{ fromJSON(fromJSON(inputs.client_payload)).prContext.author }}' &gt;&gt; $GITHUB_STEP_SUMMARY\n- name: Evaluate Rules\nuses: linear-b/gitstream-github-action@v2\nid: rules-engine\nwith:\nfull_repository: ${{ github.event.inputs.full_repository }}\nhead_ref: ${{ github.event.inputs.head_ref }}\nbase_ref: ${{ github.event.inputs.base_ref }}\nclient_payload: ${{ github.event.inputs.client_payload }}\ninstallation_id: ${{ github.event.inputs.installation_id }}\nresolver_url: ${{ github.event.inputs.resolver_url }}\nresolver_token: ${{ github.event.inputs.resolver_token }}\n</code></pre> <p>  Download gitstream.yml (regular version) </p> <p>Large Repository Support (Lite Version)</p> <p>If you're working with large repositories in your organization (typically monorepos) and experience timeout issues during GitHub Actions execution, you can use the lite version of gitStream that performs a shallow clone to reduce execution time:</p> <pre><code>jobs:\ngitStream:\ntimeout-minutes: 15\nruns-on: ubuntu-latest\nname: gitStream workflow automation\nsteps:\n- name: Evaluate Rules\nuses: linear-b/gitstream-github-action@v2-lite\nid: rules-engine\n</code></pre> <p>Important: The lite version has limitations - automations that rely on Git history (such as code-experts) may not work properly due to the shallow clone. See the troubleshooting section for more details.</p> <p>  Download gitstream.yml (lite version) </p> <p>Success</p> <p>Once finished, all PRs to your organization's repositories will be processed by the GitHub Action in this repo, and your <code>cm</code> repo should have a file directory that looks like this.</p> <pre><code>.\n\u251c\u2500 gitstream.cm\n\u251c\u2500 .github/\n\u2502  \u2514\u2500 workflows/\n\u2502     \u2514\u2500 gitstream.yml\n</code></pre> <p>gitStream will now do these two things.</p> <p>When a PR is created or changed, apply or update a label that provides an estimated time to review.   When a new PR is created, comment with a list of code experts. </p>"},{"location":"github-installation/#next-step","title":"Next Step","text":"<p>How gitStream Works</p> <p>Read our guide: How gitStream Works to get an overview of the gitStream syntax and automation lifecycle.</p>"},{"location":"github-installation/#additional-resources","title":"Additional Resources","text":""},{"location":"github-installation/#required-github-permissions","title":"Required GitHub Permissions","text":"Permissions Reason Write access to dedicated gitStream app files Used to set up the gitStream workflow files Write access to code To allow gitStream to approve PRs once all conditions are met Read access to administration, issues, and metadata To get the user team membership, and branch protection settings Read and write access to actions, checks, pull requests, and workflows Trigger workflows, create and update pull requests and their checks, and modify workflow files User email Used to identify users"},{"location":"github-installation/#configure-gitstream-to-block-merges","title":"Configure gitStream to Block Merges","text":"<p>You can configure GitHub to require gitStream checks to pass before PRs can be merged using branch protection rules.</p> <p>Run a gitStream check before continuing</p> <p>You need to run a check using your gitStream configuration at least once before it can be set as a required check. Make sure to open at least 1 PR before doing this setting.</p> <p>Here are the steps to configure gitStream in your repo's branch protection rules.</p> <ol> <li>Go to repo <code>settings</code></li> <li>On the left panel select <code>Code and automation</code> &gt; <code>Branches</code></li> <li>Set <code>Branch protection rules</code> for your desired branch</li> <li>Enable <code>Require status checks to pass before merging</code></li> <li>Search for <code>status checks in the last week for this repository</code></li> <li>Select <code>gitStream.cm</code> as required check</li> </ol> <p></p> <p></p>"},{"location":"github-installation/#configuring-gitstream-with-self-hosted-runners","title":"Configuring gitStream with Self-Hosted Runners","text":"<p>Follow these steps to ensure gitStream runs on self-hosted GitHub Actions runners:</p> <ol> <li> <p>Configure Self-Hosted Runners</p> <ul> <li>Set up self-hosted runners for your GitHub organization or repository. Refer to GitHub documentation on self-hosted runners and using them in a workflow for detailed instructions.</li> </ul> </li> <li> <p>Prerequisites for Self-Hosted Runners</p> <ul> <li>Git: Installation instructions can be found here.</li> <li>Python 3.x<ul> <li>black 24.4.2</li> </ul> </li> </ul> </li> <li> <p>Update GitHub Actions Configuration</p> <ul> <li>Modify the gitStream GitHub Actions workflow file (<code>.github/workflows/gitstream.yml</code>) to specify self-hosted runners:</li> </ul> <pre><code>jobs:\ngitStream:\nruns-on: self-hosted\n# ... other configuration ...\n</code></pre> </li> <li> <p>Save and Commit</p> <ul> <li>Save changes to the workflow file and commit them to your repository.</li> </ul> </li> <li> <p>Test with a Sample PR</p> <ul> <li>Create a sample pull request to verify gitStream's behavior with self-hosted runners.</li> </ul> </li> </ol>"},{"location":"github-installation/#uninstalling-gitstream","title":"Uninstalling gitStream","text":"<p>Configure in your GitHub organization, and choose <code>Uninstall \"gitStream.cm\"</code></p>"},{"location":"github-org-level/","title":"Github org level","text":"<p>Deprecated</p>"},{"location":"github-required-check/","title":"Github required check","text":"<p>Deprecated</p>"},{"location":"gitlab-installation/","title":"How to Setup gitStream with GitLab","text":"<p>Prerequisites</p> <ol> <li>GitLab</li> <li>GitLab runner v15 or higher with ability to run apk commands</li> <li>Login, or create a free account on the LinearB app, and follow the steps to connect gitStream Using a GitLab Integration.</li> <li>Allowed network connection between the executors and the following IPs:<ul> <li>13.56.203.235</li> <li>54.151.81.98</li> </ul> </li> </ol> Understanding IP Allowlisting for gitStream <p>When setting up IP allowlists in GitLab, you're specifying which source IP addresses are permitted to interact with your repositories and APIs. This affects both gitStream and your CI/CD runners.</p> <p>There are two primary cases where this matters for gitStream:</p> <ol> <li>Webhook Event Handling by gitStream    When GitLab triggers a webhook event (e.g., a merge request opened), gitStream may need to make follow-up API calls to GitLab. This can include fetching additional metadata, posting comments to the MR, or performing other actions. These calls are made from the LinearB/gitStream service, which uses a fixed set of IP addresses. These IPs must be added to your GitLab allowlist to ensure proper operation.</li> <li>Outbound Requests from Your CI Runner    When your pipeline runs gitStream, that runner might also make outbound calls to GitLab\u2014for example, to clone a repository or retrieve commit history. These requests will originate from the runner's IP address.</li> </ol> <p>If you encounter errors due to blocked IPs during your CI runs, it's likely that the runner is using an IP that is not part of the configured allowlist.</p> <p>Recommended Solution To ensure reliability:</p> <ul> <li>Add LinearB/gitStream service IPs to your GitLab allowlist (listed above).</li> <li>Use self-hosted runners or runners with static IPs so you can manage and allowlist their addresses explicitly.</li> </ul> <p>This combination ensures that both gitStream's internal operations and your CI runners' interactions with GitLab function without network restrictions.</p> <p>GitLab Installation Overview</p> <ol> <li>Designate a gitStream user account.</li> <li>Create a <code>cm</code> repo and <code>.cm</code> configuration file.</li> <li>Create a GitLab pipeline.</li> <li>Connect gitStream in LinearB.</li> </ol>"},{"location":"gitlab-installation/#designate-a-gitstream-user-account","title":"Designate a gitStream User Account","text":"<p>gitStream automation rules are executed on behalf of the user account configured when you connect gitStream to your GitLab instance. This account must have the appropriate permissions to the relevant repositories.</p> <ul> <li>The account must have the <code>maintainer</code> or <code>owner</code> role to the relevant repos</li> <li>We recommend creating a dedicated service account to control access to individual repos easily. A meaningful account identifier whose name contains the string <code>gitstream</code> (case insensitive), such as <code>gitStream-cm</code>, is recommended to ensure clarity and proper identification of the automated actions</li> <li>You can also use your professional or personal GitLab account, though this would result in all automations being executed under that account, which might also affect LinearB's metrics</li> </ul> <p>Use this account when you integrate gitStream</p> <p>Make sure to use this account when authorizing GitLab in LinearB.</p>"},{"location":"gitlab-installation/#create-a-cm-repo-and-cm-configuration-file","title":"Create a <code>cm</code> repo and <code>.cm</code> configuration file.","text":"<p>Create a <code>cm</code> project (repository) in your GitLab group. This repository must be created in the same group or parent group as the target repositories. In the root directory of the default branch (usually <code>master</code> or <code>main</code>), create a <code>gitstream.cm</code> rules file to define the workflow automations. The file name can vary but must end in <code>.cm</code>.</p> <p>Configuration File Locations</p> <p>Group-level rules require your <code>.cm</code> files to be placed in the <code>cm</code> repository's root directory. You can also define specific repo-level rules under the <code>.cm</code> folder in each of the connected repositories.</p> <p>Example Configuration</p> <pre><code># -*- mode: yaml -*-\nmanifest:\n  version: 1.0\n\nautomations:\n  linearb_ai_codereview:\n    if:\n      - {{ not is.bot }}\n    run:\n      - action: code-review@v1\n        args:\n          guidelines: |\n            - Keep suggestions short and actionable.\n\n  pr_policy_low_noise:\n    if:\n      - {{ not pr.draft }}\n      - {{ not is.bot }}\n    run:\n      # AI description (updates PR body; not a comment)\n      - action: describe-changes@v1\n        args:\n          concat_mode: append\n\n      # Assign reviewers silently\n      - action: add-reviewers@v1\n        args:\n          reviewers: {{ who.experts }}\n\n      # ONE consolidated, updatable comment\n      - action: add-comment@v1\n        args:\n          comment: |\n            ## gitStream Summary \u2014 Low Noise (Staff Engineer focus)\n\n            **AI PR Description:** Updated in the PR body above.  \n            **ETR:** {{ calc.etr }} min review\n            **Unresolved threads:** {{ pr.unresolved_threads | default(value=0) }}\n            **JIRA:** {{ '\u2705 Found in title/description.' if (has.jira_ticket_in_title or has.jira_ticket_in_desc) else '\u26a0\ufe0f Missing Jira ticket. Please add one (e.g., `ABC-123` or an `atlassian.net/browse/...` link).' }}\n\n            ### Suggested Reviewers (auto-assigned)\n            {{ who.experts }}\n\n# ----------------- config -----------------\ncalc:\n  etr: {{ branch | estimatedReviewTime }}\n\nhas:\n  jira_ticket_in_title: {{ pr.title       | includes(regex=r/\\b[A-Za-z][A-Za-z0-9_]+-\\d+\\b/) }}\n  jira_ticket_in_desc:  {{ pr.description | includes(regex=r/\\b[A-Za-z][A-Za-z0-9_]+-\\d+\\b/) }}\n\nwho:\n  experts: {{ repo | codeExperts(gt=10) }}\n\nis:\n  bot: {{ pr.author | match(list=['github-actions','_bot_','[bot]','dependabot','gitstream-cm','prvalidation','aida-bot']) | some }}\n\ncolors:\n  red:    'b60205'\n  yellow: 'fbca04'\n  green:  '0e8a16'\n</code></pre> <p>Explicit triggers are not supported</p> <p>The <code>triggers</code> and <code>on</code> functionality are not currently supported in GitLab. If you include them in your CM automation files, gitStream will skip the automations entirely.</p>"},{"location":"gitlab-installation/#create-a-gitlab-pipeline","title":"Create a GitLab Pipeline","text":"<p>Once your gitStream configuration file is set up, you need a GitLab CI configuration file to trigger gitStream automations. Create a <code>cm</code> project (repository) in your GitLab group if you haven't already. It should be created in the same group or a parent group of the target repositories. Create a <code>.gitlab-ci.yml</code> file in your new <code>cm</code> repository's default branch (usually <code>master</code> or <code>main</code>) and add the following configuration:</p> <p>Variables Access Configuration for CM Project</p> <p>In your CM project/repository only, ensure that the CI/CD settings have the Variables section with the \"Minimum role to use pipeline variables\" setting configured to any value other than \"No one allowed\". This allows the pipeline in the CM repository to access the necessary variables for gitStream to function properly. You can find this setting under Settings &gt; CI/CD &gt; Variables in the CM project.</p> GitLab-Hosted runnersSelf-Managed Runners - ShellSelf-Managed Runners - Kubernetes <p>Gitlab-Hosted Runners</p> <p>Use the following <code>.gitlab-ci.yml</code></p> <pre><code># Code generated by gitStream - DO NOT EDIT\nvariables:\nDOCKER_DRIVER: overlay2\nDOCKER_HOST: tcp://docker:2375\nDOCKER_TLS_CERTDIR: \"\"\nstages:\n- gitstream-main\nimage: docker:latest\nservices:\n- name: docker:dind\nbefore_script:\n- docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY\ngitstream-job:\nstage: gitstream-main\nonly:\nvariables:\n- $GITSTREAM_MAIN_JOB\nexcept:\nvariables:\n- $GITSTREAM_BLOCK_MERGE\nscript:\n- git clone --shallow-since=\"6 months ago\" --no-tags https://gitlab-ci-token:${CI_JOB_TOKEN}${repoUrl} gitstream/repo\n- git clone --depth=1 --no-tags https://gitlab-ci-token:${CI_JOB_TOKEN}${cmUrl} gitstream/cm\n- cd gitstream/repo &amp;&amp; git fetch origin $head_ref:$head_ref &amp;&amp; git checkout $head_ref\n- docker pull gitstream/rules-engine:latest\n- |\ndocker run -v $CI_PROJECT_DIR/gitstream:/code \\\n-e CLIENT_PAYLOAD=\"$client_payload\" \\\n-e DEBUG_MODE=true  gitstream/rules-engine:latest\n</code></pre> <p>Self-Managed Runners</p> <p>First, register the runner with a tag, and use the named tag in the <code>.gitlab-ci.yml</code> file</p> <p>Shell executors</p> <p>Use the tag created above in the workflow file <code>cm/.gitlab-ci.yml</code> instead <code>REGISTERED-TAG</code> <pre><code># Code generated by gitStream - DO NOT EDIT\nstages:\n- gitstream-main\nimage: docker:latest\nservices:\n- docker:dind\nbefore_script:\n- docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY\ngitstream-job:\nstage: gitstream-main\ntags:\n- REGISTERED-TAG\nonly:\nvariables:\n- $GITSTREAM_MAIN_JOB\nexcept:\nvariables:\n- $GITSTREAM_BLOCK_MERGE\nscript:\n- git clone --shallow-since=\"6 months ago\" --no-tags https://gitlab-ci-token:${CI_JOB_TOKEN}${repoUrl} gitstream/repo\n- git clone --depth=1 --no-tags https://gitlab-ci-token:${CI_JOB_TOKEN}${cmUrl} gitstream/cm\n- cd gitstream/repo &amp;&amp; git fetch origin $head_ref:$head_ref &amp;&amp; git checkout $head_ref\n- docker pull gitstream/rules-engine:latest\n- |\ndocker run -v $CI_PROJECT_DIR/gitstream:/code \\\n-e CLIENT_PAYLOAD=\"$client_payload\" \\\n-e DEBUG_MODE=true  gitstream/rules-engine:latest\n</code></pre></p> <p>Self-Managed Runners</p> <p>First, register the runner with a tag, and use the named tag in the <code>.gitlab-ci.yml</code> file</p> <p>Kubernetes executors</p> <ol> <li>Ensure your runner configuration (<code>config.toml</code> for example) has the followig: <pre><code>[runners.kubernetes]\nprivileged = true\n</code></pre></li> <li>Use the tag created above in the workflow file <code>cm/.gitlab-ci.yml</code> instead <code>REGISTERED-TAG</code> <pre><code># Code generated by gitStream - DO NOT EDIT\nvariables:\nDOCKER_DRIVER: overlay2\nDOCKER_HOST: tcp://docker:2375\nDOCKER_TLS_CERTDIR: \"\"\nstages:\n- gitstream-main\nimage: docker:latest\nservices:\n- name: docker:dind\ncommand: [\"--mtu=1450\", \"--tls=false\"]\nbefore_script:\n- docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY\ngitstream-job:\nstage: gitstream-main\ntags:\n- REGISTERED-TAG\nonly:\nvariables:\n- $GITSTREAM_MAIN_JOB\nexcept:\nvariables:\n- $GITSTREAM_BLOCK_MERGE\nscript:\n- git clone --shallow-since=\"6 months ago\" --no-tags https://gitlab-ci-token:${CI_JOB_TOKEN}${repoUrl} gitstream/repo\n- git clone --depth=1 --no-tags https://gitlab-ci-token:${CI_JOB_TOKEN}${cmUrl} gitstream/cm\n- cd gitstream/repo &amp;&amp; git fetch origin $head_ref:$head_ref &amp;&amp; git checkout $head_ref\n- docker pull gitstream/rules-engine:latest\n- |\ndocker run -v $CI_PROJECT_DIR/gitstream:/code \\\n-e CLIENT_PAYLOAD=\"$client_payload\" \\\n-e DEBUG_MODE=true  gitstream/rules-engine:latest\n</code></pre></li> </ol> <p>Configuring the image location</p> <p>By default, gitStream pulls the image from DockerHub each time it is invoked. You can configure gitStream to pull the docker image from your own registry, to allow faster build times and reduced bandwidth usage - especially for teams with high CI/CD throughput, by downloading the image and storing it in your own registry (ECR or K8S registry, for example) and changing the <code>cm/.gitlab-ci.yml</code> accordingly: <pre><code>script:\n- ...\n- docker pull YOUR-REGISTRY-URL/gitstream/rules-engine:latest\n</code></pre> The docker image can be pulled to your private repository from DockerHub.</p>"},{"location":"gitlab-installation/#connect-gitstream-in-linearb","title":"Connect gitStream in LinearB","text":"<p>To complete the setup, connect gitStream in LinearB. Follow the instructions in the LinearB app to connect your GitLab account and repositories to gitStream.</p>"},{"location":"gitlab-installation/#next-step","title":"Next Step","text":"<p>If you complete these instructions, gitStream will now automate your Merge Request workflows on GitLab.</p> <p>How gitStream Works</p> <p>Read our guide, How gitStream Works, for a deeper understanding of gitStream's capabilities and how to leverage them fully.</p>"},{"location":"gitlab-installation/#additional-resources","title":"Additional Resources","text":""},{"location":"gitlab-installation/#required-gitlab-permissions","title":"Required GitLab Permissions","text":"<p>The required permissions are:</p> Permissions Reason Read/Write API To get notified on MR changes and allow gitStream to approve MRs once all conditions are met Read repository To read and check rules over the code changes on monitored repositories Read user profile Used to identify users"},{"location":"how-it-works/","title":"How gitStream Works","text":"<p>You can configure gitStream via one or more Continuous Merge (CM) files inside your git repository or GitHub/GitLab/Bitbucket organization. These files end with a <code>.cm</code>  extension, and they outline automations that will run for your repo's pull requests. </p>"},{"location":"how-it-works/#syntax-overview","title":"Syntax Overview","text":"<p>CM files contain a combination of YAML and Jinja2 to build rules that follow an \"if this, then that\" approach to triggering and executing automations. This, combined with templating and gitStream-specific functions gives you a highly-flexible framework for building custom CM automations.</p> <p>All CM files must have a section that starts with <code>automations:</code> that contains one or more custom automations that will trigger for the repo. By default, gitStream is triggered every time someone opens a new PR or pushes a commit to an existing PR. Once activated, gitStream searches for applicable CM files and executes the automations that are listed inside them.</p> <p>Explicit Triggers</p> <p>You can configure gitStream to trigger for other PR interactions, including comments, labels, and merge status. Read more about the gitStream execution model.</p> <p>Here is an example of the basic components that are required in every CM file.</p> <p>Required CM Components</p> <p>Please note, this is not a valid CM automation, it is only for illustrative purposes. <pre><code>    # -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nmy_automation:\nif:\n- # Add a condition here\nrun:\n- # Add an automation here\n</code></pre></p> <p>Info</p> <p>When editing CM files, make sure you preserve the indentation in the examples because, like YAML, gitStream uses Python-style indentation to indicate nesting.</p>"},{"location":"how-it-works/#automation-actions","title":"Automation Actions","text":"<p>Automation actions define the desired automations triggered when specific conditions are met. Each automation must contain an <code>if</code> condition and a <code>run</code> section. Conditions are evaluated when a PR is created or modified. Multiple conditions can be listed, but all must be true to trigger the actions.</p> <p>Any number of actions can be included in a single automation, and these actions are invoked one-by-one in no particular order. PRs marked as Draft are ignored by default, and this behavior can be modified using explicit triggers (GitHub only).</p> <p>Basic Automation Example</p> <p>This example defines an automation named <code>welcome_newcomer</code> that posts a comment to welcome anyone who submits their first PR to the repo. <pre><code>automations:\nwelcome_newcomer:\nif: - {{ repo.contributors | isFirstCommit(branch.author) }}\nrun: - action: add-comment@v1\nargs:\ncomment: Welcome {{branch.author}}!\n</code></pre></p>"},{"location":"how-it-works/#context-variables-and-filter-functions","title":"Context Variables and Filter Functions","text":"<p>Context variables are pre-defined objects that gitStream provides as the input data you will need to build your automations. These variables enable you to access information about things like the file names and paths, the person who submitted the PR, or what code was changed.</p> <p>Filter functions are functions you can call and apply to variables. They are called with a pipe operator <code>|</code> and can take arguments inside parentheses <code>( )</code>. The logic expressions are based on Jinja2 syntax, supported by the Nunjucks library.</p> <p>Context Variable and Filter Function Example</p> <p>The following statement passes the context variable <code>files</code> to the filter function <code>match</code> which uses an optional list of sensitive filepaths that would need to be defined later in the CM file, and returns true if any of the files match the list as indicated by the <code>some</code> filter function. <pre><code>{{ files | match(list=sensitive) | some }}\n</code></pre></p> <p>You can also apply Nunjucks logic operators to filters</p> <p>Logic Operators Example</p> <p>This example inverts the previous example using the keyword <code>not</code>. <pre><code>{{ not (files | match(list=sensitive) | some )}}\n</code></pre></p>"},{"location":"how-it-works/#custom-expressions","title":"Custom Expressions","text":"<p>Jinja templating makes it easy to write custom expressions that can be invoked elsewhere in your CM files. This makes it easy to reuse data, define custom criteria, and keep your configuration files cleaner so they're easier to manage.  </p> <p>Custom Expressions Example</p> <p>This example contains two custom expressions; <code>is:</code> contains a context variable and some filter functions that are invoked in the <code>sensitive_review</code> automation via <code>is.sensitive</code>, and <code>sensitive directories</code> contains a list of directory paths that will be matched in the filter function. <pre><code>automations:\nsensitive_review:\nif:\n- is.sensitive\nrun:\n- action: set-required-approvals@v1\nargs:\napprovals: 2\nis:\nsensitive: {{ files | match(list=sensitive_directories) | some }}\nsensitive_directories:\n- src/app/auth/\n- src/app/routing/\n- src/app/resources/\n</code></pre></p>"},{"location":"how-it-works/#built-in-functions","title":"Built-in Functions","text":"<p>gitStream is built on top of Jinja2 and provides all default filters from that library. gitStream also includes extra filters on top of Jinja2 that are specific to git repo workflow automations.</p> <p>Warning</p> <p>Don't use these terms when naming automations, plugins, custom expressions, or any other component of gitStream because this will lead to naming conflicts</p> <p>gitStream filters:</p> <p><code>allDocs</code> <code>allImages</code> <code>allTests</code> <code>automations</code> <code>codeExperts</code> <code>config</code> <code>difference</code> <code>estimatedReviewTime</code> <code>explainCodeExperts</code> <code>explainRankByGitBlame</code> <code>extractJitFindings</code> <code>extractSonarFindings</code> <code>extensions</code> <code>every</code> <code>filter</code> <code>includes</code> <code>isFirstCommit</code> <code>isFormattingChange</code> <code>intersection</code> <code>manifest</code> <code>map</code> <code>mapToEnum</code> <code>match</code> <code>matchDiffLines</code> <code>nope</code> <code>rankByGitActivity</code> <code>rankByGitBlame</code> <code>reject</code> <code>some</code></p> <p>Nunjucks filters:</p> <p><code>abs</code> <code>asyncAll</code> <code>asyncEach</code> <code>batch</code> <code>block</code> <code>call</code> <code>capitalize</code> <code>center</code> <code>default</code> <code>dictsort</code> <code>dump</code> <code>e</code> <code>escape</code> <code>extends</code> <code>filter</code> <code>first</code> <code>float</code> <code>for</code> <code>forceescape</code> <code>groupby</code> <code>if</code> <code>import</code> <code>include</code> <code>indent</code> <code>int</code> <code>join</code> <code>last</code> <code>length</code> <code>list</code> <code>lower</code> <code>macro</code> <code>nl2br</code> <code>raw</code> <code>reject</code> <code>rejectattr</code> <code>replace</code> <code>reverse</code> <code>round</code> <code>safe</code> <code>select</code> <code>selectattr</code> <code>set</code> <code>slice</code> <code>sort</code> <code>string</code> <code>striptags</code> <code>sum</code> <code>title</code> <code>trim</code> <code>truncate</code> <code>upper</code> <code>urlencode</code> <code>urlize</code> <code>verbatim</code> <code>wordcount</code></p>"},{"location":"how-it-works/#ignore-files","title":"Ignore Files","text":"<p>You can provide gitStream with a list of specific files to ignore for all automations listed in the same CM file. To do so, add a <code>configuration:</code> section to the CM file that you want to apply the exclusion list to. In the configuration section, add a list of files as an argument to the <code>ignore_files:</code> key.</p> <p>How to Ignore Files</p> <p>To ignore a list of files, add a <code>config.ignore_files</code> to you CM file like this:  <pre><code>config:\nignore_files:\n- 'yarn.lock'\n- 'package-lock.json'\n- 'openapi.json'\n- 'ui/src/**/*Model.d.ts'\n</code></pre></p>"},{"location":"how-it-works/#configuration-priority-and-overrides","title":"Configuration Priority and Overrides","text":"<p>You can provide any number of CM files and automations for gitStream to process and you can freely combine organization-level automations with automations inside individual repos. There are two important things you need to keep in mind when doing this.</p> <p>First, when a repository defines the same automation as an organization-level rule, the repository automation will take precedence and override the organization automation. The CM file name and the automation name must both match for this to take effect because gitStream identifies all automations based on a combination of both. For example, if you have a <code>gitstream.cm</code> file that contains an automation named <code>my_automation</code>, gitStream will identify that as <code>gitstream/my_automation</code>.</p> <p>Second, no priority is given to individual automations. Instead, gitStream collects all applicable automations for a given PR and processes them all at once.</p>"},{"location":"how-it-works/#plugins","title":"Plugins","text":"<p>gitStream supports the use of JavaScript plugins to create new filter functions. This enables you to write code that further extends gitStream capabilities and connect gitStream to external API services. Read the guide on writing gitStream</p>"},{"location":"how-it-works/#next-step","title":"Next Step","text":"<p>Write your first automation.</p> <p>The best way to familiarize yourself with CM syntax is to build automations, and we've covered enough info for you to start!</p> <p>If you're ready to start writing automations, check out our guide: Write Your First Automation.</p>"},{"location":"how-it-works/#additional-resources","title":"Additional Resources","text":""},{"location":"how-it-works/#gitstream-ui","title":"gitStream UI","text":"<p>Once you have gitStream installed and have run some automations, you can view details about them at app.linearb.io/automations. To view gitStream automation data, you will need to login with your LinearB user account.</p> <p></p>"},{"location":"how-it-works/#functional-overview","title":"Functional Overview","text":"<p>Once gitStream is installed and configured, there are several services that will interact with your repository whenever a PR is created or changed:</p> <ul> <li>The git service provider API (e.g. GitHub, GitLab, Bitbucket)</li> <li>The gitStream service that was installed from the git service provider marketplace.</li> <li>A gitStream CI/CD script that is configured for the git service provider (e.g. GitHub Actions, GitLab CI/CD, Bitbucket Pipelines).</li> <li>A gitStream agent the CI/CD script triggers to execute your automation.</li> </ul> <p>Whenever a new PR is opened or an existing PR is changed (see also Execution Model), the following process occurs:</p> <ol> <li>The git service provider API notifies the gitStream service that an applicable change has occurred to the PR which triggers a call to execute the gitStream CI/CD script.</li> <li>Trigger Control evaluates whether to proceed with handling based on event type, branch patterns, or repository names as configured in your Execution Model.</li> <li>The gitStream CI/CD script executes the GitHub Action <code>linear-b/gitstream-github-action@v2</code> on the repository, which looks for two things:<ul> <li>Valid CM files that match the filepath <code>.cm/*.cm</code></li> <li>Any CM files that are contained in the root directory of the organization's cm repo (if applicable).</li> </ul> </li> <li>The gitStream CI/CD script passes all CM metadata to the gitStream agent which parses a list of all applicable CM rules.</li> <li>The GitStream agent provides the list of applicable automations to the gitStream service.</li> <li>The gitStream service iterates through the automations and updates the PR via the git service provider API.</li> </ol> <p>Here is a diagram that illustrates how things work behind the scenes: <pre><code>sequenceDiagram\n  autonumber\n  Git Provider API-&gt;&gt;gitStream app: PR Notification\n  activate gitStream app\n  gitStream app-&gt;&gt;gitStream app: Trigger Control\n  gitStream app-&gt;&gt;gitStream CI/CD script: Execute CI/CD Action\n  activate gitStream CI/CD script\n  gitStream CI/CD script-&gt;&gt;gitStream agent: CM Metadata\n  activate gitStream agent\n  gitStream agent-&gt;&gt;gitStream app: Applicable Automations \n  deactivate gitStream agent\n  deactivate gitStream CI/CD script\n  loop Automations\n    loop Actions\n      gitStream app-&gt;&gt;Git Provider API: Update PR\n    end\n   end\n  deactivate gitStream app</code></pre> Upon completion, gitStream will show one of the following three statuses:</p> <ul> <li> Success - when the applicable automation finished and PR is good to go</li> <li> Neutral - when there aren't any applicable automations for the PR</li> <li> Failed - when the applicable automation finished without completion</li> </ul> <p>gitStream checks have a 10-minute timeout for fail-safe reasons. If the check exceeds this time limit, the result will be displayed as Neutral - Skipped.</p>"},{"location":"how-it-works/#syntax-highlighting","title":"Syntax highlighting","text":"<p>You can add support for <code>.cm</code> in your code editor, see FAQ.</p>"},{"location":"how-it-works/#is-something-missing","title":"Is something missing?","text":"<p>If you find an issue with these docs or with gitStream itself, please search the  gitStream issues page and create an issue if one doesn't already exist for your problem.</p>"},{"location":"limits/","title":"Automation limits for free accounts","text":""},{"location":"limits/#monthly-pr-automation-limit","title":"Monthly PR automation limit","text":"<p>Free accounts have a monthly cap of 250 PRs that can trigger automations in their organization. This limit ensures fair usage while allowing teams to experience gitStream\u2019s benefits before upgrading.</p>"},{"location":"limits/#how-it-works","title":"How it works","text":"<ul> <li>When the account reaches 90% of its quota, a warning appears in PR comments.  </li> <li>Once the limit is reached, new PRs will not execute automations and the gitStream check will be concluded as <code>Skipped</code>.  </li> <li>The limit resets at the start of each month.  </li> </ul>"},{"location":"limits/#what-happens-when-the-limit-is-reached","title":"What happens when the limit is reached?","text":"<ul> <li>PRs that exceed the quota will still be created as usual, but gitStream will not process automations on them.  </li> <li>The PR check will indicate that automations were skipped due to limits.  </li> </ul>"},{"location":"limits/#need-more-automations","title":"Need more automations?","text":"<p>If your team requires a higher automation quota, upgrading to a paid plan will remove these restrictions.</p> <p>Contact LinearB or Book a demo to explore upgrade options.</p>"},{"location":"managed-mode/","title":"Managed Mode","text":"<p>GitHub App Migration</p> <p>If you are using the LinearB GitHub app, you should uninstall the gitStream GitHub app and use only the LinearB GitHub app. The LinearB GitHub app supports both managed and self-managed modes, where the self-managed mode is fully compatible with your existing gitStream setup.</p> <p>Setup Configuration</p> <p>Managed Mode setup is configured entirely from the LinearB platform. You do not need to setup gitStream yourself, add any GitHub Actions, or create CM rule files - all of this is handled automatically by the LinearB platform. For detailed setup instructions, see Managing AI Services in LinearB.</p> <p>Managed Mode is an operation mode for LinearB AI automations where automations run on the LinearB runner as a managed service. This mode is required for accessing AI Insights and provides centralized control of AI automations through LinearB's infrastructure.</p>"},{"location":"managed-mode/#available-managed-automations","title":"Available Managed Automations","text":""},{"location":"managed-mode/#ai-code-review","title":"AI Code Review","text":"<p>Use LinearB's AI with the <code>code-review</code> action to automatically review the introduced changes to the code. This automation triggers on non-draft PRs that were not created by bots and can be customized with specific review guidelines.</p> <pre><code>automations:\nlinearb_ai_review:\nif:\n- {{ not (pr.draft or is.bot_author) }}\nrun:\n- action: code-review@v1\nargs:\nguidelines: {{ loadReviewGuidelines() | dump }}\n</code></pre>"},{"location":"managed-mode/#ai-pr-description","title":"AI PR Description","text":"<p>Use the <code>describe-changes</code> automation action to automatically generate and append a concise, AI-generated description to a pull request. This helps provide clear context for reviewers about the changes introduced.</p> <pre><code>automations:\nlinearb_ai_description:\nif:\n- {{ not (pr.draft or is.bot_author) }}\nrun:\n- action: describe-changes@v1\nargs:\nconcat_mode: append\nguidelines: {{ loadDescriptionGuidelines() | dump }}\n</code></pre>"},{"location":"managed-mode/#smart-labeling-agent-coding-detection","title":"Smart Labeling (Agent Coding Detection)","text":"<p>Automatically apply labels to PRs that are assisted by Claude Code to track time savings, PR risk, and productivity lift from AI tools. This automation can detect Claude Code usage through multiple methods including co-authorship, user prompts, known users, or specific tags.</p> <pre><code>automations:\ntag_claude_in_pr:\nif:\n- {{ is.claude_author or is.claude_co_author }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \ud83e\udd16 Claude Code\ntag_copilot_in_pr:\nif:\n- {{ is.copilot_author or is.copilot_co_author }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \ud83e\udd16 GitHub Copilot\ntag_cursor_in_pr:\nif:\n- {{ is.cursor_author or is.cursor_co_author }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \ud83e\udd16 Cursor AI\ntag_linearb_ai_in_pr:\nif:\n- {{ is.linearb_author or is.linearb_co_author }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \ud83e\udd16 LinearB AI\nis:\nbot_author: {{ pr.author | match(list=[\"github-actions\", \"_bot_\", \"[bot]\", \"dependabot\"]) | some }}\nclaude_author: {{ pr.author | lower | includes(regex=r/claude/) }}\nclaude_co_author: {{ branch.commits.messages | match(regex=r/[Cc]o-[Aa]uthored-[Bb]y:.*[Cc]laude/) | some }}\ncopilot_author: {{ pr.author | lower | includes(regex=r/copilot/) }}\ncopilot_co_author: {{ branch.commits.messages | match(regex=r/[Cc]o-[Aa]uthored-[Bb]y:.*([Cc]opilot|[Gg]ithub.*[Cc]opilot)/) | some }}\ncursor_author: {{ pr.author | lower | includes(regex=r/cursor/) }}\ncursor_co_author: {{ branch.commits.messages | match(regex=r/[Cc]o-[Aa]uthored-[Bb]y:.*[Cc]ursor/) | some }}\nlinearb_author: {{ pr.author | lower | includes(regex=r/^linearb/) and not (pr.author | lower | includes(regex=r/^linearbci$/)) }}\nlinearb_co_author: {{ branch.commits.messages | match(regex=r/[Cc]o-[Aa]uthored-[Bb]y:.*(gitstream-cm|linearb).*\\[bot\\]/) | some }}\n</code></pre>"},{"location":"managed-mode/#estimated-time-to-review","title":"Estimated Time to Review","text":"<p>Label all PRs with an estimated number of minutes it would take someone to review. gitStream automatically updates this label whenever a PR changes, providing valuable insight for reviewers and team planning.</p> <pre><code>automations:\nestimated_time_to_review:\nif:\n- true\nrun:\n- action: add-label@v1\nargs:\nlabel: \"{{ calc.etr }} min review\"\ncolor: {{ colors.red if (calc.etr &gt;= 20) else ( colors.yellow if (calc.etr &gt;= 5) else colors.green ) }}\ncalc:\netr: {{ branch | estimatedReviewTime }}\ncolors:\nred: 'b60205'\nyellow: 'fbca04'\ngreen: '0e8a16'\n</code></pre>"},{"location":"managed-mode/#dependabot-minor-bump-auto-approve","title":"Dependabot Minor Bump Auto-Approve","text":"<p>Auto-merge Dependabot PRs for patch and minor version updates. This automation helps maintain dependencies while ensuring only safe, non-breaking changes are automatically approved and merged.</p> <pre><code>automations:\nmerge_dependabot_minor:\non:\n- pr_created\n- commit\nif:\n- {{ dependabot_bump == 'minor' }}\n- {{ branch.name | includes(term='dependabot') }}\n- {{ branch.author | includes(term='dependabot') }}\nrun:\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: Dependabot `minor` version bumps are approved automatically.\ndependabot_bump: {{ pr.description | checkDependabot | checkSemver }}\n</code></pre>"},{"location":"managed-mode/#dependabot-patch-bump-auto-approve","title":"Dependabot Patch Bump Auto-Approve","text":"<pre><code>automations:\nmerge_dependabot_patch:\non:\n- pr_created\n- commit\nif:\n- {{ dependabot_bump == 'patch' }}\n- {{ branch.name | includes(term='dependabot') }}\n- {{ branch.author | includes(term='dependabot') }}\nrun:\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: Dependabot `patch` version bumps are approved automatically.\ndependabot_bump: {{ pr.description | checkDependabot | checkSemver }}\n</code></pre>"},{"location":"plugins-for-developers/","title":"Plugins Development","text":""},{"location":"plugins-for-developers/#create-filter-function-plugins","title":"Create Filter Function Plugins","text":"<p>gitStream plugins are based on the CommonJS module standard, a widely used pattern for structuring and importing JavaScript modules.</p> <p>Supported JavaScript Dependencies</p> <p>gitStream supports the following JavaScript dependencies: axios, github actions core (@actions/core), moment, lodash, octokit rest api (@octokit/rest)</p> <p>No other dependencies are supported at this time. If you have recommendations for new dependencies, please open a new issue on the gitStream GitHub repo.</p>"},{"location":"plugins-for-developers/#loading-dependencies-in-your-plugin","title":"Loading Dependencies in Your Plugin","text":""},{"location":"plugins-for-developers/#pre-installed-dependencies","title":"Pre-installed Dependencies","text":"<p>To use the supported dependencies in your plugin, you can load them using the standard <code>require()</code> function at the top of your <code>index.js</code> file:</p> <pre><code>// Load supported dependencies\nconst axios = require('axios');\nconst moment = require('moment');\nconst _ = require('lodash');\nconst core = require('@actions/core');\nconst { Octokit } = require('@octokit/rest');\n// Example plugin using axios for HTTP requests\nconst myPlugin = async (url, callback) =&gt; {\ntry {\nconst response = await axios.get(url);\nreturn callback(null, response.data);\n} catch (error) {\nreturn callback(error, null);\n}\n};\nmodule.exports = {\nasync: true,\nfilter: myPlugin\n};\n</code></pre> <p>Pre-installed Dependency Usage Examples:</p> <ul> <li>axios: Make HTTP requests to external APIs</li> <li>moment: Parse, manipulate, and format dates</li> <li>lodash: Utility functions for working with arrays, objects, and other data types</li> <li>@actions/core: Access GitHub Actions core functionality (when running in GitHub Actions context)</li> <li>@octokit/rest: Interact with the GitHub REST API</li> </ul>"},{"location":"plugins-for-developers/#runtime-package-installation","title":"Runtime Package Installation","text":"<p>For async plugins, you can dynamically install any npm package at runtime using <code>execSync</code> to run <code>npm install</code>:</p> <pre><code>const { execSync } = require('child_process');\nconst myAdvancedPlugin = async (source, callback) =&gt; {\ntry {\n// Install packages at runtime (only runs once per execution)\nexecSync('npm install --silent tree-sitter tree-sitter-javascript', { stdio: 'pipe' });\n// Now you can require the dynamically installed packages\nconst Parser = require('tree-sitter');\nconst JavaScript = require('tree-sitter-javascript');\nconst parser = new Parser();\nparser.setLanguage(JavaScript);\n// Use the newly installed packages\nconst jsFiles = source?.diff?.files?.filter(f =&gt; f.new_file?.endsWith('.js')) || [];\nconst firstJsFile = jsFiles[0];\nif (!firstJsFile?.new_content) {\nreturn callback(null, JSON.stringify([]));\n}\nconst tree = parser.parse(firstJsFile.new_content);\n// Process the parsed tree...\nconst comments = [];\nconst traverse = (node) =&gt; {\nif (node.type === 'comment') {\ncomments.push(node.text);\n}\nfor (let i = 0; i &lt; node.childCount; i++) {\ntraverse(node.child(i));\n}\n};\ntraverse(tree.rootNode);\nreturn callback(null, JSON.stringify(comments));\n} catch (error) {\nreturn callback(error, null);\n}\n};\nmodule.exports = { async: true, filter: myAdvancedPlugin };\n</code></pre>"},{"location":"plugins-for-developers/#define-a-new-plugin","title":"Define a New Plugin","text":"<p>Each filter function plugin must have its own unique directory inside the appropriate <code>/filters</code> directory for your repo or organization. To create a new filter function, create an index.js file inside the plugin's top-level directory, all plugins must have an index.js file that serves as the primary entry point</p> <p>One of the functions contained inside this file must be exported via <code>module.exports</code>, using the following conventions:</p> <p>Export plugins that use synchronous code:</p> <pre><code>function myFilter(author) {\nreturn \"Hello ${author}!\";\n};\nmodule.exports = myFilter;\n</code></pre>"},{"location":"plugins-for-developers/#define-a-new-asynchronous-plugin-async","title":"Define a New Asynchronous Plugin (async)","text":"<p>When using async JavaScript in your plugin, you need two things:</p> <ul> <li>A primary async function that returns a <code>callback()</code> containing any errors as the first argument and the result of the filter as the second.</li> <li>A <code>module.exports</code> statement that includes the properties <code>async: true</code> and <code>filter: &lt;filterName&gt;</code> with <code>&lt;filterName&gt;</code> matching the primary function that's being exported.</li> </ul> <pre><code>const myFilter = async (author, callback) =&gt; {\nconst message = { text: \"Hello ${author}!\" };\nconst error = null;\nreturn callback(error, message.text);\n};\nmodule.exports = {\nasync: true,\nfilter: myFilter\n}\n</code></pre> <p>Async Error Handling</p> <p>Errors reported by async plugins are output to the workflow runner logs. E.g. GitHub Actions, GitLab CI, etc.</p> <p>Here's how to invoke the new filter from this example, whether it's synchronous or asynchronous:</p> <pre><code>automations:\nwelcome_author:\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: {{ pr.author | myFilter }}\n</code></pre> <p>15 Minute Time Limit</p> <p>gitStream actions are terminated after 15 minutes, this is a hard limit that can't be extended.</p>"},{"location":"plugins-for-developers/#using-async-plugin-in-conditions","title":"Using Async Plugin in Conditions","text":"<p>Normally, gitStream optimizes plugin execution by rendering plugins only after condition evaluation when all automation rules are decided. This optimization prevents unnecessary plugin calls.</p> <p>However, when using an async plugin in a condition without the <code>immediate: true</code> flag, this optimization causes the plugin to not work properly, and you will see warning messages in the logs.</p> <p>To use an async plugin in a condition, you must annotate the plugin with <code>immediate: true</code>:</p> <pre><code>module.exports = {\nasync: true,\nimmediate: true,\nfilter: myFilter\n}\n</code></pre> <p>The <code>immediate: true</code> flag tells the system not to optimize plugin execution. The downside is that the plugin might be called multiple times during the workflow execution. If your plugin makes API calls, this will result in multiple API requests as well.</p> <pre><code>automations:\nwelcome_author:\nif:\n- {{ \"\" | myFilter }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: hello world!\n</code></pre>"},{"location":"plugins-for-developers/#accept-arguments","title":"Accept Arguments","text":"<p>Filter function plugins can accept any number of arguments. The first argument must be passed to the filter function via a <code>|</code> operator; all subsequent arguments are passed as a set inside parenthesis.</p> <p>Filter function to combine two strings</p> <p>This example accepts two strings and combines them, separating by a space:</p> <pre><code>function combineStrings(str1, str2) {\nreturn str1 + \" \" + str2;\n}\nmodule.exports = combineStrings;\n</code></pre> <p>In the following invocation, \"Hello\" is passed as <code>str1</code> and \"world!\" is passed as <code>str2</code></p> <p><code>{{ \"Hello\" | combineStrings(\"world!\") }}</code></p>"},{"location":"plugins-for-developers/#tips-for-develpers","title":"Tips for develpers","text":"<ol> <li> <p>Debugging with console.log()</p> <p>Any data passed to <code>console.log()</code> will be displayed in your workflow runner logs, such as GitHub Actions, GitLab CI, etc.</p> </li> <li> <p>Context Variable Insight</p> <p>Utilize the gitStream playground to see how the context variable appears in a real Pull Request (PR). Inspect the PR Context Variables at the bottom of the screen .</p> </li> <li> <p>Local Execution</p> <ul> <li> <p>Run the plugin locally for testing, for example: Running <code>index.js</code> with Node.js.   <pre><code>module.exports = (text) =&gt; {\nreturn text.replaceAll('banana', '\ud83c\udf4c');\n};\nconst banana = require('./index.js');\nconsole.assert(banana(\"hello banana!\") === 'hello \ud83c\udf4c!', `banana(\"hello banana!\") === 'hello \ud83c\udf4c!' but got ${banana(\"hello banana!\")}`);\n</code></pre></p> </li> <li> <p>Execute with:   <pre><code>$ node index.js\n</code></pre></p> </li> </ul> </li> <li> <p>Handling Escaped Characters</p> <p>When returning strings with escaped characters, add an extra slash as it will be parsed by the template engine. For example, to return the following text <code>\"first line \\n next line\"</code> you should return this from the plugin <code>\"first line \\\\n next line\"</code>.</p> </li> </ol> <p>Check out the community plugin library.</p> <p>Check out the filter function plugin library to explore plugins created by the LinearB community.</p>"},{"location":"plugins-for-developers/#contribute-to-the-community-plugin-library","title":"Contribute to the Community Plugin Library","text":"<p>LinearB maintains a collection of community-contributed gitStream plugins. Here are the instructions for publishing a plugin as part of this library.</p> <p>Create a directory for your plugin inside one of the subdirectories in <code>plugins/filters</code>. The name of the directory must match the name of the exported JavaScript function. Then ensure you have all of the required files and JSDoc content outlined below.</p> <p>Here is an example of a well-designed gitStream plugin.</p> <p>Required Files:</p> <ul> <li>index.js - The entry point for your plugin. This should have a main function that is exported via <code>module.exports</code> that is documented according to the JSDoc requirements outlined below.</li> <li>README.md - Use this template.</li> <li>reference.md - This file must be auto-generated by <code>jsdoc2md</code>, see the instructions below.</li> <li>plugin_name.cm - A gitStream CM example that uses the plugin.</li> <li>LICENSE - The full text of the open source license the code is provided under.</li> </ul> <p>Required JSDoc tags:</p> <ul> <li><code>@module</code> - This must match the name of the exported JavaScript function.</li> <li><code>@description</code> - A 1-2 line description that wholistically describes the functionality of the plugin.</li> <li><code>@param</code> - There should be one <code>@param</code> tag for each argument the plugin accepts, with indicated types. Indicate which parameter is the default input parameter with the name \"Input.\"</li> <li><code>@returns</code> - Provide the type and a short description.</li> <li><code>@example</code> - Simple examples that show how to invoke the plugin.</li> <li><code>@license</code> - The name of the lincense contained in the LICENSE file.</li> </ul> <p>Here is an example of properly formatted JSDoc content:</p> <pre><code>/**\n * @module isFlaggedUser\n * @description Returns true if the username that is passed to this function is specified in a predefined list of users.\n * This is useful if you want gitStream automations to run only for specified users.\n * @param {string} Input - The GitHub username to check.\n * @returns {boolean} Returns true if the user is specified in the flaggedUsers list, otherwise false.\n * @example {{ pr.author | isFlaggedUser }}\n * @license MIT\n**/\n</code></pre> <p>How to Generate Plugin Reference Markdown</p> <p>You can use jsdoc2md to convert the JSDoc content of your plugin to markdown using templates we've provided. First install jsdoc2md:</p> <p><code>npm install -g jsdoc-to-markdown</code></p> <p>Then, invoke the following command from inside your plugin directory:</p> <pre><code>jsdoc2md --partial ../../../docs/snippets/partials/body.hbs --partial ../../../docs/snippets/partials/sig-name.hbs --files index.js &gt; reference.md\n</code></pre> <p>This should output a reference.md file that contains properly formatted markdown based on the JSDoc contents of your plugin.</p>"},{"location":"plugins/","title":"Filter Function Plugins","text":"<p>gitStream enables you to build JavaScript plugins to extend functionality for more advanced data processing and pulling data from external APIs. Use gitStream plugins to seamlessly create and integrate custom filters and other capabilities within your gitStream automations.</p> <p>Example: isFlaggedUser</p> <p>Here is an example of a filter function plugin that evaluates a username input against a list of specified usernames and returns true if the user is in the list.</p> <p><pre><code>const flaggedUsers = [\"user1\", \"user2\"];\nfunction isFlaggedUser(username) {\nif (flaggedUsers.includes(username)) {\nreturn true;\n} else {\nreturn false;\n}\n};\nmodule.exports = isFlaggedUser;\n</code></pre> This creates a new <code>isFlaggedUser</code> filter function that can be invoked inside gitStream CM files. For example, you can use this to enable gitStream automations to trigger only for specific PR authors.</p> <pre><code>automations:\ndetect_flagged_user:\nif:\n- {{ pr.author | isFlaggedUser }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: {{ pr.author }} is a gitStream user.\n</code></pre>"},{"location":"plugins/#installation","title":"Installation","text":"<p>gitStream plugins can be installed for an entire git organization or for individual repos.</p> <p>Repository Plugins Take Precedence</p> <p>If two filter function plugins have the same name, the repository-level plugin overrides the organization-level plugin.</p> Org-LevelRepo-Level <p>To use a filter function plugin in all your repositories, place it inside your <code>cm</code> repository in the following location:</p> <p><code>plugins/filters/&lt;filterName&gt;/index.js</code></p> <p>Success</p> <p>Once installed, you should have a directory structure that looks like this: <pre><code>.\n\u251c\u2500 gitstream.cm\n\u2514\u2500 plugins/filters/&lt;filterName&gt;\n   \u2514\u2500 index.js\n</code></pre></p> <p>To use a filter function plugin for a single repository, place it inside the repo in the following location:</p> <p><code>.cm/plugins/filters/&lt;filterName&gt;/index.js</code></p> <p>Success</p> <p>Once installed, you should have a directory structure that looks like this: <pre><code>.\n\u251c\u2500 .cm/\n\u2502  \u251c\u2500 gitstream.cm\n\u2502  \u2514\u2500 plugins/filters/&lt;filterName&gt;\n\u2502     \u2514\u2500 index.js\n</code></pre></p> <p>gitStream Community Plugins</p> <p>We maintain an official list of community-contributed gitStream plugins. Click here to explore plugin examples.</p>"},{"location":"plugins/#usage","title":"Usage","text":"<p>Once installed, you can call your new plugins inside CM files using the same conventions as the built in filter functions. Filters are called with a pipe operator (<code>|</code>) and can take arguments. The first argument must be declared before the pipe, and all remaining arguments are passed as a set inside parenthesis. For example: <pre><code>{{ \"Hello\" | plugin(\" world!\") }}\n</code></pre> If the filter does not expect any arguments, you can invoke it by passing an empty string: <pre><code>{{ \"\" | myFilter }}\n</code></pre></p>"},{"location":"quick-start/","title":"Write Your First gitStream Automation","text":"<p>This article provides Continuous Merge (CM) examples to help you start customizing gitStream automations to meet the needs of your team.</p>"},{"location":"quick-start/#approve-simple-changes","title":"Approve Simple Changes","text":"<p>Changes to documentation, testing, and code formatting are often safe enough that there is little to no risk in letting an individual contributor merge those changes without needing to distract other people on their team to meet organization-wide requirements for multiple reviews on PRs. A good first Continuous Merge (CM) automation to implement is one that labels and approves changes to resources that could be considered safe changes.</p> <p>This example uses the filter functions <code>allDocs</code>, <code>allTests</code>, <code>isFormattingChange</code> and <code>match</code> to detect changes that should be safe to merge with minimal review. It then uses the <code>add-label</code> automation action to apply a safe-changes label and the <code>approve</code> automation action to provide an approval review.</p> <p>Label and Approve Simple Changes</p> <pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nsafe_changes:\nif:\n- {{ is.docs or is.tests or is.asset or is.formatting }}\nrun: - action: add-label@v1\nargs:\nlabel: 'safe-changes'\n- action: approve@v1\nis:\ndocs: {{ files | allDocs }}\ntests: {{ files | allTests }}\nasset: {{ files | match(regex=r/\\.(png|svg|gif|css)$/) | every }}\nformatting: {{ source.diff.files | isFormattingChange }}\n</code></pre> <p>Test Your Automation in Dry Run Mode</p> <p>gitStream includes a dry-run mode that lets you test your automations on your desired repo without pushing significant code, documentation, or other changes to the repo. </p> <p>Learn more in our guide: How to Test Your Automations.</p>"},{"location":"quick-start/#find-reviewers-for-common-changes","title":"Find Reviewers for Common Changes","text":"<p>Selecting the right reviewer for your PR is crucial to ensure that your changes are thoroughly reviewed and that any issues are identified and addressed before they are merged into the main codebase. </p> <p>This example uses the <code>codeExperts</code> filter function to identify the most qualified contributors based on their activity in the repo. It then assigns those individuals as reviewers on the PR with the <code>add-reviewers</code> automation action and posts a comment that lists the code experts via the <code>explain-code-experts</code> automation action.</p> <p>Identify and Assign Code Experts for Reviews</p> <p>This example uses the codeExperts filter function to identify the people who have the most expertise in the relevant code, assigns them as reviewers, and provides a comment that explains how those people were selected.</p> <pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nassign_code_experts:\n# Triggered when someone applies a suggest-reviewer label to a PR.\nif: - {{ pr.labels | match(term='suggest-reviewer') | some }}\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: {{ repo | codeExperts(gt=10) }}\n- action: explain-code-experts@v1 args:\ngt: 10 </code></pre>"},{"location":"quick-start/#enforce-review-policies-for-critical-changes","title":"Enforce Review Policies for Critical Changes","text":"<p>Complex and sensitive PRs often require more nuanced and complex review processes that bring in outside teams of experts to review code changes. gitStream makes it easy to set up custom review policies to keep teams aligned across your organization. This example contains two automations that implement custom review policies for specific parts of a codebase. </p> <p>First, the <code>security_review</code> automation uses the <code>require-reviewers</code> automation action to add the security team from the git organization as reviewers on PRs that affect the <code>auth</code> directory of the repo. This action accepts a <code>reviewers:</code> argument that contains a list of teams or individual users; you will need to change this value to match your organization and users.</p> <p>Second, the <code>double_review</code> automation forces any changes to the <code>agent</code> directory to require a review from two people using the <code>set-required-approvals</code> automation action.</p> <p>Enforce Review Policies</p> <pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nsecurity_review:\nif:\n- {{ files | match(regex=r/auth\\//) | some }}\nrun:\n- action: require-reviewers@v1\nargs:\nreviewers: [my_organization/security]\n- action: add-reviewers@v1\nargs:\nreviewers: [my_organization/security]\ndouble_review:\nif:\n- {{ files | match(regex=r/agent\\//) | some }}\nrun:\n- action: set-required-approvals@v1\nargs:\napprovals: 2\n</code></pre>"},{"location":"quick-start/#next-step","title":"Next Step","text":"<p>Take a Look at the Quickstart Examples</p> <p>You're ready to browse our CM example library to build more automations for your repo. We have examples that help provide context to PRs with labels, assign reviewers based on custom criteria, manage security requirements, and more.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#i-cant-see-any-action-running","title":"I can't see any action running","text":""},{"location":"troubleshooting/#did-you-install-gitstream-in-your-repo","title":"Did you install gitStream in your repo?","text":"<p>Check that you see gitStream app on repository's Settings &gt; GitHub apps:</p> <p> In case you don't see it, visit the marketplace and install it for free: https://github.com/marketplace/gitstream-by-linearb</p>"},{"location":"troubleshooting/#did-you-set-the-workflow-files-correctly","title":"Did you set the workflow files correctly?","text":"<p>Check you have placed these two files in your repository with these exact names:</p> <ol> <li><code>gitstream.cm</code> in the <code>cm</code> repo, (for org level installs), or <code>.cm/gitstream.cm</code> on all other repositories</li> <li><code>.github/workflows/gitstream.yml</code></li> </ol> <p>These files must be committed to the repository default branch (usually <code>master</code> or <code>main</code>). Notice that the action will not run until these files are found on the default branch.</p> <p>Check that you see \"gitStream workflow automation\" in the Action section in your repository:</p> <p></p> <p>Next, if you see a failed action, check out the details:</p> <p></p>"},{"location":"troubleshooting/#does-your-organization-allows-3rd-party-actions","title":"Does your organization allows 3rd party actions?","text":"<p>Some organizations limit which actions can run, in that case, in the repository settings, you should enable it:</p> <p></p> <p>Also, add <pre><code>linear-b/gitstream-github-action@v2,linear-b/gitstream-github-action@v2-lite,*/*/.github/workflows/gitstream.yml*\n</code></pre> to the Allow specified actions and reusable workflows list, if it is shown. </p>"},{"location":"troubleshooting/#adding-new-repo-make-sure-to-enable-gitstream-for-it","title":"Adding new repo? Make sure to enable gitStream for it","text":"<ol> <li>Go to https://github.com/apps/gitstream-cm and then</li> <li>click the <code>Configure</code> button</li> <li>If you see organization selection, choose the relevant org</li> <li>Scroll down to <code>Repository access</code></li> <li>Make sure the repo you want is covered, i.e. either <code>All repositories</code> is checked or the repo is checked in the <code>Only select repositories</code> list</li> </ol>"},{"location":"troubleshooting/#using-org-level-did-you-enable-gitstream-for-your-cm-repo","title":"Using org level? Did you enable gitStream for your <code>cm</code> repo","text":"<p>Make sure you have added the <code>cm</code> repo to the repos gitStream should run on </p>"},{"location":"troubleshooting/#are-you-using-the-default-runners-along-with-the-ip-allow-list-feature-on-github","title":"Are you using the default runners along with the \"IP allow list\" feature on GitHub?","text":"<p>According to GitHub, in order to use GitHub actions with the allow list, you must use self-hosted runners or GitHub-hosted larger runners with static IP address ranges and add their IP to the allow list.</p> <p>When using GitHub's default runners, you will encounter the following error: \"The repository owner has an IP allow list enabled, and [IP] is not permitted to access this repository,\" which indicates that GitHub is blocking the action. You can verify if the IP is part of GitHub's CIDR ranges by using the following list</p>"},{"location":"troubleshooting/#is-the-pr-in-draft-mode","title":"Is the PR in Draft mode?","text":"<p>gitStream automations won't trigger for PRs that are in Draft mode.</p>"},{"location":"troubleshooting/#i-see-gitstream-workflow-file-not-found-error","title":"I see 'gitStream workflow file not found' error","text":"<p>This error indicates that gitStream is unable to locate the file <code>.github/workflows/gitstream.yml</code>. The tool first searches for this file in the <code>cm</code> repository and then in the PR's repository. If the CI file is not found, this error message is displayed. To resolve this issue, ensure that your setup is correct and that the specified file exists in your repository.</p>"},{"location":"troubleshooting/#i-have-rules-that-should-have-blocked-merge-but-the-pr-can-be-merged-still","title":"I have rules that should have blocked merge, but the PR can be merged still","text":"<p>For example, when using the <code>set-required-approvals</code> action, gitStream can ensure the PR got enough approvals before it can be merged. gitStream does that by running as a check and marking the check conclusion as failed. In order for the PR to be blocked, gitStream should be set as a required check in the repo: instructions here.</p> <p></p>"},{"location":"troubleshooting/#i-cant-set-gitstream-as-required-check","title":"I can't set gitStream as required check","text":"<p>In order for gitStream to be listed as a required check, it needs to be triggered at least once in that repo. First create a new PR so gitStream is triggered.</p> <p>Check it under repository's Settings &gt; Branches:</p> <p></p> <p></p>"},{"location":"troubleshooting/#i-dont-want-gitstream-to-run-on-prs-that-was-generated-by-a-bot","title":"I don't want gitStream to run on PRs that was generated by a bot","text":"<p>When using repository level rules, you can edit the <code>.github/workflows/gitstream.yml</code> and uncomment the <code>if</code> line, you can edit and replace the bot name with the bot name you want to ignore (<code>dependabot[bot]</code> in the example below).</p> <p>Note</p> <p>This will not work for org level rules</p> .github/workflows/gitstream.yml<pre><code>jobs:\ngitStream:\ntimeout-minutes: 5\n# uncomment this condition, if you don't want any automation on dependabot PRs\nif: github.actor != 'dependabot[bot]'\nruns-on: ubuntu-latest\nname: gitStream workflow automation\nsteps:\n- name: Evaluate Rules\nuses: linear-b/gitstream-github-action@v2\n</code></pre>"},{"location":"troubleshooting/#pr-author-usernames-containing-linearb-prevent-gitstream-from-running","title":"PR author usernames containing \"linearb\" prevent gitStream from running","text":"<p>If a PR is created by a user whose GitHub username contains the substring \"linearb\" (case-insensitive), gitStream will not run on that PR. This is a built-in restriction to prevent gitStream from processing its own internal automated PRs.</p>"},{"location":"troubleshooting/#gitstream-fails-and-i-dont-understand-why","title":"gitStream fails and I don't understand why","text":"<p>gitStream check run can fail from different reasons, and these are shown in the check result.</p>"},{"location":"troubleshooting/#missing-workflow-file","title":"Missing workflow file","text":"<p>When it says <code>gitStream.cm Skipped \u2014 gitStream workflow file not found</code>, it means that: - The GitHub action was not found, check again that you have this file in your repository root: <code>.github/workflows/gitstream.yml</code>, see instructions on GitHub installation - When using org level, then the required <code>cm</code> repo may not be in the GitHub application allowed repositories list. See instructions above: enable gitStream for your <code>cm</code> repo</p>"},{"location":"troubleshooting/#syntax-error-in-the-cm-files","title":"Syntax error in the cm files","text":"<p>Clicking the <code>Details</code> button will show more information and context.</p> <p></p> <p>You can add this automation to see details on context variable.</p>"},{"location":"troubleshooting/#gitstream-fails-when-using-template-strings-with-special-characters-eg-colon","title":"gitStream fails when using template strings with special characters (e.g., colon ':')","text":"<p>If a template string (e.g., pull request title, description, or other context variables) contains special characters such as a colon (<code>:</code>), gitStream might fail with a YAML parsing error due to invalid syntax.</p> <p>To resolve this issue, ensure you properly escape special characters by using Nunjucks multiline strings. For example:</p> <pre><code>comment: |\n{{ pr.title }}\n</code></pre>"},{"location":"troubleshooting/#gitlab-self-managed-in-restricted-networks","title":"GitLab self-managed in restricted networks","text":"<p>If gitStream is installed in GitLab and nothing happens (or the CI job starts but fails in different places), the issue is often related to network allowlists, TLS configuration, or runner policies. Use the checkpoints below to narrow it down.</p>"},{"location":"troubleshooting/#gitstream-cant-reach-gitlab-timeouts-403s-or-no-webhook-follow-up","title":"gitStream can't reach GitLab (timeouts, 403s, or no webhook follow-up)","text":"<p>Make sure your GitLab allowlist includes the LinearB/gitStream service IPs and your runner IPs. See the allowlist notes in GitLab installation.</p>"},{"location":"troubleshooting/#tlscertificate-mismatch-when-gitlab-is-exposed-by-ip","title":"TLS/certificate mismatch when GitLab is exposed by IP","text":"<p>You may see an error like: <pre><code>Error: Hostname/IP does not match certificate's altnames\n</code></pre> This usually means the GitLab URL is an IP address, but the TLS certificate was issued for a hostname. Use a hostname that matches the certificate, or reissue the certificate with the IP in its SANs. If you run gitStream in a managed environment, contact support to align SSL validation with the host you expose.</p>"},{"location":"troubleshooting/#pipeline-starts-but-fails-pulling-images-no-logs-or-timeouts","title":"Pipeline starts but fails pulling images (no logs or timeouts)","text":"<p>If your runners can\u2019t reach DockerHub, mirror the required images in your private registry (for example <code>docker:latest</code>, <code>docker:dind</code>, <code>gitstream/rules-engine:latest</code>) and update your <code>.gitlab-ci.yml</code> to pull from that registry. See GitLab installation for the registry customization option.</p>"},{"location":"troubleshooting/#pipeline-stuck-on-waiting-for-pod-containersnotready","title":"Pipeline stuck on \"Waiting for pod ... ContainersNotReady\"","text":"<p>Kubernetes/GitLab runners often disallow privileged mode, which Docker-in-Docker requires. Either allow privileged DIND on the runner or run gitStream with a container runtime your runner allows (for example Podman) and remove the DIND dependency from the pipeline.</p>"},{"location":"troubleshooting/#clone-url-is-malformed-eg-ssh-or-unexpected-port","title":"Clone URL is malformed (e.g., <code>ssh///</code> or unexpected port)","text":"<p>If your org injects SSH URLs or a custom port into <code>repoUrl</code>/<code>cmUrl</code>, normalize the URL in your CI script before cloning (remove the SSH prefix/port and enforce the correct https URL).</p>"},{"location":"troubleshooting/#docker-runs-but-fails-to-write-into-the-mounted-repo","title":"Docker runs but fails to write into the mounted repo","text":"<p>If the runner checks out files as <code>root</code> and the container runs as a non-root user, update ownership/permissions on the checkout directory before running the container, or run the container as the same user that owns the files.</p>"},{"location":"troubleshooting/#api-calls-succeed-locally-but-fail-to-post-mr-updates","title":"API calls succeed locally but fail to post MR updates","text":"<p>If the <code>client_payload</code> (or derived repo URL) points to an external IP/host not reachable from your internal network, replace the host in <code>client_payload</code> with the internal GitLab endpoint, or align GitLab's external URL with the hostname reachable by your runners.</p>"},{"location":"troubleshooting/#github-timeout-issues-with-large-repositories","title":"GitHub timeout issues with large repositories","text":"<p>If you're experiencing timeout issues during GitHub Actions execution, particularly with large repositories or monorepos, this is typically caused by the time required to clone the entire repository history.</p> <p>You can resolve this by using the lite version of the gitStream GitHub Action, which performs a shallow clone to reduce execution time:</p> <pre><code>jobs:\ngitStream:\ntimeout-minutes: 15\nruns-on: ubuntu-latest\nname: gitStream workflow automation\nsteps:\n- name: Evaluate Rules\nuses: linear-b/gitstream-github-action@v2-lite\nid: rules-engine\n</code></pre> <p>Important limitations of the lite version: - Automations that rely on Git history (such as <code>code-experts</code>) may not work properly due to the shallow clone - Historical data analysis features will be limited - Some context variables that depend on full Git history may return incomplete results</p> <p>  Download gitstream.yml (lite version) </p>"},{"location":"troubleshooting/#how-can-i-debug-expressions-and-see-their-content","title":"How can I debug expressions and see their content?","text":"<p>You can dump any context value to the PR comment. For example, to see the list of changed files, use:</p> <pre><code>automations:\nshow_changed_files:\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nFILES DUMP {{ files | dump | safe }}\nJS FILES DUMP {{ files | filter(regex=r/\\.js$/) | dump | safe }}\n</code></pre> <p>  Download and add to your repo .cm directory </p>"},{"location":"troubleshooting/#gitstream-fails-with-syntax-error-after-adding-new-rules","title":"gitStream fails with syntax error after adding new rules","text":"<p>IntelliJ IDEA has automatic code styling for YAML that can break the <code>.cm</code> syntax, check the following Settings/Preferences | Editor | Code Style | YAML --&gt; Spaces | Code braces and make sure it is unchecked.</p> <p></p> <p>VS Code YAML plugin by Red Hat extension <code>[vscode-yaml](https://github.com/redhat-developer/vscode-yaml)</code> has automatic code styling for YAML that can break the <code>.cm</code> syntax, make sure you disable <code>bracketSpacing</code> <pre><code>{\n\"yaml.format.bracketSpacing\": false,\n}\n</code></pre></p>"},{"location":"troubleshooting/#not-here","title":"Not here?","text":"<p>Create a new issue in the project's issues</p>"},{"location":"user-commands/","title":"User Commands","text":"<p>User commands allow you to trigger specific gitStream actions manually by adding comments to pull requests. These commands provide on-demand execution of automation actions without requiring changes to your <code>.cm</code> configuration files.</p> <p>GitHub Only &amp; v2 Action Required</p> <p>User commands are only supported on GitHub and require the <code>linear-b/gitstream-github-action@v2</code>. This feature is not available on GitLab or Bitbucket.</p>"},{"location":"user-commands/#overview","title":"Overview","text":"<p>gitStream supports comment-triggered actions that allow you to execute specific automations on-demand. Commands are only processed when new comments are added, not when existing comments are edited.</p> <p>gitStream provides visual feedback through emoji reactions on command comments.  is added when a command is recognized and processing begins and  is added when the command has been successfully executed.</p>"},{"location":"user-commands/#available-commands","title":"Available Commands","text":"Command Platform Description Action <code>/gs review</code> Run an AI-powered code review on this PR Executes <code>code-review@v1</code> once on the current PR <code>/gs desc</code> Generate a description of the changes in this PR Executes <code>describe-changes@v1</code> once on the current PR with <code>concat_mode: append</code> <code>/gs etr</code> Add estimated time to review label Adds a label with the estimated review time based on the PR changes <code>/gs experts</code> Add a comment with codeExperts suggestion for current changes Executes <code>explain-code-experts@v1</code> once on the current PR <code>/gs help</code> Show help message with available commands Displays a comment with the list of all available gitStream commands"},{"location":"automations/automation-library/","title":"gitStream Automation Library","text":"<p>This library of gitStream examples is meant to serve as a starting point for your automation. We encourage you to customize them for your project and organization.</p> <p>How to use these examples.</p> <p>These examples are all complete gitStream configuration files that you can download directly via the buttons below the examples and upload to the <code>.cm</code> directory of your repo. Alternatively, you can copy and paste the individual automations, but make sure you include all required declarations and any related custom expressions from the configurations to ensure they work properly.</p>"},{"location":"automations/automation-library/#most-popular-automations","title":"Most Popular Automations","text":"<ul> <li>Approve safe changes - Approve documentation, formatting changes, and tests.</li> <li>Provide estimated time to review - Label all PRs with an estimated number of minutes it would take someone to review.</li> <li>Explain Code Experts - Post a comment that recommends reviewers based on their expertise. </li> <li>Review sensitive files - Define a custom list of files and directories that trigger additional reviews.</li> <li>Additional review for large PRs - Require additional reviewers for complex PRs.</li> </ul>"},{"location":"automations/automation-library/#improve-pr-efficiency","title":"Improve PR Efficiency","text":""},{"location":"automations/automation-library/#auto-approve-merges","title":"Auto-Approve Merges","text":"<ul> <li>Approve tests - Label and approve PRs that only include tests.</li> <li>Approve Tiny Changes - Approve single-line changes to a single file.</li> <li>Approve team by directory - Approve PRs from specific teams to specified directories and files.</li> </ul>"},{"location":"automations/automation-library/#add-pr-context-with-labels-and-comments","title":"Add PR Context With Labels and Comments","text":"<ul> <li>Label PRs without tests - Apply a <code>missing-tests</code> label to any PRs that lack updates to tests.</li> <li>Label percent new code - Post a comment that indicates what percentage of the PR contains new code.</li> <li>Label deleted files - Label PRs that delete files.</li> <li>Label missing project tracker - Flag PRs that are missing a reference to an associated project tracking resource.</li> <li>Automatic project tracking links - Automatically post PR comments that link to the associated project tracking resource (Jira, Shortcut, Azure Boards, and more).</li> <li>Summarize PR contents by language - Post a comment that breaks down code changes by the programming languages contained in the PR.</li> <li>PR Checklist - Post a comment with a checklist giving more context about the PR to reviewers</li> </ul>"},{"location":"automations/automation-library/#improve-pr-quality","title":"Improve PR Quality","text":""},{"location":"automations/automation-library/#merge-routing","title":"Merge Routing","text":"<ul> <li>Assign code experts - Identify the best experts for a PR and assign them to review.</li> <li>Assign reviewers by directory - Automatically assign code reviewers based on directory structure.</li> <li>Assign reviewers for knowledge share - Automatically assign code reviewers based on contributions between specified thresholds.</li> <li>Change missing Lambda field - Request changes if a PR creates a new Lambda function that lacks a required field.</li> <li>Close wrong team by directory - Close PRs to a specified directory if the PR author is not on an approved team.</li> </ul>"},{"location":"automations/automation-library/#quality-checks","title":"Quality Checks","text":"<ul> <li>Enforce Semantic PR Titles - Enforce PR naming conventions.</li> <li>Enforce Changelog Updates - Require changelog updates for PRs that meet specific criteria.</li> <li>Request screenshot - Request a screenshot in the PR description if none exists.</li> <li>Welcome newcomer - Post a welcome message when someone makes their first PR to a repo, and provide context to help them know what's next.</li> <li>Remove TODO comments - Detect TODO comments in PRs and ask the author to remove or fix them.</li> </ul>"},{"location":"automations/automation-library/#security-and-policy-compliance","title":"Security and Policy Compliance","text":"<p>These examples help you follow your team's security best practices.</p> <ul> <li>Change deprecated components - Request changes when a PR includes one or more deprecated components.</li> <li>Enforce copyright headers - Enforce the use of copyright headers when publishing open source code.</li> </ul>"},{"location":"automations/automation-library/#integrations","title":"Integrations","text":"<p> AI Assistance</p> <p>  LinearB</p> <p> LinearB AI</p>"},{"location":"automations/automation-library/#github-gitlab","title":"GitHub / GitLab","text":"<p> GitHub Actions</p> <p> PR Labels</p> <p> Branch Management</p> <p> PR Reviews</p>"},{"location":"automations/automation-library/#ai-tools","title":"AI Tools","text":"<p> GitHub Copilot</p> <p> Cursor</p> <p> Amazon Q</p> <p> Claude Code</p> <p> Windsurf</p>"},{"location":"automations/automation-library/#security-compliance","title":"Security &amp; Compliance","text":"<p>  Orca</p> <p> SonarCloud</p> <p> Dependabot</p> <p> Jit</p> <p> Renovate</p> <p> Snyk</p> <p> SOC 2</p>"},{"location":"automations/automation-library/#project-management","title":"Project Management","text":"<p> Jira</p> <p> Asana</p> <p> Shortcut</p> <p> Azure Boards</p>"},{"location":"automations/automation-library/#chat-communications","title":"Chat &amp; Communications","text":"<p> Slack</p> <p> Microsoft Teams</p>"},{"location":"automations/automation-library/#feature-flags","title":"Feature Flags","text":"<p>DevCycle</p> <p>Launch Darkly</p> <p>Flagsmith</p> <p>Unleash</p> <p>Flagr</p>"},{"location":"automations/automation-library/#languages","title":"Languages","text":"<p> JavaScript</p> <p> Go</p> <p> Python</p> <p> Java</p> <p> Ruby</p> <p> HTML/CSS</p> <p> Rust</p>"},{"location":"automations/automation-library/#documentation","title":"Documentation","text":"<p> Swimm</p> <p> Javadoc</p> <p> JSDoc</p> <p> RDoc</p> <p> Godoc</p>"},{"location":"automations/automation-library/#other","title":"Other","text":"<p> Terraform</p> <p> Zapier</p>"},{"location":"automations/automation-library/#utilities","title":"Utilities","text":"<p>These examples provide useful components to use in other automations. These aren't intended to be used on their own; instead, they act as a reference point for improving other automations.</p> <ul> <li>Colors custom expression - A custom expression that implements all of GitHub's default label colors in a custom expression.</li> <li>CM File Header - A header to copy/paste to the top of your CM files to help yourself and others understand the purpose of the file.</li> </ul>"},{"location":"automations/automation-library/#contribute-your-idea","title":"Contribute Your Idea","text":"<p>Do you have a great idea for an automation that should be included in this library?</p> <p>Submit your configuration on GitHub. We'll recognize your contribution publicly (if you want) and might even send you some special swag for your contribution.</p>"},{"location":"automations/additional-review-for-large-pr/","title":"Additional Review for Large PRs","text":"<p>Require 2 reviewers for PRs that have more than 10 changed files in the src directory and the estimated time to review is 30 or more minutes.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>There are 10 or more changed files</li> <li>The estimated time to review is 30 minutes or more.</li> <li>One or more of the changed files is inside the <code>src</code> directory.</li> </ul> <p>Automation Actions:</p> <ul> <li>Require a minumim of 2 reviews.</li> <li>Post a comment that explains this is considered a large change that requires 2 reviews.</li> </ul> <p>Additional Review for Large PRs</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nadditional_review_for_large_pr:\nif:\n- {{ branch | estimatedReviewTime &gt;= 30 }}\n- {{ files | length &gt;= 10 }}\n- {{ files | match(regex=r/src\\//) | some }}\nrun:\n- action: set-required-approvals@v1\nargs:\napprovals: 2\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR is a large change and requires 2 reviews.\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/additional-review-for-large-pr/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Assign or suggest reviewers based on level of code expertise for the code changed in a PR.</li> <li>Assign reviewers based on modified directories and files</li> <li>Assign reviewers to share knowledge based on pre-determined criteria</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/approve-safe-changes/","title":"Approve Safe Changes","text":"<p>Automatically approve PRs that change docs, tests, and other safe assets.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR only contains documentation, images, tests, or formatting changes.</li> </ul> <p>Automation Actions:</p> <ul> <li>Add a <code>safe-change</code> label</li> <li>Approve the PR</li> <li>Post a comment that explains that this is a safe change</li> </ul> <p>Approve Safe Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nsafe_changes:\n# Triggered for any changes that only affect formatting, documentation, tests, or images\nif:\n- {{ is.formatting or is.docs or is.tests or is.image }}\n# Apply a safe change label, approve the PR and explain why in a comment.\nrun: - action: add-label@v1\nargs:\nlabel: 'safe-change'\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR is considered a safe change and has been automatically approved.\n# These custom expressions are used in the safe_changes automation\nis:\nformatting: {{ source.diff.files | isFormattingChange }}\ndocs: {{ files | allDocs }}\ntests: {{ files | allTests }}\nimage: {{ files | allImages }}\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/approve-safe-changes/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Approve low-risk PRs from trusted teams.</li> <li>Approve Python or JavaScript formatting changes.</li> <li>Approve Tiny Changes</li> <li>Approve JSDoc or Javadoc changes.</li> <li>Approve and Merge Dependabot PRs</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/approve-swimm/","title":"Index","text":"<p>This file has moved: /docs/automations/integrations/swimm/approve-swimm</p>"},{"location":"automations/approve-team-by-directory/","title":"Approve Trusted Team","text":"<p>Automatically approve low-risk PRs from trusted teams.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>All changed files are inside the <code>docs</code> directory</li> <li>The PR author is on the <code>tech-writers</code> team.</li> </ul> <p>Automation Actions:</p> <ul> <li>Approve the PR</li> <li>Post a comment that explains the approval.</li> </ul> <p>Approve Expert Team</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_team_by_directory:\n# Triggered for PRs that only include changes to files inside the docs directory,\n# and that are authored by someone on the tech-writers team.\nif:\n- {{ files | match(regex=r/docs\\//) | every }}\n- {{ pr.author_teams | match(term='tech-writers') }}\nrun: - action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nDocs changes from the tech-writers team are automatically approved.\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/approve-team-by-directory/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Automatically approve changes to docs, tests, and other safe assets.</li> <li>Approve Python or JavaScript formatting changes.</li> <li>Approve Tiny Changes</li> <li>Approve JSDoc or Javadoc changes.</li> <li>Approve and Merge Dependabot PRs</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/approve-tests/","title":"Approve test changes","text":"<p>Label and approve PRs that only include tests, and post an explanation comment.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR only contains changes to tests</li> </ul> <p>Automation Actions:</p> <ul> <li>Add a tests-only label</li> <li>Approve the PR</li> <li>Post a comment that explains why the PR was approved.</li> </ul> <p>Approve Tests</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_tests:\nif:\n# Triggered for PRs that only include changes to tests\n- {{ files | allTests }}\nrun: - action: add-label@v1\nargs:\nlabel: 'tests-only'\n- action: add-comment@v1\nargs:\ncomment: |\nThis merge has been automatically approved because it only contains changes to tests.\n- action: approve@v1\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/approve-tests/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Automatically approve changes to docs, tests, and other safe assets.</li> <li>Approve low-risk PRs from trusted teams.</li> <li>Approve Python or JavaScript formatting changes.</li> <li>Approve Tiny Changes</li> <li>Approve JSDoc or Javadoc changes.</li> <li>Approve and Merge Dependabot PRs</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/approve-tiny-changes/","title":"Approve Tiny Changes","text":"<p>Approve single-line changes to a single file.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>If the PR contains a one-line change to a single file.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>single-line</code> label.</li> <li>Approve the PR.</li> <li>Post a comment explaining why the PR was approved.</li> </ul> <p>name</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_tiny_change:\n# Triggered for PRs that contain one file and one line.\nif:\n- {{ is.one_file and is.one_line }}\nrun:\n- action: add-label@v1\nargs:\nlabel: 'single-line'\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR has been approved because it is only a single line\nchanges:\n# Sum all the lines added in the PR\nadditions: {{ branch.diff.files_metadata | map(attr='additions') | sum }}\n# Sum all the line removed in the PR\ndeletions: {{ branch.diff.files_metadata | map(attr='deletions') | sum }}\nis:\none_file: {{ files | length == 1 }}\none_line: {{ changes.additions - changes.deletions &lt;= 1 }}\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/approve-tiny-changes/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Automatically approve changes to docs, tests, and other safe assets.</li> <li>Approve low-risk PRs from trusted teams.</li> <li>Approve Python or JavaScript formatting changes.</li> <li>Approve JSDoc or Javadoc changes.</li> <li>Approve and Merge Dependabot PRs</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/assign-reviewers-by-directory/","title":"Assign Reviewers by Directory","text":"<p>Automatically assign code reviewers based on directory structure. Optionally, you can substitue <code>require-reviewers</code> for <code>add-reviewers</code> to make review from the specified teams and individuals mandatory.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains changes to JavaScript files inside the <code>src/ui</code> directory.</li> </ul> <p>Automation Actions:</p> <ul> <li>Add a user named <code>my-teamate</code> and a team named <code>my-organization/ui-team</code> as reviewers. These should be customized to match your organization.</li> <li>Post a comment explaining why these reviewers were assigned.</li> </ul> <p>Assign Reviewers by Directory</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_ui:\n# Triggered for PRs that contain any changes to JavaScript files inside the `src/ui` directory.\nif:\n- {{ files | match(regex=r/src\\/ui\\/.*/) | some}}\n# Add a specified user and team as reviewers.\n# Customize the reviewers to match your organization\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: [my-teamate, my-organization/security]\n- action: add-comment@v1\nargs:\ncomment: |\nThe Security team has automatically been added for review because this PR contains changes to components inside `/src/ui`\n</code></pre>  Download this example as a CM file."},{"location":"automations/assign-reviewers-by-directory/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Assign additional reviewers for large PRs</li> <li>Assign or suggest reviewers based on level of code expertise for the code changed in a PR.</li> <li>Assign reviewers to share knowledge based on pre-determined criteria</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/assign-team-members-as-reviewers/","title":"Assign team members as reviewers","text":"<p>Assign PR reviewer based on the owner team membership.</p> <p>You can also omit the <code>| first</code> filter to assign all teams the owner is member of.</p> <p>name</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nadd_first_team_reviewer:\nif:\n- true\nrun:\n- action: add-reviewers@v1\nargs:\nteam_reviewers: {{ pr.author_teams | first }}\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/assign-team-members-as-reviewers/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Assign additional reviewers for large PRs</li> <li>Assign or suggest reviewers based on level of code expertise for the code changed in a PR.</li> <li>Assign reviewers based on modified directories and files</li> <li>Assign reviewers to share knowledge based on pre-determined criteria</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/change-deprecated-components/","title":"Change Deprecated Components","text":"<p>Request changes when a PR includes one or more deprecated components.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR contains one or more references to functions, methods, or classes that have been designated as deprecated.</li> </ul> <p>Automation Actions:</p> <ul> <li>Add a <code>deprecated-component</code> label to the PR</li> <li>Request changes to the PR and post a comment that explains what deprecated component was included and what the alternative is.</li> </ul> <p>Change Deprecated Components</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n# Request changes when a PR includes deprecated components.\n# This requires the `item` custom expression found at the bottom of this file.\n{% for item in deprecated %}\n# Automation names must be unique, so this adds an iterator index to each instance\nreview_deprecated_component_{{ item.old }}:\n# Triggered when any of the modified files use a deprecated component\nif:\n- {{ source.diff.files | matchDiffLines(regex=item.regex) | some }}\n# Apply a deprecated-component label, request changes, and post a comment with an explanation.\nrun:\n- action: add-label@v1\nargs:\nlabel: 'deprecated-component'\ncolor: '#FF0000'\n- action: request-changes@v1\nargs:\ncomment: |\n`{{ item.old }}` component is deprecated, use `{{ item.new }}` instead\n{% endfor %}\n# These are the deprecated files that are evaluated in catch_deprecated_components\ndeprecated:\n- regex: r/oldAPI/\nold: oldAPI\nnew: newAPI\n- regex: r/anotherOldAPI/\nold: anotherOldAPI\nnew: anotherNewAPI\n</code></pre>  Download this example as a CM file."},{"location":"automations/change-deprecated-components/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Require changelog updates for PRs to specific branches</li> <li>Restrict portions of your code base to authorized teams only.</li> <li>Require changes when PRs include !important tags in CSS files</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/change-missing-lambda-field/","title":"Change Missing Lambda Field","text":"<p>If a PR creates a new Lambda function, but lacks a description field, gitStream will request changes and post a comment that explains why.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains an update to a Lambda function.</li> <li>The affected files are missing a description field.</li> </ul> <p>Automation Actions:</p> <ul> <li>Add a <code>lambda-missing-field</code> label to the PR.</li> <li>Request changes and post a comment that explains why.</li> </ul> <p>Change Missing Lambda Field</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n# Request changes when required Lambda information is missing from the PR.\ncatch_missing_lambda_info:\n# Triggered for new Lambda functions that are missing a description field.\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/LambdaFunction/) | some }}\n- {{ source.diff.files | matchDiffLines(regex=r/description:/) | nope }}\n# Apply the lambda-missing-field label and request changes to the PR.\nrun:\n- action: add-label@v1\nargs:\nlabel: 'lambda-missing-field'\ncolor: '#FF0000'\n- action: request-changes@v1\nargs:\ncomment: |\nNew `LambdaFunction` must have `description:` field.\n</code></pre>  Download this example as a CM file."},{"location":"automations/change-missing-lambda-field/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Require changelog updates for PRs to specific branches</li> <li>Flag the use of deprecated APIs, functions, or other components.</li> <li>Restrict portions of your code base to authorized teams only.</li> <li>Require changes when PRs include !important tags in CSS files</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/close-wrong-team-by-directory/","title":"Close Wrong Team by Directory","text":"<p>Close PRs to a specified directory if the PR author is not on an approved team.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR changes one or more files inside <code>/src/views</code>. Customize this value for your project.</li> <li>The PR author is not a member of the <code>ui</code> team. Customize this value for your organization.</li> </ul> <p>Automation Actions:</p> <ul> <li>Close the PR.</li> <li>Post a comment that explains why the PR was closed.</li> </ul> <p>Close Wrong Team by Directory</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n# Close PRs to restricted sections of the codebase if the PR author isn't on the correct team. \nclose_wrong_team_by_directory:\n# Triggered when someone who isn't on the `ui` team submits a PR to change files inside /src/views\nif:\n- {{ files | match(regex=r/src\\/views/) | some }}\n- {{ pr.author_teams | match(term='ui') | nope }}\n# Close the PR and post a comment explaining the next step.\nrun:\n- action: add-comment@v1\nargs: comment: Please contact a member of the `ui` team if you need to make changes to files in `src/views`\n- action: close@v1\n</code></pre>  Download this example as a CM file."},{"location":"automations/close-wrong-team-by-directory/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Require changelog updates for PRs to specific branches</li> <li>Flag the use of deprecated APIs, functions, or other components.</li> <li>Require changes when PRs include !important tags in CSS files</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/generate-pr-description/","title":"Automatically Generate PR Description from Commit Messages","text":"<p>Automatically generate Pull Request descriptions based on commit messages. This automation helps ensure PR descriptions are consistent and informative.</p> <p>Required gitStream Plugins</p> <p>This example requires you to install the <code>generateDescription</code> plugin.</p> <p>Learn more about gitStream plugins.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created or has commits added to it.</li> </ul> <p>Automation Actions:</p> <ul> <li>Update the PR description with auto-generated content based on commit messages.</li> </ul> <p>Generate PR Description</p> <p><pre><code>triggers:\nexclude:\nbranch:\n- r/dependabot/\nautomations:\ngenerate_pr_desc:\nif:\n- true\nrun:\n- action: update-description@v1\nargs:\ndescription: |\n{{ branch | generateDescription(pr, repo, source) }}\n</code></pre>  Download this example as a CM file."},{"location":"automations/generate-pr-description/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/LinearBAI/code-review/","title":"Code Review Using LinearB's AI","text":"<p>Use LinearB's AI with the <code>code-review</code> action to automatically review the introduced changes to the code.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created or new code has been committed to the PR.</li> <li>The PR is not on Draft staten and was not created by a bot.</li> </ul> <p>Automation Actions:</p> <ul> <li>Perform an AI-driven code review and append the review comments to the PR.</li> <li>Use <code>guidelines</code> to add your prompts to the team or org review.</li> <li>Use <code>issues_limit</code> to control how many issues are included in the review comment (number or <code>unlimited</code>).</li> </ul> <p>Configuration Example</p> <p><pre><code>manifest:\nversion: 1.0\nautomations:\nlinearb_ai_review:\n# Triggers only when PR is created or has new commits, see docs\n#   https://docs.gitstream.cm/execution-model/#action-level-execution-control\nif:\n- {{ not pr.draft }}\n- {{ not (is.bot_author or is.bot_branch) }}\nrun:\n- action: code-review@v1\nargs:\napprove_on_LGTM: {{ approve_pr_on_lgtm }} # optional arg, you can remove it\nissues_limit: 10 # optional arg; set to a positive integer or \"unlimited\"\nguidelines: {{ guidelines }}\n# Define variables\n# Add conditions for PR approvals. For example - allow approval only for specific users\napprove_pr_on_lgtm: false\n# Add `guidelines` to customize the code review prompts:\n# - For repository-specific guidelines: Place `REVIEW_RULES.md` at your repository root\n# - For organization-wide guidelines: Place the file in your CM repository root and use `../cm/REVIEW_RULES.md`\n# - For team-specific guidelines: Place the file in the team repository root\n# The `dump` filter ensures proper YAML formatting when the file content is inserted\nguidelines: {{ \"./REVIEW_RULES.md\" | readFile() | dump }}\nis:\nbot_author: {{ pr.author | match(list=['github-actions', '_bot_', '[bot]', 'dependabot']) | some }}\nbot_branch: {{ branch.name | match(list=['renovate/']) | some }}\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/integrations/LinearBAI/code-review/#localization-support","title":"Localization Support","text":"<p>You can request the AI to provide code review comments in your preferred language by adding it to the guidelines:</p> <pre><code>automations:\nlinearb_ai_review:\nif:\n- {{ not pr.draft }}\nrun:\n- action: code-review@v1\nargs:\nguidelines: |\n- Use Spanish language for all comments\n- Focus on code quality and best practices\n</code></pre>"},{"location":"automations/integrations/LinearBAI/code-review/#repository-rules-file-example","title":"Repository rules file example","text":"<ol> <li> <p>Add the rules file to your repo root:</p> ./REVIEW_RULES.md<pre><code>- Do not comment on missing documentation.\n- Do not comment on missing tests.\n- For JavaScript code, enforce using camelCase for variables and functions.\n</code></pre> </li> <li> <p>Load the file in the code review automation:</p> <pre><code>automations:\n  linearb_ai_review:\n    if:\n      - {{ not pr.draft }}\n    run:\n      - action: code-review@v1\n        args:\n          guidelines: {{ \"./REVIEW_RULES.md\" | readFile() | dump }}\n</code></pre> </li> </ol>"},{"location":"automations/integrations/LinearBAI/code-review/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/LinearBAI/describe-pr/","title":"PR Description Using LinearB's AI","text":"<p>Use the <code>describe-changes</code> automation action to automatically generate and append a concise, AI-generated description to a pull request. This ensures that all PRs include meaningful and helpful descriptions, improving review efficiency.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created or new code has been committed to the PR.</li> </ul> <p>Automation Actions:</p> <ul> <li>Append the AI-generated description to the PR description.</li> </ul> <p>Configuration Example</p> <p><pre><code>manifest:\nversion: 1.0\nautomations:\nlinearb_ai_description:\n# Triggers only when PR is created or has new commits, see docs\n#   https://docs.gitstream.cm/execution-model/#action-level-execution-control\n# Skip description for Draft PRs and PRs from bots\nif:\n- {{ not pr.draft }}\n- {{ not (is.bot_author or is.bot_branch) }}\nrun:\n- action: describe-changes@v1\nargs:\nconcat_mode: append\nis:\nbot_author: {{ pr.author | match(list=['github-actions', '_bot_', '[bot]', 'dependabot']) | some }}\nbot_branch: {{ branch.name | match(list=['renovate/']) | some }}\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/integrations/LinearBAI/describe-pr/#localization-support","title":"Localization Support","text":"<p>You can request the AI to add PR descriptions in your preferred language by adding it to the guidelines:</p> <pre><code>automations:\nlinearb_ai_desc:\nif:\n- {{ not pr.draft }}\nrun:\n- action: describe-changes@v1\nargs:\nconcat_mode: append\nguidelines: |\n- Use Korean language for all comments\n</code></pre>"},{"location":"automations/integrations/LinearBAI/describe-pr/#repository-rules-file-example","title":"Repository rules file example","text":"<ol> <li> <p>Add the rules file to your repo root:</p> ./DESCRIPTION_RULES.md<pre><code>-  Add emojis to highlight important changes.\n-  Use clear and concise language.\n-  Avoid using jargon or technical terms.\n</code></pre> </li> <li> <p>Load the file in the PR descriptions automation:</p> <pre><code>automations:\n  linearb_ai_desc:\n    if:\n      - {{ not pr.draft }}\n    run:\n      - action: describe-changes@v1\n        args:\n          concat_mode: append\n          guidelines: {{ \"./DESCRIPTION_RULES.md\" | readFile() | dump }}\n</code></pre> </li> </ol>"},{"location":"automations/integrations/LinearBAI/describe-pr/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/ai-assistance/flag-ai-pr/","title":"Automatically Label AI-Assisted PRs","text":"<p>Automatically apply labels to PRs based on whether they were assisted by AI tools. Developers can indicate the specific AI tools or models used, or pre-add an AI-related label to skip the prompt.</p> Ask Developers About AI AssistanceSkip the survey for known users"},{"location":"automations/integrations/ai-assistance/flag-ai-pr/#ask-developers-about-ai-assistance","title":"Ask Developers About AI Assistance","text":"<p>Prompt PR authors with a convenient checkbox survey to indicate which AI tools they used for the PR. Developers can pre-add any <code>\ud83e\udd16 ai-*</code> label to skip the question. The automation checks for existing labels before posting the prompt.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is created, and no <code>\ud83e\udd16 ai-*</code> label is pre-applied.</li> <li>The question hasn't been asked before.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment with a checkbox survey about AI tools used.</li> <li>Apply labels based on the checkboxes selected.</li> </ul> <p>Ask the PR author about AI assistance.</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\ntriggers:\non:\n- pr_created\nautomations:\ncomment_ai_assistance_prompt:\n# Post a comment for all PRs to prompt the PR author to indicate whether they used AI to assist coding in this PR\n# Only do this if there's no existing AI-related label and we haven't asked before\nif:\n- {{ pr.labels | match(regex=r/\ud83e\udd16 ai-*/) | nope }}\n- {{ pr.comments | filter(attr='commenter', term='gitstream-cm') | filter(attr='content', regex=r/Please mark which AI tools you used/) | nope }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nPlease mark which AI tools you used for this PR by checking the appropriate boxes:\n- [ ] GitHub Copilot\n- [ ] Cursor\n- [ ] Zed\n- [ ] Tabnine\n- [ ] JetBrains AI Assistant\n- [ ] VSCode IntelliCode\n- [ ] ChatGPT\n- [ ] Claude Code\n- [ ] Gemini\n- [ ] Other AI tool\n- [ ] No AI tools were used\nTip: If you want to avoid this comment in the future, you can add a label of the format `\ud83e\udd16 ai-*` when creating your PR.\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/integrations/ai-assistance/flag-ai-pr/#track-ai-tools","title":"Track AI Tools","text":"<p>Add labels to the PR according to the tools that the developer checked in the micro-survey above </p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR with selected checkboxes for AI tools used.</li> <li>Optional: Details about AI Service and Model specified.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply labels for specific AI tools (e.g., <code>\ud83e\udd16 ai-copilot</code>, <code>\ud83e\udd16 ai-cursor</code>).</li> <li>Apply labels for AI services and models if provided.</li> </ul> <p>Track AI tools, models and services.</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_ai_tools_by_checkbox:\n# Apply labels based on the checkboxes selected in the PR comment\nif:\n- {{ pr.comments | filter(attr='content', regex=r/\\- \\[x\\] GitHub Copilot/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83e\udd16 ai-copilot\"\nlabel_ai_cursor:\nif:\n- {{ pr.comments | filter(attr='content', regex=r/\\- \\[x\\] Cursor/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83e\udd16 ai-cursor\"\nlabel_ai_tabnine:\nif:\n- {{ pr.comments | filter(attr='content', regex=r/\\- \\[x\\] Tabnine/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83e\udd16 ai-tabnine\"\nlabel_ai_jetbrains:\nif:\n- {{ pr.comments | filter(attr='content', regex=r/\\- \\[x\\] JetBrains AI Assistant/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83e\udd16 ai-jetbrains\"\nlabel_ai_intellicode:\nif:\n- {{ pr.comments | filter(attr='content', regex=r/\\- \\[x\\] VSCode IntelliCode/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83e\udd16 ai-intellicode\"\nlabel_ai_chatgpt:\nif:\n- {{ pr.comments | filter(attr='content', regex=r/\\- \\[x\\] ChatGPT/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83e\udd16 ai-chatgpt\"\nlabel_ai_other:\nif:\n- {{ pr.comments | filter(attr='content', regex=r/\\- \\[x\\] Other AI tool/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83e\udd16 ai-other\"\nlabel_ai_none:\nif:\n- {{ pr.comments | filter(attr='content', regex=r/\\- \\[x\\] No AI tools were used/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83e\udd16 ai-none\"\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/integrations/ai-assistance/flag-ai-pr/#ask-developers-about-ai-assistance_1","title":"Ask Developers About AI Assistance","text":"<p>The automation will not prompt known users for AI assistance. This allows a smoother experience for users who were predefined as AI users, to avoid answering the same questions again. </p> <p>Skip the survey for known users.</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\ntriggers:\non:\n- pr_created\nautomations:\ncomment_ai_assistance_prompt:\n# Post a comment for all PRs to prompt the PR author to indicate whether they used AI to assist coding in this PR\n# Only do this if there's no existing AI-related label and we haven't asked before\nif:\n- {{ pr.labels | match(regex=r/\ud83e\udd16 ai-*/) | nope }}\n- {{ pr.author | match(list=copilot_contributors) | nope }}\n- {{ pr.author | match(list=cursor_contributors) | nope }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nPlease mark which AI tools you used for this PR by checking the appropriate boxes:\n- [ ] GitHub Copilot\n- [ ] Cursor\n- [ ] Tabnine\n- [ ] JetBrains AI Assistant\n- [ ] VSCode IntelliCode\n- [ ] ChatGPT\n- [ ] Claude\n- [ ] Gemini\n- [ ] Other AI tool\n- [ ] No AI tools were used\n**Tip**: If you want to avoid this comment in the future, add a label of the format `\ud83e\udd16 ai-*` when creating your PR, or ask your admin to add you to the pre-defined lists of known users\nlabel_copilot_known_users:\n# For all PRs authored by someone who is specified in the genai_contributors list\nif:\n- {{ pr.author | match(list=copilot_contributors) | some  }}\n# Apply a label indicating the user has adopted Copilot\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 ai-copilot'\nlabel_cursor_known_users:\n# For all PRs authored by someone who is specified in the genai_contributors list\nif:\n- {{ pr.author | match(list=cursor_contributors) | some  }}\n# Apply a label indicating the user has adopted Copilot\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 ai-cursor'\ncopilot_contributors:\n- username1\n- username2\n- usernameN\ncursor_contributors:\n- username1\n- username2\n- usernameN\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/integrations/ai-assistance/flag-ai-pr/#track-ai-tools_1","title":"Track AI Tools","text":"<p>Add labels to the PR according to the tools that the developer checked in the micro-survey above </p> <p>Track AI tools, models and services.</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_ai_tools_by_checkbox:\n# Apply labels based on the checkboxes selected in the PR comment\nif:\n- {{ pr.comments | filter(attr='content', regex=r/\\- \\[x\\] GitHub Copilot/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83e\udd16 ai-copilot\"\nlabel_ai_cursor:\nif:\n- {{ pr.comments | filter(attr='content', regex=r/\\- \\[x\\] Cursor/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83e\udd16 ai-cursor\"\nlabel_ai_tabnine:\nif:\n- {{ pr.comments | filter(attr='content', regex=r/\\- \\[x\\] Tabnine/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83e\udd16 ai-tabnine\"\nlabel_ai_jetbrains:\nif:\n- {{ pr.comments | filter(attr='content', regex=r/\\- \\[x\\] JetBrains AI Assistant/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83e\udd16 ai-jetbrains\"\nlabel_ai_intellicode:\nif:\n- {{ pr.comments | filter(attr='content', regex=r/\\- \\[x\\] VSCode IntelliCode/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83e\udd16 ai-intellicode\"\nlabel_ai_chatgpt:\nif:\n- {{ pr.comments | filter(attr='content', regex=r/\\- \\[x\\] ChatGPT/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83e\udd16 ai-chatgpt\"\nlabel_ai_other:\nif:\n- {{ pr.comments | filter(attr='content', regex=r/\\- \\[x\\] Other AI tool/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83e\udd16 ai-other\"\nlabel_ai_none:\nif:\n- {{ pr.comments | filter(attr='content', regex=r/\\- \\[x\\] No AI tools were used/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83e\udd16 ai-none\"\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/integrations/amazon-q/flag-amazon-q-pr/","title":"Automatically Label Amazon Q PRs","text":"<p>Automatically apply labels to PRs that are assisted by Amazon Q. You can apply labels based on a known list of Amazon Q users, PR tags, or by prompting the PR author to indicate if they used Amazon Q.</p> Label by PromptLabel by Known UsersLabel by Tag <p>Prompt PR authors to indicate if they used Amazon Q for the PR and automatically label the PR if they did. This requires two separate automation files to handle posting the prompt and labeling accordingly.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is created</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment prompting the author to indicate if Amazon Q assisted the author with writing the code in the PR.</li> </ul> <p>Ask the PR author about Amazon Q usage</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\nautomations:\ncomment_amazon_q_prompt:\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nPlease mark whether you used Amazon Q to assist coding in this PR\n- [ ] Amazon Q Assisted\n- [ ] Not Amazon Q Assisted \n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is updated or merged where the author indicates they used Amazon Q via a prompt.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Amazon Q</code> label to the PR</li> </ul> <p>Label PRs where the user indicated Amazon Q usage</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_amazon_q_pr:\nif:\n- {{ pr.comments | filter(attr='commenter', term='gitstream-cm') | filter (attr='content', regex=r/\\- \\[x\\] Amazon Q Assisted/) | some}}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Amazon Q' </code></pre>  Download this example as a CM file. </p> <p>Automatically apply labels to PRs that are created by known users of generative AI coding tools.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The PR author is one of a specified list of contributors</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Amazon Q</code> label to the PR</li> </ul> <p>Label by Contributors</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_amazon_q_contributors:\nif:\n- {{ pr.author | match(list=amazon_q_contributors) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Amazon Q'\namazon_q_contributors:\n- username1\n- username2\n- etc </code></pre>  Download this example as a CM file. </p> <p>Look for a specific tag in the PR title, description, comments or commit messages and if found add a label to the PR</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li> <p>The <code>#amazon_q#</code> tag is found in any of the PR title, description, comments or commit messages for commits in the PR Automation Actions:</p> </li> <li> <p>Apply a <code>\ud83e\udd16 Amazon Q</code> label to the PR</p> </li> </ul> <p>Label Amazon Q by Tag</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- comment_added\n- commit\n- pr_created\nautomations:\nlabel_amazon_q:\nif:\n- {{ amazon_q_tag.pr_title or amazon_q_tag.pr_desc or amazon_q_tag.pr_comments or amazon_q_tag.commit_messages }}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Amazon Q'\namazon_q_tag:\npr_title: {{ pr.title | includes(regex=r/#amazon_q#/) }}\npr_desc: {{pr.description | includes(regex=r/#amazon_q#/) }}\npr_comments: {{ pr.comments | map(attr='content') | match(regex=r/#amazon_q#/) | some }}\ncommit_messages: {{ branch.commits.messages | match(regex=r/#amazon_q#/) | some }} </code></pre>  Download this example as a CM file. </p>"},{"location":"automations/integrations/amazon-q/flag-amazon-q-pr/#track-the-business-impact","title":"\ud83d\udcc8 Track the Business Impact","text":"<p>By labeling PRs assisted by Amazon Q, you can measure:</p> <ul> <li>Time savings (via Cycle Time, Review Time)</li> <li>PR risk (via Refactor Rate, CFR)</li> <li>Productivity lift from AI tools</li> </ul>"},{"location":"automations/integrations/asana/label-missing-asana/","title":"Label Missing Asana","text":"<p>Automatically label PRs that are missing references to Asana resources.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR is missing an Asana ticket reference in the PR title and a link to an Asana resource in the PR description.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a red <code>\u26a0\ufe0f Missing Asana Link</code> label</li> <li>Post a comment that asks the author to add an Asana reference to the PR.</li> </ul> <p>Label Missing Asana</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_missing_asana:\nif:\n- {{not (has.asana.ticket_in_title or has.asana.ticket_in_desc)}}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Asana Link\"\ncolor: {{ colors.red }}\n- action: add-comment@v1\nargs:\ncomment: Please provide a link to the associated Asana resource.\nhas:\nasana:\nticket_in_title: {{ pr.title | includes(regex=r/asana-(\\d+)/) }}\nticket_in_desc: {{ pr.description | includes(regex=r/app\\.asana.\\com\\/(\\d+)\\/(\\d+)\\/(\\d+)\\/(\\d+)\\/(\\d+)/) }}\ncolors:\nred: 'b60205'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/asana/label-missing-asana/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/asana/link-asana/","title":"Automatically Link PRs to Related Asana Cards","text":"<p>Provide automatic links to Asana cards that are associated with PRs.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains a reference to an Asana card in the title or branch name.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment that provides a link to the associated Asana Card.</li> </ul> <p>Automatically Link to the Related Asana Card</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nprovider: asana\n# Configure this to match your organization. It is used in tracker.asana.baseurl.\nasanaProject: 1234\n{% set ticketid = \"\" %}\n{% for ticket in tickets %}\n{% if (ticket | includes(regex=r/.+/)) %}\n{% set ticketid = ticket %}\n{% endif %}\n{% endfor %} automations:\nlink_asana:\nif:\n- {{ has.ticket_in_title or has.ticket_in_branch }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: Issue Tracker Link - [{{ticketid}}]({{tracker[provider].baseurl}}{{ticketid}})\nhas:\nticket_in_title: {{ pr.title | includes(regex=tracker[provider].pattern) }}\nticket_in_branch: {{ branch.name | includes(regex=tracker[provider].pattern) }}\ntracker:\nasana:\nbaseurl: https://app.asana.com/0/[asanaProject]/0/\npattern: r/asana-(\\d+)/\ntickets:\n- {{branch.name | capture(regex=tracker[provider].pattern)}}\n- {{pr.title | capture(regex=tracker[provider].pattern)}}\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/asana/link-asana/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/azure-boards/label-missing-azure-boards/","title":"Label Missing Azure Boards Info","text":"<p>Automatically label PRs that are missing references to Azure Boards resources.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR is missing one of the following:<ul> <li>An Azure Boards ticket reference in the PR title.</li> <li>A link to an Azure Boards resource in the PR description.</li> </ul> </li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a red <code>\u26a0\ufe0f Missing Azure Boards Link</code> label</li> <li>Post a comment that asks the author to add an Azure Boards reference to the PR.</li> </ul> <p>Label Missing Azure Boards</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_missing_azure:\nif:\n- {{not (has.azure.ticket_in_title or has.azure.ticket_in_desc)}}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Azure Boards Link\"\ncolor: {{ colors.red }}\n- action: add-comment@v1\nargs:\ncomment: Please provide a link to the associated resource in Azure Boards.\nhas:\nazure:\nticket_in_title: {{ pr.title | includes(regex=r/(\\w+)-(\\w+)-(\\d+)/) }}\nticket_in_desc: {{ pr.description | includes(regex=r/(dev\\.azure\\.com|(\\w+)\\.visualstudio\\.com)\\/(\\w+)\\/(\\w+)\\/_workitems\\/edit\\/(\\d+)/) }}\ncolors:\nred: 'b60205'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/azure-boards/label-missing-azure-boards/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/azure-boards/link-azure-boards/","title":"Automatically Link PRs to Related Azure Boards Resources","text":"<p>Provide automatic links to Azure Boards resources that are associated with PRs.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains a reference to an Azure Boards resource in the title or branch name.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment that provides a link to the associated Azure Boards Resource.</li> </ul> <p>Automatically Link to the Related Azure Boards Resource</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\n# Configure these to match your organization.\nprovider: azure\n# The name of your Azure organization\norgName: org\n# The name of your Azure project\nazureProject: my_project\n{% set ticketid = \"\" %}\n{% for ticket in tickets %}\n{% if (ticket | includes(regex=r/.+/)) %}\n{% set ticketid = ticket %}\n{% endif %}\n{% endfor %}\nautomations:\nlink_azure_boards:\nif:\n- {{ has.ticket_in_title or has.ticket_in_branch }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: Issue Tracker Link - [{{ticketid}}]({{tracker[provider].baseurl}}{{ticketid}})\nhas:\nticket_in_title: {{ pr.title | includes(regex=tracker[provider].pattern) }}\nticket_in_branch: {{ branch.name | includes(regex=tracker[provider].pattern) }}\ntracker:\nazure:\nbaseurl: https://dev.azure.com/{{orgName}}/{{azureProject}}/_workitems/\npattern: r/(\\w+)-(\\w+)-(\\d+)/\ntickets:\n- {{branch.name | capture(regex=tracker[provider].pattern)}}\n- {{pr.title | capture(regex=tracker[provider].pattern)}}\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/azure-boards/link-azure-boards/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/claude-code/flag-claude-code-pr/","title":"Automatically Label Claude Code PRs","text":"<p>Automatically apply labels to PRs that are assisted by Claude Code. You can apply labels based on a known list of Claude Code users, PR tags, or by prompting the PR author to indicate if they used Claude Code.</p> Label Co-authorLabel by PromptLabel by Known UsersLabel by Tag <p>Automatically apply labels to PRs that are authored by Claude or have Claude as a co-author in commit messages.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The PR author's name contains \"Claude\" (case-insensitive), OR</li> <li>Any commit message in the PR contains a \"Co-Authored-By\" line with Claude</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Claude Code</code> label to the PR</li> </ul> <p>Label Claude Code by Co-author</p> <p><pre><code>manifest:\nversion: 1.0\nautomations:\ntag_claude_pr:\nif:\n- {{ is.claude_author or is.claude_co_author }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83e\udd16 Claude Code\"\nis:\nclaude_author: {{ pr.author | lower | includes(regex=r/claude/) }}\nclaude_co_author: {{ branch.commits.messages | match(regex=r/[Cc]o-[Aa]uthored-[Bb]y:.*[Cc]laude/) | some }}\n</code></pre>  Download this example as a CM file. </p> <p>Prompt PR authors to indicate if they used Claude Code for the PR and automatically label the PR if they did. This requires two separate automation files to handle posting the prompt and labeling accordingly.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is created</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment prompting the author to indicate if Claude Code assisted the author with writing the code in the PR.</li> </ul> <p>Ask the PR author about Claude Code usage.</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\nautomations:\ncomment_claude_code_prompt:\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nPlease mark whether you used Claude Code to assist coding in this PR\n- [ ] Claude Code Assisted\n- [ ] Not Claude Code Assisted \n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is updated or merged where the author indicates they used Claude Code via a prompt.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Claude Code</code> label to the PR</li> </ul> <p>Label PRs where the user indicated Claude Code usage</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_claude_code_pr:\nif:\n- {{ pr.comments | filter(attr='commenter', term='gitstream-cm') | filter (attr='content', regex=r/\\- \\[x\\] Claude Code Assisted/) | some}}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Claude Code' </code></pre>  Download this example as a CM file. </p> <p>Automatically apply labels to PRs that are created by known users of generative AI coding tools.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The PR author is one of a specified list of contributors</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Claude Code</code> label to the PR</li> </ul> <p>Label by Contributors</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_claude_code_contributors:\nif:\n- {{ pr.author | match(list=claude_code_contributors) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Claude Code'\nclaude_code_contributors:\n- username1\n- username2\n- etc </code></pre>  Download this example as a CM file. </p> <p>Look for a specific tag in the PR title, description, comments or commit messages and if found add a label to the PR</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The <code>#claude_code#</code> tag is found in any of the PR title, description, comments or commit messages for commits in the PR</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Claude Code</code> label to the PR</li> </ul> <p>Label Claude Code by Tag</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- comment_added\n- commit\n- pr_created\nautomations:\nlabel_claude_code:\nif:\n- {{ claude_code_tag.pr_title or claude_code_tag.pr_desc or claude_code_tag.pr_comments or claude_code_tag.commit_messages }}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Claude Code'\nclaude_code_tag:\npr_title: {{ pr.title | includes(regex=r/#claude_code#/) }}\npr_desc: {{pr.description | includes(regex=r/#claude_code#/) }}\npr_comments: {{ pr.comments | map(attr='content') | match(regex=r/#claude_code#/) | some }}\ncommit_messages: {{ branch.commits.messages | match(regex=r/#claude_code#/) | some }} </code></pre>  Download this example as a CM file. </p>"},{"location":"automations/integrations/claude-code/flag-claude-code-pr/#track-the-business-impact","title":"\ud83d\udcc8 Track the Business Impact","text":"<p>By labeling PRs assisted by Claude Code, you can measure:</p> <ul> <li>Time savings (via Cycle Time, Review Time)</li> <li>PR risk (via Refactor Rate, CFR)</li> <li>Productivity lift from AI tools</li> </ul>"},{"location":"automations/integrations/copilot/flag-copilot-pr/","title":"Automatically Label GitHub Copilot PRs","text":"<p>Automatically apply labels to PRs that are assisted by GitHub Copilot. You can apply labels based on a known list of Copilot users, PR tags, or by prompting the PR author to indicate if they used Copilot.</p> Label by PromptLabel by Known UsersLabel by TagLabel by Copilot code comment <p>Prompt PR authors to indicate if they used Copilot for the PR and automatically label the PR if they did. This requires two separate automation files to handle posting the prompt and labeling accordingly.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is created</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment prompting the author to indicate if Copilot assisted the author with writing the code in the PR.</li> </ul> <p>Ask the PR author about Copilot usage.</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\nautomations:\ncomment_copilot_prompt:\n# Post a comment for all PRs to prompt the PR author to indicate whether they used Copilot to assist coding in this PR\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nPlease mark whether you used Copilot to assist coding in this PR\n- [ ] Copilot Assisted\n- [ ] Not Copilot Assisted\n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is updated or merged where the author indicates they used Copilot via a prompt.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Copilot</code> label to the PR</li> </ul> <p>Label PRs where the user indicated Copilot usage</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n# You should use this automation in conjunction with comment_copilot_prompt.cm\nlabel_copilot_pr:\n# If the PR author has indicated that they used Copilot to assist coding in this PR, \n# apply a label indicating the PR was supported by Copilot\nif:\n- {{ pr.comments | filter(attr='commenter', term='gitstream-cm') | filter (attr='content', regex=r/\\- \\[x\\] Copilot Assisted/) | some}}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Copilot'\n</code></pre>  Download this example as a CM file. </p> <p>Automatically apply labels to PRs that are created by known users of generative AI coding tools.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The PR author is one of a specified list of contributors</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Copilot</code> label to the PR</li> </ul> <p>Label by Contributors</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_copilot_by_contributors:\n# For all PRs authored by someone who is specified in the genai_contributors list\nif:\n- {{ pr.author | match(list=genai_contributors) | some }}\n# Apply a label indicating the user has adopted Copilot\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 ai-copilot'\ngenai_contributors:\n- username1\n- username2\n- usernameN\n</code></pre>  Download this example as a CM file. </p> <p>Look for a specific tag  in the PR title, description, comments or commit messages and if found add a label to the PR</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The <code>#copilot#</code> tag is found in any of the PR title, description, comments or commit messages for commits in the PR</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Copilot</code> label to the PR</li> </ul> <p>Label Copilot by Tag</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- comment_added\n- commit\n- pr_created\nautomations:\nlabel_copilot:\n# Detect PRs that contain the text '#copilot#' in the title, description, comments, or commit messages\nif:\n- {{ copilot_tag.pr_title or copilot_tag.pr_desc or copilot_tag.pr_comments or copilot_tag.commit_messages  }}\n# Apply a label indicating the user has adopted Copilot\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Copilot'\ncopilot_tag:\npr_title: {{ pr.title | includes(regex=r/#copilot#/) }}\npr_desc: {{pr.description | includes(regex=r/#copilot#/) }}\npr_comments: {{ pr.comments | map(attr='content') | match(regex=r/#copilot#/) | some }}\ncommit_messages: {{ branch.commits.messages | match(regex=r/#copilot#/) | some }}\n</code></pre>  Download this example as a CM file. </p> <p>Experimental</p> <p>Code generation instructions is an experimental setting which might change in future GitHub Copilot versions.</p> <p>Use Code generation instructions to instruct copilot to add a comment at the beginning of the AI generated code. Use gitStream automation to automatically identify PRs with this comment </p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The comment <code>Generated by Copilot</code> is added to the code in this PR</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Copilot</code> label to the PR</li> </ul> <p>Label Copilot by comment</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_copilot_pr:\n# Look for the comment 'Generated by Copilot' in the added code\nif:\n- {{ source.diff.files | matchDiffLines(regex=copilot_comment, ignoreWhiteSpaces=true) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Copilot'\ncopilot_comment: \"r/^\\\\+.*Generated by Copilot/\"\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/integrations/cursor/flag-cursor-pr/","title":"Automatically Label Cursor PRs","text":"<p>Automatically apply labels to Pull Requests that are assisted by Cursor AI. This automation helps track the impact and usage of Cursor's AI capabilities across your development workflow.</p> Label by PromptLabel by Known UsersLabel by Tag <p>Prompt PR authors to indicate if they used Cursor for the PR and automatically label the PR if they did. This requires two separate automation files to handle posting the prompt and labeling accordingly.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is created</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment prompting the author to indicate if Cursor assisted the author with writing the code in the PR.</li> </ul> <p>Ask the PR author about Cursor usage</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\nautomations:\ncomment_cursor_prompt:\n# Post a comment for all PRs to prompt the PR author to indicate whether they used Cursor to assist coding in this PR\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nPlease mark whether you used Cursor to assist coding in this PR\n- [ ] Cursor Assisted\n- [ ] Not Cursor Assisted \n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is updated or merged where the author indicates they used Cursor via a prompt.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Cursor</code> label to the PR</li> </ul> <p>Label PRs where the user indicated Cursor usage</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n# You should use this automation in conjunction with comment_cursor_prompt.cm\nlabel_cursor_pr:\n# If the PR author has indicated that they used Cursor to assist coding in this PR, \n# apply a label indicating the PR was supported by Cursor\nif:\n- {{ pr.comments | filter(attr='commenter', term='gitstream-cm') | filter (attr='content', regex=r/\\- \\[x\\] Cursor Assisted/) | some}}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Cursor' </code></pre>  Download this example as a CM file. </p> <p>Automatically apply labels to PRs that are created by known users of generative AI coding tools.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The PR author is one of a specified list of contributors</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Cursor</code> label to the PR</li> </ul> <p>Label by Contributors</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_cursor_contributors:\n# For all PRs authored by someone who is specified in the cursor_contributors list\nif:\n- {{ pr.author | match(list=cursor_contributors) | some }}\n# Apply a label indicating the user has adopted Cursor\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Cursor'\ncursor_contributors:\n- username1\n- username2\n- etc </code></pre>  Download this example as a CM file. </p> <p>Look for a specific tag in the PR title, description, comments or commit messages and if found add a label to the PR</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The <code>#cursor#</code> tag is found in any of the PR title, description, comments or commit messages for commits in the PR</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Cursor</code> label to the PR</li> </ul> <p>Label Cursor by Tag</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- comment_added\n- commit\n- pr_created\nautomations:\nlabel_cursor:\n# Detect PRs that contain the text '#cursor#' in the title, description, comments, or commit messages\nif:\n- {{ cursor_tag.pr_title or cursor_tag.pr_desc or cursor_tag.pr_comments or cursor_tag.commit_messages }}\n# Apply a label indicating the user has adopted Cursor\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Cursor'\ncursor_tag:\npr_title: {{ pr.title | includes(regex=r/#cursor#/) }}\npr_desc: {{pr.description | includes(regex=r/#cursor#/) }}\npr_comments: {{ pr.comments | map(attr='content') | match(regex=r/#cursor#/) | some }}\ncommit_messages: {{ branch.commits.messages | match(regex=r/#cursor#/) | some }} </code></pre>  Download this example as a CM file. </p>"},{"location":"automations/integrations/dependabot/approve-dependabot/","title":"Approve and Merge Dependabot Changes","text":"<p>Auto-merge Dependabot PRs</p> By Release TypeAll Updates <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR author is Dependabot.</li> <li>The branch name includes 'dependabot'</li> <li>The dependency change is a patch or minor update.</li> </ul> <p>Automation Actions:</p> <ul> <li>Approve the PR</li> <li>Apply an <code>approved-dependabot</code> label to the PR</li> <li>Merge the PR if all status checks pass.</li> </ul> <p>Configuration Example</p> <p><pre><code>manifest:\nversion: 1.0\nautomations:\nmerge_dependabot_minor:\non:\n- pr_created\n- commit\nif:\n- {{ bump == 'minor' }}\n- {{ branch.name | includes(term=\"dependabot\") }}\n- {{ branch.author | includes(term=\"dependabot\") }}\nrun:\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nDependabot `minor` version bumps are approved automatically.\nmerge_dependabot_minor_patch:\non:\n- pr_created\n- commit\nif:\n- {{ bump == 'patch' }}\n- {{ branch.name | includes(term=\"dependabot\") }}\n- {{ branch.author | includes(term=\"dependabot\") }}\nrun:\n- action: approve@v1\n- action: merge@v1\n- action: add-comment@v1\nargs:\ncomment: |\nDependabot `patch` version bumps are approved and merged automatically.\nbump: {{ pr.description | checkDependabot | checkSemver }}\n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR author is Dependabot.</li> <li>The branch name includes 'dependabot'</li> </ul> <p>Automation Actions:</p> <ul> <li>Approve the PR</li> <li>Apply an <code>approved-dependabot</code> label to the PR</li> <li>Merge the PR if all status checks pass.</li> </ul> <p>Configuration Example</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_dependabot:\non:\n- pr_created\n- commit\nif:\n- {{ branch.name | includes(term=\"dependabot\") }}\n- {{ branch.author | includes(term=\"dependabot\") }}\nrun:\n- action: approve@v1\n- action: add-label@v1\nargs:\nlabel: \"approved-dependabot\"\n- action: merge@v1\nargs:\nwait_for_all_checks: true\nsquash_on_merge: true\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/integrations/devcycle/label-ff-devcycle/","title":"Label DevCycle Feature Flags","text":"<p>Automatically label code that contians specified feature flags.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR adds one or more feature flag keys.</li> </ul> <p>Automation Actions:</p> <ul> <li>Label the PR for each feature flag key introduced in the PR.</li> </ul> <p>Label PRs Based on Feature Flags</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in feature_flags %}\nlabel_ff_devcycle_{{ item.name }}:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/key = '/) | some }}\n      - {{ source.diff.files | matchDiffLines(regex=item.regex) | some }}\n    run:\n      - action: add-label@v1\n        args:\n          label: {{ item.name }}\n          color: {{ colors.yellow }}\n  {% endfor %}\nfeature_flags:\n   - name: engineering_rollback_plan_activated \n     regex: r/engineering_rollback_plan_activated/\n   - name: marketing_premium_plan_features_unlocked \n     regex: r/marketing_premium_plan_features_unlocked/\n   - name: mobile_push_notifications_enabled\n     regex: r/mobile_push_notifications_enabled/\ncolors:\n  yellow: 'ffb300'   \n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/flagr/label-ff-flagr/","title":"Label Flagr Feature Flags","text":"<p>Automatically label code that contians specified feature flags.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR adds one or more feature flag keys.</li> </ul> <p>Automation Actions:</p> <ul> <li>Label the PR for each feature flag key introduced in the PR.</li> </ul> <p>Label PRs Based on Feature Flags</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in feature_flags %}\nlabel_ff_flagr_{{ item.name }}:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/evaluation_result.variant_id ==/) | some }}\n- {{ source.diff.files | matchDiffLines(regex=item.regex) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: {{ item.name }}\ncolor: {{ colors.yellow }}\n{% endfor %}\nfeature_flags:\n- name: engineering_rollback_plan_activated regex: r/engineering_rollback_plan_activated/\n- name: marketing_premium_plan_features_unlocked regex: r/marketing_premium_plan_features_unlocked/\n- name: mobile_push_notifications_enabled\nregex: r/mobile_push_notifications_enabled/\ncolors:\nyellow: 'ffb300'   </code></pre>  Download this example as a CM file."},{"location":"automations/integrations/flagsmith/label-ff-flagsmith/","title":"Label Flagsmith Feature Flags","text":"<p>Automatically label code that contians specified feature flags.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR adds one or more feature flag keys.</li> </ul> <p>Automation Actions:</p> <ul> <li>Label the PR for each feature flag key introduced in the PR.</li> </ul> <p>Label PRs Based on Feature Flags</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in feature_flags %}\nlabel_ff_flagsmith_{{ item.name }}:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/flagsmith.hasFeature\\(/) | some }}\n- {{ source.diff.files | matchDiffLines(regex=item.regex) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: {{ item.name }}\ncolor: {{ colors.yellow }}\n{% endfor %}\nfeature_flags:\n- name: engineering_rollback_plan_activated regex: r/engineering_rollback_plan_activated/\n- name: marketing_premium_plan_features_unlocked regex: r/marketing_premium_plan_features_unlocked/\n- name: mobile_push_notifications_enabled\nregex: r/mobile_push_notifications_enabled/\ncolors:\nyellow: 'ffb300'   </code></pre>  Download this example as a CM file."},{"location":"automations/integrations/github-actions/dispatch-github-action/","title":"Dispatch GitHub Actions","text":"<p>Automatically trigger GitHub Actions based on PR content like changed resources, source or target branch, slash commands, and more.</p> <p></p> By BranchUsing LabelsBy Modified Resources <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR source or target branch matches a specified format.</li> </ul> <p>Automation Actions:</p> <ul> <li>Trigger a manual dispatch for the specified CI pipeline.</li> </ul> <p>Dispatch GitHub Actions by Branch</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\n- commit\nautomations:\n{% for item in pipelines %}\n# Change pr.target to branch.name if you want to trigger on the source branch rather then the target branch.\ndispatch_github_action_branch_{{ item.name }}:\nif:\n- {{ pr.target | includes(term=item.branch_prefix) }}\nrun:\n- action: run-github-workflow@v1\nargs:\nworkflow: .github/workflows/{{ item.workflow }}\ncheck_name: {{ item.name }}\n- action: add-label@v1\nargs:\nlabel: {{ item.label }}\n{% endfor %}\npipelines:\n- name: mobile_ci\nlabel: Mobile CI\nbranch_prefix: 'mobile-'\nworkflow: mobile.yml\n- name: backend_ci\nlabel: Backend CI\nbranch_prefix: 'backend-'\nworkflow: 'backend.yml'\n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR has one or more specified labels applied to it.</li> </ul> <p>Automation Actions:</p> <ul> <li>Trigger a manual dispatch for the specified CI pipeline.</li> </ul> <p>Dispatch GitHub Actions Using Labels</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- label_added\n- label_removed\nautomations:\n{% for item in pipelines %}\ndispatch_github_action_label_{{ item.name }}:\nif:\n- {{ pr.labels | match(term=item.label) | some }}\nrun:\n- action: run-github-workflow@v1\nargs:\nworkflow: .github/workflows/{{ item.workflow }}\ncheck_name: {{ item.name }}\n{% endfor %}\npipelines:\n- name: mobile-ci\nlabel: Mobile CI\nworkflow: mobile.yml\n- name: backend-ci\nlabel: Backend CI\nworkflow: 'backend.yml'\n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR modifies one or more specified resources.</li> </ul> <p>Automation Actions:</p> <ul> <li>Trigger a manual dispatch for the specified CI pipeline.</li> </ul> <p>Dispatch GitHub Actions Based on Modified Resources</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\n- commit\nautomations:\n{% for item in pipelines %}\ndispatch_github_action_resource_{{ item.name }}:\nif:\n- {{ files | match(list=item.resources) | some }}\nrun:\n- action: run-github-workflow@v1\nargs:\nworkflow: .github/workflows/{{ item.workflow }}\ncheck_name: {{ item.name }}\n- action: add-label@v1\nargs:\nlabel: {{ item.label }}\n{% endfor %}\npipelines:\n- name: mobile-ci\nlabel: Mobile CI\nresources:\n- 'src/android/'\n- 'src/ios/'\nworkflow: mobile.yml\n- name: backend-ci\nlabel: Backend CI\nresources:\n- 'src/api/'\n- 'src/services'\nworkflow: 'backend.yml'\n- name: frontend-ci\nlabel: Frontend CI\nresources:\n- 'src/app/'\nworkflow: 'frontend.yml'\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/integrations/github-actions/dispatch-github-action/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Automatically approve changes to docs, tests, and other safe assets.</li> <li>Approve low-risk PRs from trusted teams.</li> <li>Approve Python or JavaScript formatting changes.</li> <li>Approve Tiny Changes</li> <li>Approve JSDoc or Javadoc changes.</li> <li>Approve and Merge Dependabot PRs</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/github-actions/skip-github-action/","title":"Skip Required GitHub Actions","text":"<p>Automatically skip GitHub Actions based on branch names, modified resource, slash commands, and more.</p> <p></p> <p>Prerequisite Config for Required Statuses</p> <p>If you want to skip a required status check, you will need to make sure that your branch protection is configured to allow gitStream to bypass status check requirements.</p> <p></p> By BranchUsing LabelsBy Modified Resource <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The target branch name includes a specified keyword. Optionally, you can modify this to detect the source branch name.</li> </ul> <p>Automation Actions:</p> <ul> <li>Skip the specified CI pipelines.</li> </ul> <p>Automatically Skip GitHub Actions by Branch</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\n- commit\n# Optionally, you can change pr.target to branch.name\n# if you want to trigger based on the source branch name rather then the target branch name.\nautomations:\nskip_github_action_branch:\nif:\n- {{ pr.target | includes(term='release') }}\nrun:\n- action: add-github-check@v1\nargs:\ncheck_name: staging-ci\nconclusion: skipped\n- action: add-comment@v1\nargs:\ncomment: |\n[gitStream](https://docs.gitstream.cm) automatically skipped staging CI pipelines because this PR targets the release branch.\n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>Someone applies one or more specified labels to a PR.</li> </ul> <p>Automation Actions:</p> <ul> <li>Skip the specified CI pipelines.</li> </ul> <p>Use Labels to Automatically Skip GitHub Actions</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- label_added\n- label_removed\nautomations:\nskip_github_action_label:\nif:\n- {{ pr.labels | match(term='experimental') | some }}\nrun:\n- action: add-github-check@v1\nargs:\ncheck_name: production-ci\nconclusion: skipped\n- action: add-comment@v1\nargs:\ncomment: |\n[gitStream](https://docs.gitstream.cm) automatically skipped production CI pipelines because this is labeled for experimental release.\n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR modifies specific files or directories.</li> </ul> <p>Automation Actions:</p> <ul> <li>Skip a specified GitHub Action.</li> </ul> <p>Automatically Skip GitHub Actions Based on Modified Resources</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\n- commit\nautomations:\nskip_github_action_resource:\nif:\n- {{ files | match(term='docs/') | every }}\nrun:\n- action: add-github-check@v1\nargs:\ncheck_name: release-ci\nconclusion: skipped\n- action: add-github-check@v1\nargs:\ncheck_name: mobile-ci\nconclusion: skipped\n- action: add-comment@v1\nargs:\ncomment: |\n[gitStream](https://docs.gitstream.cm) automatically skipped production CI pipelines because this PR only contains docs changes.\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/integrations/github-actions/skip-github-action/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Automatically approve changes to docs, tests, and other safe assets.</li> <li>Approve low-risk PRs from trusted teams.</li> <li>Approve Python or JavaScript formatting changes.</li> <li>Approve Tiny Changes</li> <li>Approve JSDoc or Javadoc changes.</li> <li>Approve and Merge Dependabot PRs</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/godoc/review-godoc/","title":"Review Godoc Changes","text":"<p>Approve PRs that only contain changes to Godoc and assign optional reviewers.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR only contains changes to Godoc content.</li> </ul> <p>Automation Actions:</p> <ul> <li>Assign the org/tech-writers team for optional review.</li> <li>Apply a green <code>\ud83d\udcd3 Godoc Only</code> label</li> <li>Approve the PR</li> </ul> <p>Review Godoc</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n#Assign PRs that only affect godocs to the technical writing team and add docs label\nreview_godoc:\nif:\n- {{ source.diff.files | match(attr='diff', regex=r/^\\/\\/.*/) | every }}\n- {{ files | extensions | match(regex=r/go/) | every }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83d\udcd3godoc Only\"\ncolor: {{ colors.green }}\n- action: add-reviewers@v1\nargs:\nreviewers: [org/tech-writers]\n- action: approve@v1\ncolors:\ngreen: '0e8a16'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/godoc/review-godoc-large/","title":"Review Godoc for Large Changes","text":"<p>Require more extensive reviews for large Golang changes that lack Godoc updates.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR changes more than 100 lines of Golang code.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment asking the author to review all relevant Godoc to identify necessary updates.</li> <li>Require a review from the <code>ORG/tech-writers</code> team.</li> <li>Apply a yellow <code>\u26a0\ufe0f Missing Godoc</code> Label</li> </ul> <p>Review Godoc</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n#Require more extensive reviews for large Golang changes that lack Godoc updates.\nreview_godoc_large:\nif:\n- {{ changes.additions &gt; 100}}\n- {{ source.diff.files | matchDiffLines(regex=r/^\\/\\/.*/) | nope }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Godoc\"\ncolor: {{ colors.yellow }}\n- action: add-comment@v1\nargs: comment: | This PR makes major changes to Golang classes, but is missing updates to Godoc. Please double check for any necessary Godoc updates.\n- action: add-reviewers@v1\nargs:\nreviewers: [fourth-organization/tech-writers]\nchanges:\n# Sum all the lines added/edited in the PR\nadditions: {{ branch.diff.files_metadata | map(attr='additions') | sum }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/godoc/review-godoc-new-class/","title":"Require Godoc for New Golang Classes","text":"<p>Require Godoc for all new Golang classes.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates a new Golang class.</li> <li>The PR lacks Godoc content.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment explaining that Godoc is required</li> <li>Apply a yellow <code>\u26a0\ufe0f Missing Godoc</code> label.</li> </ul> <p>Enforce Godoc for New Golang Classes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_godoc_new_class: if:  - {{ is.go and is.new }} - {{ source.diff.files | match(attr='diff', regex=r/\\/*[\\s\\S]*?\\//) | nope }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing godoc\"\ncolor: {{ colors.yellow }}\n- action: add-comment@v1\nargs: comment: | godoc is required for all Golang classes. Please add godoc to all new classes in this PR.\nis:\ngo: {{ files | extensions | match(regex=r/go/) | every }}\nnew: {{ source.diff.files | map(attr='original_file') | match(regex=r/^$/) | some }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/javadoc/review-javadoc/","title":"Review Javadoc Changes","text":"<p>Unblock PRs that only change Javadoc content.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR only contains changes to Javadoc content.</li> </ul> <p>Automation Actions:</p> <ul> <li>Assign the <code>org/tech-writers</code>team for optional review.</li> <li>Apply a green <code>\ud83d\udcd3 Javadoc Only</code> label</li> <li>Approve the PR</li> </ul> <p>Review Javadoc Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n# Assign PRs that only affect JavaDocs to the technical writing team and add docs label\nreview_javadoc:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/\\/*\\*([\\s\\S]*?)\\//) | every }}\n- {{ source.diff.files | matchDiffLines(regex=r/\\b(public|protected|private|static|final|synchronized)?\\s+\\w+\\s+\\w+\\s*\\(([^)]*)\\)\\s*\\{/) | nope }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83d\udcd3 Javadoc Only\"\ncolor: {{ colors.green }}\n- action: add-reviewers@v1\nargs:\nreviewers: [org/tech-writers]\n- action: approve@v1\ncolors:\ngreen: '0e8a16'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/javadoc/review-javadoc-input-parameters/","title":"Review Java Input Parameters for Javadoc Changes","text":"<p>If a PR modifies the input parameters for a Java method, but not the associated Javadocs, notify reviewers to check for Javadoc updates.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR changes one or more input parameters in Java methods.<ul> <li>Note: This may not trigger for methods with annotations, methods that throw exceptions, multi-line method definitions, and other non-standard use cases.</li> </ul> </li> <li>The PR lacks changes to \u2018@param\u2019 declarations.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment warning the user to review the method\u2019s Javadoc to identify necessary updates.</li> </ul> <p>Review Javadoc</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_javadoc_input_parameters: if:  - {{ source.diff.files | matchDiffLines(regex=r/\\*\\s@param/) | nope }}\n- {{ source.diff.files | matchDiffLines(regex=r/\\b(public|protected|private|static|final|synchronized)?\\s+\\w+\\s+\\w+\\s*\\(([^)]*)\\)\\s*\\{/) | some }}\nrun:\n- action: add-comment@v1\nargs: comment: | This PR modifies method input parameters, but is missing Javadoc changes. Please check to ensure no Javadoc changes are necessary.\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/javadoc/review-javadoc-large-change/","title":"Review Javadoc for Large Changes","text":"<p>Require more extensive reviews for large Java changes that lack Javadoc updates.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR changes more than 25% of a Java class.</li> <li>The PR lacks Javadoc changes.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment asking the author to review all relevant Javadoc to identify necessary updates.</li> <li>Require a review from the <code>my-organization/tech-writers</code> team.</li> <li>Apply a yellow <code>\u26a0\ufe0f Missing Javadoc</code> Label</li> </ul> <p>Review Javadoc for Large Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n#Require more extensive reviews for large Java changes that lack Javadoc updates.\nreview_javadoc_large:\nif:\n- {{ changes.ratio &gt; 25}}\n- {{ source.diff.files | matchDiffLines(regex=r/\\/*\\*([\\s\\S]*?)\\//) | nope }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Javadoc\"\ncolor: {{ colors.yellow }}\n- action: add-comment@v1\nargs: comment: | This PR makes major changes to Java classes, but is missing updates to Javadoc. Please double check for any necessary Javadoc updates.\n- action: add-reviewers@v1\nargs:\nreviewers: [fourth-organization/tech-writers]\nchanges:\n# Sum all the lines added/edited in the PR\nadditions: {{ branch.diff.files_metadata | map(attr='additions') | sum }}\n# Sum all the line removed in the PR\ndeletions: {{ branch.diff.files_metadata | map(attr='deletions') | sum }}\n# Calculate the ratio of new code\nratio: {{ (changes.additions / (changes.additions + changes.deletions)) * 100 | round(2) }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/javadoc/review-new-class-javadoc/","title":"Enforce Javadoc Requirements for New Classes","text":"<p>Automatically request changes when someone creates a new Java class that lacks Javadoc content.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates a new Java class.</li> <li>The PR lacks Javadoc content.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\u26a0\ufe0f Missing Javadoc</code> label.</li> <li>Request changes, and post a comment explaining that Javadoc is required</li> </ul> <p>Review Javadoc Requirements for New Classes</p> <p><pre><code>manifest:\nversion: 1.0\nautomations:\nreview_new_class_javadoc:\n# Triggered for new Java files that lack Javadoc content.\nif:\n- {{ is.java and is.new }}\n- {{ source.diff.files | matchDiffLines(regex=r/\\/*\\*([\\s\\S]*?)\\//) | nope }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Javadoc\"\ncolor: {{ colors.yellow }}\n- action: request-changes@v1\nargs:\ncomment: | This PR creates new Java classes, but is missing updates to Javadoc. Please double check for any necessary Javadoc updates.\nis:\njava: {{ files | extensions | match(term='java') | every }}\nnew: {{ source.diff.files | map(attr='original_file') | match(regex=r/^$/) | some }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/jira/configure/","title":"Configure Jira for gitStream Integrations","text":"<p>If you want to build gitStream automations to interact with the Jira API or Jira webhooks, you'll need to complete some setup in Jira, GitHub, and gitStream. This section outlines the setup process depending on the type of automation you want to build.</p> <p>These guides are for sending HTTP requests to Jira</p> <p>If the gitStream automations you want to use don't make any HTTP requests to a Jira API or webhook, you can ignore this section.</p>"},{"location":"automations/integrations/jira/configure/#use-webhooks-to-trigger-jira-automations","title":"Use Webhooks to Trigger Jira Automations","text":"<p>Jira automations are the preferred method for gitStream to trigger actions within Jira, so you should use them whenever possible. If webhooks don't provide access to the data you need, or acheive the functionality you want, use the Jira API instead.</p> <p>First, create a Jira automation that uses an incoming webhook as the trigger and add whatever automation components you want after this trigger. Save the webhook URL in a secure place, you'll need it later.</p> <p>Here is an example of an automation that uses the <code>webhookData</code> property of the incoming data payload to create a new task. It expects the incoming data payload to contain <code>title</code> and <code>pr_url</code> fields to set the task summary and a <code>pr_url</code> custom field our demo environment already has configured.</p> <p></p> <p> Learn more about working with incoming webhooks in the Jira docs </p> <p>Next, in GitHub, create an organization secret to store your Jira webhook URL and pass it to gitStream's <code>env</code> context variable by adding a line to <code>.github/workflows/gitstream.yml</code> inside your repo. Make sure to give this a unique name, such as <code>JIRA_CREATE_ISSUE_WEBHOOK: ${{ secrets.JIRA_CREATE_ISSUE_WEBHOOK }}</code>.</p> <p>Once finished, you can use the <code>env.JIRA_CREATE_ISSUE_WEBHOOK</code> context variable inside CM files to send HTTP requests to Jira from your GitHub repo. For an example of how to do this, check out the create Jira issue automation.</p>"},{"location":"automations/integrations/jira/configure/#connect-to-the-jira-api","title":"Connect to the Jira API","text":"<p>The Jira API is useful in situations where you need to retreive data from Jira or need to access capabilities that aren't available via Jira Automations. The Jira API uses an account-based token system that follows a basic auth model; this means you'll need an individual account to connect to Jira's APIs and will pass the account email address and API token in the headers of your API requests.</p> <p>Here's the process to grant gitStream access to the Jira API:</p> <ol> <li>Create an API token for your Jira account, and give it a unique name. Copy the API token, you'll need it in the next step.</li> <li>Create a GitHub organization secret to store the token and make the secret available to gitStream's <code>env</code> context variable.</li> <li>Add <code>env.MY_API_TOKEN</code> to any of your CM automations to access the API token and pass it to plugins and automation actions.</li> </ol> <p>Check out the <code>hasJiraIssue</code> filter plugin for an example of how to use Jira API tokens.</p>"},{"location":"automations/integrations/jira/create-jira-issue/","title":"Automatically Create Jira Issues from PRs","text":"<p>Automatically create Jira tickets for new pull/merge requests.</p> <p>Jira API &amp; Webhook Integration Required.</p> <p>This automation requires you to connect to the Jira API and incoming webooks.</p> <p>Required gitStream Plugins</p> <p>This example requires you to install the <code>hasJiraIssue</code> plugin.</p> <p>Learn more about gitStream plugins.</p> <p> </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR description contains the text <code>- [x] Auto-create Jira Issue</code></li> <li>No existing Jira issues reference the PRs URL.</li> </ul> <p>Automation Actions:</p> <ul> <li>Send an HTTP request to create a new Jira issue.</li> </ul> <p>Automatically Create Jira Issues</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\n###### ** Configure This Section ** ######\n# Configure this for your Jira instance and the email associated with your API key.\n# You can safely use these values because only your API key is sensitive. \njiraSpaceName: \"my-company\" # e.g. my-company.atlassian.net\nemail: \"my.email@example.com\"\n# If you're concerned about exposing this information,\n# we recommend using environment variables for your production environment.\n# -----------\n# Pass the API token associated with the email above to gitStream via an environment variable.\njiraAuth: {{ env.JIRA_API_TOKEN }}\n# Learn more about env: https://docs.gitstream.cm/context-variables/#env\n# -----------\n# Change this to the Jira field you want to match the input string against.\njiraField: \"myField\"\n# If you want to search a custom field, you should provide the ID like so:\n# jiraField: \"cf[XXXXX]\"\n# Replace XXXXX with the ID of the custom field you want to search.\n# More information:\n# Using JQL to search the Jira API: https://support.atlassian.com/jira-service-management-cloud/docs/jql-fields/\n# How to find the ID of a custom field: https://confluence.atlassian.com/jirakb/how-to-find-any-custom-field-s-ids-744522503.html\n# -----------\n###### ** Automation ** ######\n# You may want to update the text in the comment gitStream posts;\n# otherwise, this section shouldn't need to be changed.\nprUrl: \"https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"\nhas_jira_issue: {{ prUrl  | hasJiraIssue(jiraAuth, jiraField, jiraSpaceName, email) }}\nautomations:\nautomatic_jira_task: if:\n- {{ not has_jira_issue }}\n- {{ pr.description | includes(regex=r/\\- \\[x\\] Auto-create Jira Task/)}}\nrun:\n- action: send-http-request@v1\nargs:\nurl: {{ env.JIRA_WEBHOOK }}\nmethod: POST\nheaders: '{\"Content-type\": \"application/json\"}'\nbody: '{\"data\":{\"pr_url\": \"{{ prUrl }}\",\"title\":\"{{ pr.title }}\"}}'\n- action: add-comment@v1\nargs:\ncomment: \"gitStream automatically created a Jira task for this PR\"\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/jira/create-jira-issue/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/jira/jira-assign/","title":"Automatically Assign Jira Tickets","text":"<p>Automatically assign Jira tickets based on code review actions.</p> <p>Jira Webhook Integration Required</p> <p>You need to configure an incoming Jira webhook to use this automation.</p> <p> </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR description contains the slash command: <code>/gitstream assign-jira</code> followed by a Jira username.</li> </ul> <p>Automation Actions:</p> <ul> <li>Trigger a Jira webhook to update the assignee field with the username provided in the slash command.</li> </ul> <p>Automatically Assign Jira Tickets</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nassigneeRegex: r/(?&lt;=\\/gitstream assign-jira ).*(?=&lt;br \\/&gt;)/\n{% set ticketid = \"\" %}\n{% for ticket in tickets %}\n{% if (ticket | includes(regex=r/.+/)) %}\n{% set ticketid = ticket %}\n{% endif %}\n{% endfor %} automations:\njira_assign: if:\n- {{ pr.description | includes(regex=assigneeRegex) }}\nrun:\n- action: send-http-request@v1\nargs:\nurl: \"{{ env.JIRA_WEBHOOK }}}\"\nmethod: POST\nheaders: '{\"Content-type\": \"application/json\"}'\nbody: '{\"issues\":[\"{{ticketid}}\"],\"data\":{\"assignee\":\"{{pr.description | capture(regex=assigneeRegex)}}\"}}'\nhas:\njira_ticket_in_title: {{ pr.title | includes(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\njira_ticket_in_branch: {{ branch.name | includes(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\ntickets:\n- {{branch.name | capture(regex=r/\\b[A-Za-z]+-\\d+\\b/)}}\n- {{pr.title | capture(regex=r/\\b[A-Za-z]+-\\d+\\b/)}}\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/jira/jira-assign/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/jira/jira-change-status/","title":"Automatic Jira Status Updates","text":"<p>Automatically update the status of Jira tickets when a PR is opened.</p> <p>Jira Webhook Integration Required</p> <p>You need to configure an incoming Jira webhook to use this automation.</p> <p> </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created that references a Jira ticket in the title or description.</li> </ul> <p>Automation Actions:</p> <ul> <li>Make an HTTP request to a Jira webhook that is pre-configured to update the ticket status.</li> </ul> <p>Automatic Jira Status Updates</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\n{% set ticketid = \"\\b[A-Za-z]+-\\d+\\b\" %}\n{% for ticket in tickets %}\n{% if (ticket | includes(regex=r/.+/)) %}\n{% set ticketid = ticket %}\n{% endif %}\n{% endfor %} automations:\njira_change_status: if:\n- {{ has.jira_ticket_in_title or has.jira_ticket_in_desc }}\nrun:\n- action: send-http-request@v1\nargs:\nurl: \"{{ env.JIRA_CHANGE_STATUS_WEBHOOK }}\"\nmethod: POST\nheaders: '{\"Content-type\": \"application/json\"}'\nbody: '{\"issues\":[\"{{ticketid}}\"],\"data\":{\"pr_url\":\"https://github.com/{{repo.owner}}/{{repo.name}}/pull/{{pr.number}}\"}}'\nhas:\njira_ticket_in_title: {{ pr.title | includes(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\njira_ticket_in_branch: {{ branch.name | includes(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\ntickets:\n- {{branch.name | capture(regex=r/\\b[A-Za-z]+-\\d+\\b/)}}\n- {{pr.title | capture(regex=r/\\b[A-Za-z]+-\\d+\\b/)}}\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/jira/jira-change-status/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/jira/jira-update-field/","title":"Automatic Jira Updates","text":"<p>Automatically update Jira tickets with pull request information. You can modify this to send any PR metadata to Jira. </p> <p>Jira Webhook Integration Required</p> <p>You need to configure an incoming Jira webhook to use this automation.</p> <p> </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created that contains a Jira ticket reference in the title or branch name.</li> </ul> <p>Automation Actions:</p> <ul> <li>Send a webhook to Jira containing metadata to add to the Issue.</li> </ul> <p>Automatic Jira Updates</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\n{% set ticketid = '' %}\n{% for ticket in tickets %}\n{% if ticket and ticket | length &gt; 0 and ticketid == '' %}\n{% set ticketid = ticket %}\n{% endif %}\n{% endfor %}\nautomations:\njira_update_field: if:\n- {{ has.jira_ticket_in_title or has.jira_ticket_in_branch }}\nrun:\n- action: send-http-request@v1\nargs:\nurl: \"{{ env.JIRA_UPDATE_PR_FIELD_WEBHOOK }}\"\nmethod: POST\nheaders: '{\"Content-type\": \"application/json\", \"X-Automation-Webhook-Token\": \"{{ env.JIRA_UPDATE_PR_FIELD_SECRET }}\"}'\nbody: '{\"issues\":[\"{{ticketid}}\"],\"data\":{\"pr_url\":\"https://github.com/{{repo.owner}}/{{repo.name}}/pull/{{pr.number}}\"}}'\nhas:\njira_ticket_in_title: {{ pr.title | includes(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\njira_ticket_in_branch: {{ branch.name | includes(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\ntickets:\n- {{branch.name | capture(regex=r/\\b[A-Za-z]+-\\d+\\b/)}}\n- {{pr.title | capture(regex=r/\\b[A-Za-z]+-\\d+\\b/)}}\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/jira/jira-update-field/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/jira/label-missing-jira-info/","title":"Label Missing Jira Info","text":"<p>Label PRs that don't reference a Jira ticket in the title or description. This uses regex to detect Jira ticket formats in the title (e.g. ABC-1234), and URLs to Jira tickets in the description.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR lacks a Jira ticket number in the title, or a link to a Jira ticket in the PR description.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>missing-jira</code> label.</li> </ul> <p>Label Missing Jira Info</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_missing_jira_info:\n# Triggered for PRs that don't have either a Jira ticket number in the title,\n# or a link to a Jira ticket in the PR description.\nif:\n- {{ not (has.jira_ticket_in_title or has.jira_ticket_in_desc) }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"missing-jira\"\ncolor: 'F6443B'\nhas:\njira_ticket_in_title: {{ pr.title | includes(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\njira_ticket_in_desc: {{ pr.description | includes(regex=r/atlassian.net\\/browse\\/\\w{1,}-\\d{3,4}/) }}\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/jira/link-jira/","title":"Automatically Link PRs to Related Jira Issues","text":"<p>Provide automatic links to Jira issues that are associated with PRs.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains a reference to an Jira card in the title or branch name.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment that provides a link to the associated Jira Card.</li> </ul> <p>Automatically Link to the Related Jira Card</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nprovider: jira\n# Change this to the name of your Jira organization\norgName: org\n{% set ticketid = \"\" %}\n{% for ticket in tickets %}\n{% if (ticket | includes(regex=r/.+/)) %}\n{% set ticketid = ticket %}\n{% endif %}\n{% endfor %}\nautomations:\nlink_jira:\nif:\n- {{ has.ticket_in_title or has.ticket_in_branch }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: Issue Tracker Link - [{{ticketid}}]({{tracker[provider].baseurl}}{{ticketid}})\nhas:\nticket_in_title: {{ pr.title | includes(regex=tracker[provider].pattern) }}\nticket_in_branch: {{ branch.name | includes(regex=tracker[provider].pattern) }}\ntracker:\njira:\nbaseurl: https://{{orgName}}.atlassian.net/browse/\npattern: r/\\b[A-Za-z]+-\\d+\\b/\ntickets:\n- {{branch.name | capture(regex=tracker[provider].pattern)}}\n- {{pr.title | capture(regex=tracker[provider].pattern)}}\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/jira/link-jira/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/jit/label-jit-alerts/","title":"Label Jit Alerts","text":"<p>Label the number of high, medium, and low risk vulnerabilities Jit reports for PRs.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>Jit reports one or more high, medium, or low risk security vulnerabilities for the PR.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply labels to indicate the number of each type of vulnerability</li> </ul> <p>Label Jit Alerts</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in reports %}\nlabel_jit_{{ item.name }}:\nif:\n- {{ item.count &gt; 0}}\nrun:\n- action: add-label@v1\nargs:\nlabel: 'Jit: {{ item.count }} {{ item.name }} vulnerabilities'\ncolor: {{ colors.red if (item.name == 'high') else (colors.orange if (item.name == 'medium' ) else colors.yellow) }}\n{% endfor %}\njit: {{ pr | extractJitFindings }}\nreports:\n- name: high\ncount: {{ jit.metrics.HIGH }}\n- name: medium\ncount: {{ jit.metrics.MEDIUM }}\n- name: low\ncount: {{ jit.metrics.LOW }}\ncolors:\nred: 'b60205'\norange: 'd93f0b'\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/jit/review-jit-alerts/","title":"Review Jit Security Alerts","text":"<p>Manage review assignment for high and medium risk Jit security alerts.</p> <p></p> <p>Configuration Description</p> <pre><code>**Review Jit High Alerts**\n\n* Conditions (all must be true):\n    * Jit reports one or more high vulnerabilities for the PR\n* Automation Actions:\n    * Require a review from the organization\u2019s security team.\n    * Require 2 reviewers.\n    * Post a comment explaining why this action was taken.\n\n**Review Jit Medium Alerts**\n\n* Conditions (all must be true):\n    * Jit reports one or more medium vulnerabilities for the PR\n* Automation Actions:\n    * Require 2 reviewers\n    * Post a comment explaining why this action was taken.\n</code></pre> <p>Review Jit Security Alerts</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_jit_high_alerts:\nif:\n- {{ jit.metrics.HIGH &gt; 0 }}\nrun:\n- action: require-reviewers@v1\nargs:\nreviewers: [my-organization/security-team]\n- action: set-required-approvals@v1\nargs:\napprovals: 2\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR requires additional review because Jit reported one or more high risk vulnerabilities.\nreview_jit_medium_alerts:\nif:\n- {{ jit.metrics.MEDIUM &gt; 0 }}\nrun:\n- action: set-required-approvals@v1\nargs:\napprovals: 2\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR requires additional reviewers because Jit reported one or more medium risk vulnerabilities.\njit: {{ pr | extractJitFindings }}\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/jit/review-jit-ignore-accept/","title":"Review Jit Ignore and Accept","text":"<p>Notify your Security team when someone ignores a Jit vulnerability report and accepts the risk.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>Someone ignores and accepts a Jit finding</li> </ul> <p>Automation Actions:</p> <ul> <li>Request review from the organization\u2019s security team.</li> <li>Label the PR to indicate someone accepted the risk of a Jit security alert.</li> <li>Post a comment explaining why this action was taken.</li> </ul> <p>Review Jit Ignore and Accept</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_jit_ignore_accept:\nif:\n- {{ pr.conversations | reject(attr='commenter', term='jit-ci') | filter(attr='content', term='#jit_ignore_accept') | some }}\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: [my-organziation/security]\n- action: add-label@v1\nargs:\nlabel: '\u2755 Jit: Ignore - Accept Risk'\n- action: add-comment@v1\nargs:\ncomment: |\nThe security team has been assigned for optional review because this PR ignores a Jit alert and accepts the associated risks.\njit: {{ pr | extractJitFindings }}\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/jit/review-jit-secret/","title":"Review Jit Secret Detection","text":"<p>Close PRs where Jit detects a secret and post a comment explaining steps to remedy the situation.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>Jit detects a secret in the PR.</li> </ul> <p>Automation Actions:</p> <ul> <li>Close the PR</li> <li>Post a comment explaining why this action was taken and to outline the necessary steps to remedy the situation.</li> </ul> <p>Review Jit Security Control</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_jit_secret:\nif:\n- true\n- {{ jit.vulnerabilities | match(attr='security_control', term='Secret Detection') | some }}\nrun:\n- action: add-comment@v1\nargs: comment: |\nJit detects secrets in this PR. Please complete the following steps:\n1. Undo the commit with git reset and remove all secrets from the files you modified.\n2. Deactivate the secret in any locations its used and replace it with a new key\n3. Commit your changes and resubmit your PR.\n- action: close@v1\njit: {{ pr | extractJitFindings }}\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/jsdoc/review-jsdoc/","title":"Review JSDoc Changes","text":"<p>Approve PRs that only contain changes to JSDoc and assign optional reviewers.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR only affects JavaScript and TypeScript files</li> <li>The PR only contains changes to JSDoc content.</li> </ul> <p>Automation Actions:</p> <ul> <li>Assign the <code>ORG/tech-writers</code> team.</li> <li>Apply a green <code>\ud83d\udcd3 JSDoc Only label</code></li> <li>Approve the PR</li> </ul> <p>Review JSDoc</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n#Assign PRs that only affect JSDocs to the technical writing team and add docs label\nreview_jsdoc:\nif:\n- {{ source.diff.files | match(attr='diff', regex=r/\\/*\\*[\\s\\S]*?\\//) | every }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83d\udcd3JSDoc Only\"\ncolor: {{ colors.green }}\n- action: add-reviewers@v1\nargs:\nreviewers: [fourth-organization/tech-writers]\n- action: approve@v1\ncolors:\ngreen: '0e8a16'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/jsdoc/review-jsdoc-input/","title":"Review JSDoc Input Parameters","text":"<p>Warn PR authors when they change JavaScript function or constructor input parameters without updating JSDoc content.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR changes an input parameter in one or more JavaScript methods.</li> <li>The PR lacks changes to \u2018@param\u2019 declarations.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment warning the user to review the method\u2019s JSDoc to identify necessary updates.</li> </ul> <p>Review JSDoc Input Parameters</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_jsdoc_input: if:  - {{ source.diff.files | matchDiffLines(regex=r/.*\\s@param/) | nope }}\n- {{ source.diff.files | matchDiffLines(regex=r/\\((?:.*\\:.*\\))/) | some }}\nrun:\n- action: add-comment@v1\nargs: comment: | This PR appears to modify method input parameters, but is missing JSDoc changes. Please check to ensure no JSDoc changes are necessary.\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/jsdoc/review-jsdoc-large/","title":"Review JSDoc for Large Changes","text":"<p>Require more extensive reviews for large JavaScript changes that lack JSDoc updates.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR changes more than 25% of a JavaScript class.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment asking the author to review all relevant JSDoc to identify necessary updates.</li> <li>Require a review from the <code>ORG/tech-writers</code> team.</li> <li>Apply a yellow <code>\u26a0\ufe0f Missing JSDoc</code> Label</li> </ul> <p>Review JSDoc</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n#Require more extensive reviews for large Javascript changes that lack JSDoc updates.\nreview_jsdoc_large:\nif:\n- {{ changes.ratio &gt; 25}}\n- {{ source.diff.files | matchDiffLines(regex=r/\\/*\\*([\\s\\S]*?)\\//) | nope }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f No JSDoc\"\ncolor: {{ colors.yellow }}\n- action: add-comment@v1\nargs: comment: | This PR makes major changes to JavaScript classes, but is missing updates to JSDoc. Please double check for any necessary JSDoc updates.\n- action: add-reviewers@v1\nargs:\nreviewers: [fourth-organization/tech-writers]\nchanges:\n# Sum all the lines added/edited in the PR\nadditions: {{ branch.diff.files_metadata | map(attr='additions') | sum }}\n# Sum all the line removed in the PR\ndeletions: {{ branch.diff.files_metadata | map(attr='deletions') | sum }}\n# Calculate the ratio of new code\nratio: {{ (changes.additions / (changes.additions + changes.deletions)) * 100 | round(2) }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/jsdoc/review-jsdoc-new-class/","title":"Enforce JSDoc for New JavaScript Classes","text":"<p>Require JSDoc for all new JavaScript classes.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates a new JavaScript class.</li> <li>The PR lacks JSDoc content.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment explaining that JSDoc is required</li> <li>Apply a yellow <code>\u26a0\ufe0f Missing JSDoc</code> label.</li> </ul> <p>Enforce JSDoc for New JavaScript Classes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_jsdoc_new_class: if:  - {{ is.javascript and is.new }} - {{ source.diff.files | matchDiffLines(regex=r/\\/*\\*([\\s\\S]*?)\\//) | nope }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing JSDoc\"\ncolor: {{ colors.yellow }}\n- action: request-changes@v1\nargs: comment: | JSDoc is required for all JavaScript classes. Please add JSDoc to all new classes in this PR.\nis:\njavascript: {{ files | extensions | match(list=['js', 'ts']) | every }}\nnew: {{ source.diff.files | map(attr='original_file') | match(regex=r/^$/) | some }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/launch-darkly/label-ff-launch-darkly/","title":"Label LaunchDarkly Feature Flags","text":"<p>Automatically label code that contians specified feature flags.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR adds one or more feature flag keys.</li> </ul> <p>Automation Actions:</p> <ul> <li>Label the PR for each feature flag key introduced in the PR.</li> </ul> <p>Label PRs Based on Feature Flags</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in feature_flags %}\nlabel_ff_launchdarkly_{{ item.name }}:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/var flagValue = ldclient/) | some }}\n- {{ source.diff.files | matchDiffLines(regex=item.regex) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: {{ item.name }}\ncolor: {{ colors.yellow }}\n{% endfor %}\nfeature_flags:\n- name: engineering_rollback_plan_activated regex: r/engineering_rollback_plan_activated/\n- name: marketing_premium_plan_features_unlocked regex: r/marketing_premium_plan_features_unlocked/\n- name: mobile_push_notifications_enabled\nregex: r/mobile_push_notifications_enabled/\ncolors:\nyellow: 'ffb300'   </code></pre>  Download this example as a CM file."},{"location":"automations/integrations/orca/label-orca-scan-results/","title":"Auto-Label Orca Scan Results","text":"<p>Automatically apply labels to PRs that indicate the result of Orca Security scans.</p> <p>Required gitStream Plugin</p> <p>This example requires you to install the <code>extractOrcaFindings</code> plugin.</p> <p>Learn more about gitStream plugins.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>Orca Security detects one or more issues with the code in the PR.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a label that indicates which issue was identified.</li> </ul> <p>Auto-Label Orca Scan Results</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in reports %}\nlabel_orca_{{ item.name }}:\nif:\n- {{ item.count &gt; 0 }}\nrun:\n- action: add-label@v1\nargs:\nlabel: 'orca:{{ item.name }}'\n{% endfor %}\norca: {{ pr | extractOrcaFindings }}\nreports:\n- name: introduced-cves\ncount: {{ orca.vulnerabilities.count }}\n- name: iac-misconfigurations\ncount: {{ orca.infrastructure_as_code.count }}\n- name: exposed-secrets count: {{ orca.secrets.count }}\ncolors:\nred: 'b60205'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/orca/label-orca-scan-results/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/orca/review-orca-alerts/","title":"Require Security Review for Orca Alerts","text":"<p>Automatically require review from your SecOps team for Orca Security violations in pull requests.</p> <p> </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains a vulnerability, IAC problem, or secret that is flagged as High or Medium.</li> </ul> <p>Automation Actions:</p> <ul> <li>Require review from your organization's security team.</li> <li>Post a comment explaining the requirement.</li> </ul> <p>Review Orca Security Alerts</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_orca_alerts:\nif:\n- {{ has.vulnerability or has.iac_violation or has.secret }}\nrun:\n- action: require-reviewers@v1\nargs:\nreviewers: [my-organization/security-team]\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR requires additional review because it fails to meet Orca Security safe code standards.\norca: {{ pr | extractOrcaFindings }}\nhas:\nvulnerability: {{ orca.vulnerabilities.priority == 'High' or orca.vulnerabilities.priority == 'Medium' }}\niac_violation: {{ orca.infrastructure_as_code.priority == 'High' or orca.infrastructure_as_code.priority == 'Medium' }}\nsecret: {{ orca.secrets.priority == 'High' or orca.secrets.priority == 'Medium' }}\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/orca/review-orca-alerts/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/rdoc/review-rdoc/","title":"Automatically Approve RDoc Changes","text":"<p>Approve PRs that only contain changes to RDoc and assign optional reviewers.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR only contains changes to RDoc content.</li> </ul> <p>Automation Actions:</p> <ul> <li>Assign the org/tech-writers team for optional review.</li> <li>Apply a green <code>\ud83d\udcd3 RDoc Only</code> label</li> <li>Approve the PR</li> </ul> <p>Review RDoc</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_rdoc:\nif:\n- {{ source.diff.files | match(attr='diff', regex=r/^[\\s\\t]*#.*/) | every }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83d\udcd3RDoc Only\"\ncolor: {{ colors.green }}\n- action: add-reviewers@v1\nargs:\nreviewers: [org/tech-writers]\n- action: approve@v1\ncolors:\ngreen: '0e8a16'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/rdoc/review-rdoc-input/","title":"Review RDoc Input Parameters","text":"<p>Warn PR authors when they change Ruby function or constructor input parameters without updating RDoc content.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR changes one or more input parameters in Ruby methods.</li> <li>The PR lacks RDoc updates.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment warning the user to review the method\u2019s RDoc to identify necessary updates.</li> </ul> <p>Review RDoc Input Parameters</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_rdoc_input: if:  - {{ source.diff.files | match(attr='diff', regex=r/(\\#.*\\n.*)*def/) | nope }}\n- {{ source.diff.files | match(attr='diff', regex=r/def.*\\(.*\\)/ | some }}\nrun:\n- action: add-comment@v1\nargs: comment: | This PR modifies method input parameters, but is missing RDoc changes. Please check to ensure no RDoc changes are necessary.\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/rdoc/review-rdoc-large/","title":"Review RDoc for Large Changes","text":"<p>Require more extensive reviews for large Ruby changes that lack RDoc updates.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR changes more than 150 lines of Ruby code.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment asking the author to review all relevant RDoc to identify necessary updates.</li> <li>Require a review from the <code>ORG/tech-writers</code> team.</li> <li>Apply a yellow <code>\u26a0\ufe0f Missing RDoc</code> Label</li> </ul> <p>Review RDoc</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n#Require more extensive reviews for large Ruby changes that lack RDoc updates.\nreview_rdoc_large:\nif:\n- {{ changes.additions &gt; 150}}\n- {{ source.diff.files | matchDiffLines(regex=r/(\\#.*\\n.*)*def/) | nope }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing RDoc\"\ncolor: {{ colors.yellow }}\n- action: add-comment@v1\nargs: comment: | This PR makes major changes to Ruby methods, but is missing updates to RDoc. Please double check for any necessary RDoc updates.\n- action: add-reviewers@v1\nargs:\nreviewers: [fourth-organization/tech-writers]\nchanges:\n# Sum all the lines added/edited in the PR\nadditions: {{ branch.diff.files_metadata | map(attr='additions') | sum }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/rdoc/review-rdoc-new-class/","title":"Enforce RDoc for New Ruby Classes","text":"<p>Require RDoc for all new Ruby classes.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates a new Ruby class.</li> <li>The PR lacks RDoc content.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment explaining that RDoc is required</li> <li>Apply a yellow <code>\u26a0\ufe0f Missing RDoc</code> label.</li> </ul> <p>Enforce RDoc for New Ruby Classes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_rdoc_new_class: if:  - {{ is.rb and is.new }} - {{ source.diff.files | match(attr='diff', regex=r/(\\#.*\\n.*)*def/) | nope }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing RDoc\"\ncolor: {{ colors.yellow }}\n- action: add-comment@v1\nargs: comment: | RDoc is required for all Ruby classes. Please add documentation for this PR.\nis:\nrb: {{ files | extensions | match(regex=r/rb/) | every }}\nnew: {{ source.diff.files | map(attr='original_file') | match(regex=r/^$/) | some }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/renovate/approve-renovate/","title":"Approve and Merge Renovate Changes","text":"<p>Auto-merge Renovate PRs</p> By Release TypeAll Updates <p>Required gitStream Plugins</p> <p>This example requires you to install the <code>extractRenovateVersionBump</code>, <code>compareMultiSemver</code> and <code>compareSemver</code> plugins.</p> <p>Learn more about gitStream plugins.</p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR author is Renovate.</li> <li>The branch name includes 'renovate'</li> <li>The dependency change is a patch or minor update.</li> </ul> <p>Automation Actions:</p> <ul> <li>Approve the PR</li> <li>Apply an <code>approved-renovate</code> label to the PR</li> <li>Merge the PR if all status checks pass.</li> </ul> <p>Configuration Example</p> <p><pre><code>manifest:\nversion: 1.0\nautomations:\nmerge_renovate_minor:\nif:\n- {{ bump == 'minor' }}\n- {{ branch.name | includes(term=\"renovate\") }}\n- {{ branch.author | includes(term=\"renovate\") }}\nrun:\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nRenovate `minor` version bumps are approved automatically.\nmerge_renovate_minor_patch:\nif:\n- {{ bump == 'patch' }}\n- {{ branch.name | includes(term=\"renovate\") }}\n- {{ branch.author | includes(term=\"renovate\") }}\nrun:\n- action: approve@v1\n- action: merge@v1\n- action: add-comment@v1\nargs:\ncomment: |\nRenovate `patch` version bumps are approved and merged automatically.\nbump: {{ pr.description | extractRenovateVersionBump | compareMultiSemver }}\n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR author is Renovate.</li> <li>The branch name includes 'renovate'</li> </ul> <p>Automation Actions:</p> <ul> <li>Approve the PR</li> <li>Apply an <code>approved-renovate</code> label to the PR</li> <li>Merge the PR if all status checks pass.</li> </ul> <p>Configuration Example</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_renovate:\nif:\n- {{ branch.author | includes(term=\"renovate\") }}\nrun:\n- action: approve@v1\n- action: add-label@v1\nargs:\nlabel: \"approved-renovate\"\n- action: merge@v1\nargs:\nwait_for_all_checks: true\nsquash_on_merge: true\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/integrations/shortcut/label-missing-shortcut/","title":"Label Missing Shortcut","text":"<p>Automatically label PRs that are missing references to Shortcut resources.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR is missing one of the following:<ul> <li>An Shortcut ticket reference in the PR title.</li> <li>A link to an Shortcut resource in the PR description.</li> </ul> </li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a red <code>\u26a0\ufe0f Missing Shortcut Link</code> label</li> <li>Post a comment that asks the author to add an Shortcut reference to the PR.</li> </ul> <p>Label Missing Shortcut</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_missing_shortcut:\nif:\n- {{not (has.shortcut.ticket_in_title or has.shortcut.ticket_in_desc)}}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Shortcut Link\"\ncolor: {{ colors.red }}\n- action: add-comment@v1\nargs:\ncomment: Please provide a link to the associated Shortcut resource.\nhas:\nshortcut:\nticket_in_title: {{ pr.title | includes(regex=r/(\\w+)\\/sc-(\\d+)/) }}\nticket_in_desc: {{ pr.description | includes(regex=r/(app\\.shortcut\\.com)\\/(\\w+)\\/story\\/(\\d+)\\/(\\w+)/) }}\ncolors:\nred: 'b60205'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/shortcut/label-missing-shortcut/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/shortcut/link-shortcut/","title":"Automatically Link PRs to Related Shortcut Tasks","text":"<p>Provide automatic links to Shortcut tasks that are associated with PRs.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains a reference to an Shortcut card in the title or branch name.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment that provides a link to the associated Shortcut Task.</li> </ul> <p>Automatically Link to the Related Shortcut Task</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\n# Configure these to match your organization.\nprovider: jira\n# Change this to match the name of your Shortcut organization. This is used in tracker.shortcut.baseurl\norgName: org\n{% set ticketid = \"\" %}\n{% for ticket in tickets %}\n{% if (ticket | includes(regex=r/.+/)) %}\n{% set ticketid = ticket %}\n{% endif %}\n{% endfor %}\nautomations:\nlink_shortcut:\nif:\n- {{ has.ticket_in_title or has.ticket_in_branch }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: Issue Tracker Link - [{{ticketid}}]({{tracker[provider].baseurl}}{{ticketid}})\nhas:\nticket_in_title: {{ pr.title | includes(regex=tracker[provider].pattern) }}\nticket_in_branch: {{ branch.name | includes(regex=tracker[provider].pattern) }}\ntracker:\nshortcut:\nbaseurl: https://app.shortcut.com/{{orgName}}/story/\npattern: r/(\\w+)\\/sc-(\\d+)/\ntickets:\n- {{branch.name | capture(regex=tracker[provider].pattern)}}\n- {{pr.title | capture(regex=tracker[provider].pattern)}}\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/shortcut/link-shortcut/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/slack/slack-auto-recognition/","title":"Automatic Slack Messages","text":"<p>Automatically post positive recognition messages in Slack for well-structured PRs.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains updates to tests.</li> <li>The PR has fewer than 5 modified files.</li> <li>The PR branch references a Jira ticket.</li> <li>The PR has fewer than 150 lines of code changed.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a Slack message that automatically recognizes the PR author and provides a link to the PR.</li> </ul> <p>Automatic Slack Messages</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nslack_auto_recognition:\nif:\n- {{ files | match(regex=r/(test|spec)/) | some }} # this pr has at least 1 test\n- {{ files | length &lt;= 5 }} # this pr has 5 or less files\n- {{ branch.name | includes(regex=r/[A-Z]{2,}-\\d+.*/) }} # this branch has the Jira ticket prefix\n- {{ branch.diff.size &lt;= 150 }} # this branch has 150 lines of code or less changed\nrun:\n- action: send-slack-message@v1\nargs:\nwebhook_url: \"{{ env.SLACK_WEBHOOK }}\"\nmessage: \":tada: Congrats to {{ pr.author }} for the amazing new PR, '{{ pr.title }}'! Check it out at https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/slack/slack-auto-recognition/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/slack/slack-send-notification/","title":"Send Slack Notifications","text":"<p>Automatically send Slack notifications to specific channels based on the contents of a pull request.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR meets one or more of the specified trigger criteria for Slack notifications.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a Slack message based on the contents of the PR.</li> </ul> <p>Send Slack Notifications</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nsend_slack_security:\n# use your custom logic here to determine whether this needs a security review\nif:\n- true\nrun:\n- action: send-slack-message@v1\nargs:\nwebhook_url: \"{{ env.SLACK_WEBHOOK_SECURITY }}\"\nmessage: \"A PR requires a security review. See https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"\nsend_slack_qa:\n# use your custom logic here to determine whether this needs a qa review\nif:\n- {{ not (files | match(regex=r/(test|spec)/) | some) }}\nrun:\n- action: send-slack-message@v1\nargs:\nwebhook_url: \"{{ env.SLACK_WEBHOOK_QA }}\"\nmessage: \"A PR was submitted without tests. See https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"\nsend_slack_docs:\n# use your custom logic here to determine whether this needs a docs review\nif:\n- {{ files | match(regex=r/(docs)/) | some }}\nrun:\n- action: send-slack-message@v1\nargs:\nwebhook_url: \"{{ env.SLACK_WEBHOOK_DOCS }}\"\nmessage: \"A PR has modified the docs. See https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/slack/slack-send-notification/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/snyk/approve-snyk/","title":"Approve and Merge Snyk Changes","text":"<p>Approve PRs from Snyk</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR author is Snyk.</li> </ul> <p>Automation Actions:</p> <ul> <li>Approve the PR</li> <li>Apply an <code>approved-snyk</code> label to the PR</li> <li>Merge the PR if all status checks pass.</li> </ul> <p>Approve Snyk</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_snyk:\nif:\n- {{ branch.author | includes(term=\"snyk\") }}\nrun:\n- action: approve@v1\n- action: add-label@v1\nargs:\nlabel: \"approved-snyk\"\n- action: merge@v1\nargs:\nwait_for_all_checks: true\nsquash_on_merge: true\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/sonar/approve-sonar-clean-code/","title":"Approve Sonar Clean Code","text":"<p>Approve PRs that pass SonarCloud's quality gate.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>SonarCloud reports an 'A' rating for vulnerabilities, bugs, security hotspots, and code smells.</li> <li>There is no duplicated code.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>Sonar: Clean Code</code> label to the PR.</li> <li>Approve the PR.</li> <li>Post a comment that explains why the PR was approved.</li> </ul> <p>Aprove Sonar Clean Code</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_sonar_clean_code:\nif:\n- {{ sonar.bugs.rating == 'A' }}\n- {{ sonar.code_smells.rating == 'A' }}\n- {{ sonar.vulnerabilities.rating == 'A' }}\n- {{ sonar.security_hotspots.rating == 'A' }}\n- {{ sonar.duplications == null or sonar.duplications == 0 }}\nrun: - action: add-label@v1\nargs:\nlabel: '\u2705 Sonar: Clean Code'\ncolor: {{ colors.green }}\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR passes the SonarCloud quality gate check and as been automatically approved.\nsonar: {{ pr | extractSonarFindings }}\ncolors:\ngreen: '0e8a16'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/sonar/label-sonar/","title":"Label SonarCloud Quality Reports","text":"<p>Label the number of bugs, vulnerabilities, security hotspots, and code smells reported by SonarCloud.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>There is at least one vulnerability, code smell, security hotspot, or bug reported by SonarCloud. Uses the <code>extractSonarFindings</code> filter function</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply color-coded labels to indicate the number of vulnerabilities, code smells, security hotspots, and bugs.</li> </ul> <p>Label SonarCloud Quality Reports</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in reports %}\nlabel_sonar_{{ item.name }}:\nif:\n- {{ item.count &gt; 0}}\nrun:\n- action: add-label@v1\nargs:\nlabel: '{{ item.icon }} sonar:{{ item.name }}-{{ item.rating }}'\ncolor: {{ colors.red if (item.rating == 'E' or item.rating == 'D') else (colors.orange if (item.rating == 'C' ) else colors.yellow) }}\n{% endfor %}\nsonar: {{ pr | extractSonarFindings }}\nreports:\n- name: vulnerabilities\ncount: {{ sonar.vulnerabilities.count }}\nicon: \ud83d\udd13\nrating: {{ sonar.vulnerabilities.rating }}\n- name: code_smells\ncount: {{ sonar.code_smells.count }}\nicon: \u2623\ufe0f\nrating: {{ sonar.code_smells.rating }}\n- name: security_hotspots\ncount: {{ sonar.security_hotspots.count }}\nicon: \ud83d\udee1\ufe0f\nrating: {{ sonar.security_hotspots.rating }}\n- name: bugs\ncount: {{ sonar.bugs.count }}\nicon: \ud83e\udeb2\nrating: {{ sonar.bugs.rating }}\ncolors:\nred: 'b60205'\norange: 'd93f0b'\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/sonar/review-sonar-alerts/","title":"Review Sonar Security Alerts","text":"<p>Require additional reviews for Sonar security alerts. gitStream will remove this requirement if the alerts are resolved.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The SonarCloud quality gate check fails to pass for code smells, vulnerabilities, or security hotspots.</li> </ul> <p>Automation Actions:</p> <ul> <li>Require a review from the <code>my-organization/security-team</code> team. Customize this to match your organization.</li> <li>Post a comment explaining why this PR requires additional review.</li> </ul> <p>Review Sonar Alerts</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_sonar_alerts:\nif:\n- {{ sonar.code_smells.rating != 'A' or sonar.vulnerabilities.rating != 'A' or sonar.security_hotspots.rating != 'A'}}\nrun:\n- action: require-reviewers@v1\nargs:\nreviewers: [my-organization/security-team]\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR requires additional review because it fails to meet SonarCloud clean code standards.\nsonar: {{ pr | extractSonarFindings }}\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/sonar/review-sonar-duplications/","title":"Review Sonar Duplications","text":"<p>Request changes when Sonar reports an excessive level of duplicated code.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains more than 3% duplicated code.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a label that indicates how much duplicated code Sonar detected.</li> <li>Request changes and post a comment explaining why.</li> </ul> <p>Review Sonar Duplications</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_sonar_duplications:\nif:\n- {{ sonar.duplications &gt; 3 }}\nrun: - action: add-label@v1\nargs:\nlabel: 'Sonar: {{ sonar.duplications}}% duplication'\ncolor: {{ colors.yellow }}\n- action: request-changes@v1\nargs:\ncomment: |\nSonar reports an excessive level of code duplication. Please consider refactoring your PR to reduce duplications.\nsonar: {{ pr | extractSonarFindings }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/swimm/approve-swimm/","title":"Approve Swimm Changes","text":"<p>Approve changes that only affect Swimm documentation.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR only affects files that end in a <code>.swm</code> extension.</li> </ul> <p>Automation Actions:</p> <ul> <li>Add a <code>swimm-docs-only</code> label</li> <li>Approve the PR</li> <li>Post a comment that explains that this is a Swimm docs change only.</li> </ul> <p>Approve Swimm Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_swimm_changes:\n# Triggered for any changes to Swimm documentation\nif:\n- {{ branch.diff.files_metadata | match(attr='file', regex=r/\\.swm\\//) | every }}\n# Apply a swimm-docs-only label, approve the PR and explain why in a comment.\nrun: - action: add-label@v1\nargs:\nlabel: 'swimm-docs-only'\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR is considered a safe change as it only affects Swimm Docs. \nIt has been automatically approved.\n</code></pre>  Download this example as a CM file. <p>Special thanks to Omerr for providing this example. </p>"},{"location":"automations/integrations/teams/teams-auto-recognition/","title":"Automatic MS Teams Notifications","text":"<p>Automatically post positive recognition messages in MS Teams for well-structured PRs.</p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains updates to tests.</li> <li>The PR has fewer than 5 modified files.</li> <li>The PR branch references a Jira ticket.</li> <li>The PR has fewer than 150 lines of code changed.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post an MS Teams message that automatically recognizes the PR author and provides a link to the PR.</li> </ul> <p>Automatic MS Teams Notifications</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nteams_auto_recognition:\nif:\n- {{ files | match(regex=r/(test|spec)/) | some }} # this pr has at least 1 test\n- {{ files | length &lt;= 5 }} # this pr has 5 or less files\n- {{ branch.name | includes(regex=r/[A-Z]{2,}-\\d+.*/) }} # this branch has the Jira ticket prefix\n- {{ branch.diff.size &lt;= 150 }} # this branch has 150 lines of code or less changed\nrun:\n- action: send-http-request@v1\nargs:\nmethod: \"POST\"\nheaders: '{\"Content-type\": \"application/json\"}'\nurl: \"{{ env.MS_TEAMS_WEBHOOK }}\"\nbody: '{\"text\": \"Congrats to {{ pr.author }} for the amazing new PR, {{ pr.title }}! Check it out at https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"}'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/teams/teams-auto-recognition/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/teams/teams-send-notification/","title":"Automatically Notify MS Teams Channels","text":"<p>Automatically send Slack notifications to specific channels based on the contents of a pull request.</p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR meets one or more of the specified trigger criteria for MS Teams notifications.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post an MS Teams message based on the contents of the PR.</li> </ul> <p>Automatically Notify MS Teams Channels</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nsend_teams_security:\nif:\n# use your custom logic here to determine whether this needs a security review\n- true\nrun:\n- action: send-http-request@v1\nargs:\nmethod: \"POST\"\nheaders: '{\"Content-type\": \"application/json\"}'\nurl: \"{{ env.MS_TEAMS_WEBHOOK_SECURITY }}\"\nbody: '{\"text\": \"A PR requires a security review. See https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"}'\nsend_teams_qa:\nif:\n# use your custom logic here to determine whether this needs a qa review\n- {{ not (files | match(regex=r/(test|spec)/) | some) }}\nrun:\n- action: send-http-request@v1\nargs:\nmethod: \"POST\"\nheaders: '{\"Content-type\": \"application/json\"}'\nurl: \"{{ env.MS_TEAMS_WEBHOOK_QA }}\"\nbody: '{\"text\": \"A PR was submitted without tests. See https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"}'\nsend_teams_docs:\nif:\n# use your custom logic here to determine whether this needs a docs review\n- {{ files | match(regex=r/(docs)/) | some }}\nrun:\n- action: send-http-request@v1\nargs:\nmethod: \"POST\"\nheaders: '{\"Content-type\": \"application/json\"}'\nurl: \"{{ env.MS_TEAMS_WEBHOOK_DOCS }}\"\nbody: '{\"text\": \"A PR has modified the docs. See https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"}'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/teams/teams-send-notification/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/terraform/review-new-module/","title":"Review New Terraform Modules","text":"<p>Request changes if a PR that creates a new Terraform module which do not conform to the required directory structure.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates a new Terraform module<ul> <li>A new sub-directory is created inside the <code>/modules</code> directory.</li> </ul> </li> <li>The PR lacks one or more required components from the list in the terraform custom expression.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment explaining the missing parts of the module.</li> <li>Apply Label : <code>\u26a0\ufe0f Missing Terraform Components</code></li> </ul> <p>Review New Module</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\n{% set misslist = [] %}\n{% for pattern in terraform %}\n{% if (newfilesinpr | match(term=pattern) | nope) %}\n{% set misslist = misslist + [pattern+' '] %}\n{% endif %}\n{% endfor %} automations:\nreview_new_terraform_module:\nif: - {{misslist | match(regex=r/.*/) | some}}\n- {{is.mainfile and is.mainfilenotinroot }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nNew terraform modules must contain all required components before merging. Please update your PR with the required components and gitStream will automatically remove this comment once completed.\nHere are the required components, {{misslist}} should be customized appropriately:\nmy_module/\n\u251c\u2500\u2500 main.tf\n\u251c\u2500\u2500 outputs.tf\n\u251c\u2500\u2500 providers.tf\n- action: add-label@v1\nargs:\nlabel: '\u26a0\ufe0f Missing Terraform Components'\ncolor: '#FFA500'\nresources:\nmodule_directory: 'modules'\nterraform:\n- main.tf\n- outputs.tf\n- providers.tf\nis:\nmainfile: {{newfilesinpr | match(term = \"main.tf\") | some}}\nmainfilenotinroot: {{source.diff.files | map(attr='original_file') | match(term = \"main.tf\") | nope }}\nnewfilesinpr:\n{{ branch.diff.files_metadata | map(attr='new_file')}}\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/terraform/review-terraform/","title":"Require Reviewers for Terraform changes","text":"<p>Automatically assign <code>org/infrastructure</code> team for reviewing changes when PR contains Terraform file changes.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains changes to one or more Terraform configuration files.</li> </ul> <p>Automation Actions:</p> <ul> <li>Require a review from the org/infrastructure team.</li> </ul> <p>Review Terraform Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_terraform:\n# Triggered for any changes to Terraform files\nif:\n- {{ files | match(regex=r/.*\\.tf.*/) | some }}\n# Assign infrastructure team as reviewer for change in Terraform files\nrun:\n- action: require-reviewers@v1\nargs:\nreviewers: [org/infrastructure]\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR affects Terraform configurations and requires a review from the Infra team.\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/terraform/review-terraform-module-name/","title":"Review Terraform Module Name","text":"<p>Request changes if a PR creates a new Terraform module that is missing a required prefix or keyword in the name.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates a new Terraform module.</li> <li>The module name lacks a required name prefix, or one or more keywords.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request review changes on the PR with a comment explaining the structure of module name.</li> </ul> <p>Review Terraform Module Name</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\n# Prefix Check Logic\n{% set prefixcheck = [] %}\n{% for pattern in terraform.prefixes %}\n{% if(newfilesinpr | match(term=module_location + pattern) | some) %}\n{% set prefixcheck = prefixcheck + [true]%}\n{% else %}\n{% set prefixcheck = prefixcheck + [false]  %}\n{% endif %}\n{% endfor %}\nautomations:\nreview_terraform_module_name:\nif:\n- {{is.mainfile and is.mainfilenotinroot}}\n- {{module_name_checks.prefix or module_name_checks.keyword}}\nrun:\n- action: request-changes@v1\nargs:\ncomment: |\nTerraform module names must contain a required prefix and keyword:\n* Prefixes: {{ terraform.prefixes }}\n* Keywords: {{ terraform.keywords }}\nmodule_name_checks:\nprefix: {{prefixcheck | match(term='true') | nope}}\nkeyword: {{newfilesinpr | match(list=terraform.keywords) | nope}}\nmodule_location: infrastructure/modules/\nterraform:\nprefixes: ['aws', 'gcp', 'azure']\nkeywords: ['db', 'networking', 'security']\nis:\nmainfile: {{newfilesinpr | match(term = \"main.tf\") | some}}\nmainfilenotinroot: {{source.diff.files | map(attr='original_file') | match(term = \"main.tf\") | nope }}\nnewfilesinpr:\n{{ branch.diff.files_metadata | map(attr='new_file')}}\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/terraform/review-terraform-source-version/","title":"Review Terraform Source Version","text":"<p>Ensure that all Terraform modules imported via a source URL specify a version.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains a Terraform source declaration via URL that lacks a version reference.</li> <li>The source is not included in a whitelist custom expression that defines one or more whitelisted source locations.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request review changes on the PR with a comment explaining version number requirement.</li> </ul> <p>Review Terraform Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_terraform_source_version:\n# Check if New Content contains a source URL, the URL is not part of allow list and lacks version reference\nif: - {{ source.diff.files | match(attr='new_content', regex=r/source.*?=.*\\\".*(http|https).*\\\"/) | some }}\n- {{ source.diff.files | match(attr='new_content', list=allowlist) | nope }}\n- {{ source.diff.files | match(attr='new_content', regex=r/source.*?=.*\\?ref=v.*/) | nope }}\nrun:\n- action: request-changes@v1\nargs:\ncomment: |\nYou must reference a specific version when accessing Terraform module sources via URL, e.g. `?ref=v1.0.0`. Please update your Terraform files to follow this practice.\nallowlist:\n- 'https://github.com/terraform-aws-modules/terraform-aws-s3-bucket.git'\n- 'https://github.com/terraform-aws-modules/terraform-aws-vpc.git'\n- 'https://github.com/terraform-aws-modules/terraform-aws-eks.git'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/unleash/label-ff-unleash/","title":"Label Unleash Feature Flags","text":"<p>Automatically label code that contians specified feature flags.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR adds one or more feature flag keys.</li> </ul> <p>Automation Actions:</p> <ul> <li>Label the PR for each feature flag key introduced in the PR.</li> </ul> <p>Label PRs Based on Feature Flags</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in feature_flags %}\nlabel_ff_unleash_{{ item.name }}:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/const notificationBadgeEnabled = useFlag/) | some }}\n- {{ source.diff.files | matchDiffLines(regex=item.regex) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: {{ item.name }}\ncolor: {{ colors.yellow }}\n{% endfor %}\nfeature_flags:\n- name: engineering_rollback_plan_activated regex: r/engineering_rollback_plan_activated/\n- name: marketing_premium_plan_features_unlocked regex: r/marketing_premium_plan_features_unlocked/\n- name: mobile_push_notifications_enabled\nregex: r/mobile_push_notifications_enabled/\ncolors:\nyellow: 'ffb300'   </code></pre>  Download this example as a CM file."},{"location":"automations/integrations/windsurf/flag-windsurf-pr/","title":"Automatically Label Windsurf PRs","text":"<p>Automatically apply labels to PRs that are assisted by Windsurf. You can apply labels based on a known list of Windsurf users, PR tags, or by prompting the PR author to indicate if they used Windsurf.</p> Label by PromptLabel by Known UsersLabel by Tag <p>Prompt PR authors to indicate if they used Windsurf for the PR and automatically label the PR if they did. This requires two separate automation files to handle posting the prompt and labeling accordingly.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is created</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment prompting the author to indicate if Windsurf assisted the author with writing the code in the PR.</li> </ul> <p>Ask the PR author about Windsurf usage</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\nautomations:\ncomment_windsurf_prompt:\n# Post a comment for all PRs to prompt the PR author to indicate whether they used Windsurf to assist coding in this PR\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nPlease mark whether you used Windsurf to assist coding in this PR\n- [ ] Windsurf Assisted\n- [ ] Not Windsurf Assisted \n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is updated or merged where the author indicates they used Windsurf via a prompt.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Windsurf</code> label to the PR</li> </ul> <p>Label PRs where the user indicated Windsurf usage</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n# You should use this automation in conjunction with comment_windsurf_prompt.cm\nlabel_windsurf_pr:\n# If the PR author has indicated that they used Windsurf to assist coding in this PR, \n# apply a label indicating the PR was supported by Windsurf\nif:\n- {{ pr.comments | filter(attr='commenter', term='gitstream-cm') | filter (attr='content', regex=r/\\- \\[x\\] Windsurf Assisted/) | some}}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Windsurf' </code></pre>  Download this example as a CM file. </p> <p>Automatically apply labels to PRs that are created by known users of generative AI coding tools.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The PR author is one of a specified list of contributors</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Windsurf</code> label to the PR</li> </ul> <p>Label by Contributors</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_windsurf_contributors:\n# For all PRs authored by someone who is specified in the windsurf_contributors list\nif:\n- {{ pr.author | match(list=windsurf_contributors) | some }}\n# Apply a label indicating the user has adopted Windsurf\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Windsurf'\nwindsurf_contributors:\n- username1\n- username2\n- etc </code></pre>  Download this example as a CM file. </p> <p>Look for a specific tag in the PR title, description, comments or commit messages and if found add a label to the PR</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The <code>#windsurf#</code> tag is found in any of the PR title, description, comments or commit messages for commits in the PR</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Windsurf</code> label to the PR</li> </ul> <p>Label Windsurf by Tag</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- comment_added\n- commit\n- pr_created\nautomations:\nlabel_windsurf:\n# Detect PRs that contain the text '#windsurf#' in the title, description, comments, or commit messages\nif:\n- {{ windsurf_tag.pr_title or windsurf_tag.pr_desc or windsurf_tag.pr_comments or windsurf_tag.commit_messages }}\n# Apply a label indicating the user has adopted Windsurf\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Windsurf'\nwindsurf_tag:\npr_title: {{ pr.title | includes(regex=r/#windsurf#/) }}\npr_desc: {{pr.description | includes(regex=r/#windsurf#/) }}\npr_comments: {{ pr.comments | map(attr='content') | match(regex=r/#windsurf#/) | some }}\ncommit_messages: {{ branch.commits.messages | match(regex=r/#windsurf#/) | some }} </code></pre>  Download this example as a CM file. </p>"},{"location":"automations/integrations/zapier/zapier-export-pr-description-title-url/","title":"Create Project Management Tasks Via Zapier","text":"<p>Export new PR titles, description, and URL to Zapier.</p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created.</li> </ul> <p>Automation Actions:</p> <ul> <li>gitStream sends a webhook to Zapier that contains the PR title, description, and URL.</li> </ul> <p>Create Project Management Tasks Via Zapier</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\npr_url: \"https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"\non:\n- pr_created\nautomations:\nzapier_export_pr_description_title_url:\nif:\n- true\nrun:\n- action: send-http-request@v1\nargs:\nurl: \"{{ ZAPIER_WEBHOOK }}\"\nmethod: POST\nheaders: '{\"Content-type\": \"application/json\"}'\nbody: '{ \"pr_description\":\"{{ pr.description }}\", \"pr_title\":\"{{ pr.title }}\", \"pr_url\":\"{{ pr_url }}\" }'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/zapier/zapier-export-pr-description-title-url/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/zapier/zapier-export-pr-number/","title":"Export PR Data to Zapier","text":"<p>This is an example of how to send data from gitStream to Zapier.</p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created.</li> </ul> <p>Automation Actions:</p> <ul> <li>gitStream sends a webhook to Zapier that contains the PR number</li> </ul> <p>Export PR Number to Zapier</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nzapier_export_pr_number:\nif:\n- true\nrun:\n- action: send-http-request@v1\nargs:\nurl: \"{{ ZAPIER_WEBHOOK }}\"\nmethod: POST\nheaders: '{\"Content-type\": \"application/json\"}'\nbody: '{ \"pr_number\":\"{{ pr.number }}\" }'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/zapier/zapier-export-pr-number/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/zapier/zapier-export-pr-number-title-url/","title":"Export PR Number, Title, and URL to Zapier","text":"<p>Export new PR titles, numbers, and URLs to Zapier.</p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created.</li> </ul> <p>Automation Actions:</p> <ul> <li>gitStream sends the PR number, title, and URL to Zapier via webhook.</li> </ul> <p>Export PR Number, Title, and URL to Zapier</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\npr_url: \"https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"\non:\n- pr_created\nautomations:\nzapier_export_pr_number_title_url:\nif:\n- true\nrun:\n- action: send-http-request@v1\nargs:\nurl: \"{{ ZAPIER_WEBHOOK }}\"\nmethod: POST\nheaders: '{\"Content-type\": \"application/json\"}'\nbody: '{ \"pr_number\":\"{{ pr.number }}\", \"pr_title\":\"{{ pr.title }}\", \"pr_url\":\"{{ pr_url }}\" }'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/zapier/zapier-export-pr-number-title-url/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/integrations/zapier/zapier-export-pr-reviewers/","title":"Auto-Schedule Sync Meetings via Zapier","text":"<p>Automatically update Zapier with a list of PR reviewers.</p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created or updated.</li> </ul> <p>Automation Actions:</p> <ul> <li>gitStream sends the list of reviewers to Zapier via webooks.</li> </ul> <p>Auto-Schedule Sync Meetings via Zapier</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\npr_url: \"https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"\nautomations:\nzapier_export_pr_reviewers:\nif:\n- true\nrun:\n- action: send-http-request@v1\nargs:\nurl: \"{{ env.ZAPIER_WEBHOOK }}\"\nmethod: \"POST\"\nheaders: '{\"Content-type\": \"application/json\"}'\nbody: '{ \"reviewers\": \"{{ pr.reviewers }}\" }'\n</code></pre>  Download this example as a CM file."},{"location":"automations/integrations/zapier/zapier-export-pr-reviewers/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/label-deleted-files/","title":"Label Deleted Files","text":"<p>Label PRs that delete files.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR deletes one or more files.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>deleted-files</code> label to the PR.</li> </ul> <p>Label Deleted Files</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n# Apply a label that indicates when a PR deletes files\n# This uses the `has` custom expression found at the bottom of this file\nlabel_deleted_files:\nif:\n- {{ has.deleted_files }}\nrun: - action: add-label@v1\nargs:\nlabel: 'deleted-files'\ncolor: '#DF9C04'\n# This is used in the `label_deleted_files` automation\nhas:\ndeleted_files: {{ source.diff.files | map(attr='new_file') | match(term='/dev/null') | some }}\n</code></pre>  Download this example as a CM file."},{"location":"automations/label-deleted-files/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/label-missing-jira-info/","title":"Index","text":"<p>This file has moved: /docs/automations/integrations/jira/label-missing-jira-info</p>"},{"location":"automations/label-missing-project-tracker/","title":"Flag Missing Project Tracking Info","text":"<p>Label PRs that lack a reference to a project tracker issue (Jira, Azure Boards, Shortcut and Asana) in the PR title or description.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR lacks a project tracker ticket number in the title, or a link to a project tracker resource in the PR description.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply Label : <code>\u26a0\ufe0f Missing Project Tracker</code></li> <li>Post a comment asking the author to reference the associated project tracker resource.</li> </ul> <p>Label Missing Project Tracker</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_missing_project_tracker:\nif:\n- {{not (has[provider].ticket_in_title or has[provider].ticket_in_desc)}}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Project Tracker\"\ncolor: 'F6443B'\n- action: add-comment@v1\nargs:\ncomment: Please provide a link to the associated resource in your team's project tracker.\nhas:\njira:\nticket_in_title: {{ pr.title | includes(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\nticket_in_desc: {{ pr.description | includes(regex=r/atlassian.net\\/browse\\/\\w{1,}-\\d{3,4}/) }}\nasana:\nticket_in_title: {{ pr.title | includes(regex=r/asana-(\\d+)/) }}\nticket_in_desc: {{ pr.description | includes(regex=r/app\\.asana.\\com\\/(\\d+)\\/(\\d+)\\/(\\d+)\\/(\\d+)\\/(\\d+)/) }}\nazure:\nticket_in_title: {{ pr.title | includes(regex=r/(\\w+)-(\\w+)-(\\d+)/) }}\nticket_in_desc: {{ pr.description | includes(regex=r/(dev\\.azure\\.com|(\\w+)\\.visualstudio\\.com)\\/(\\w+)\\/(\\w+)\\/_workitems\\/edit\\/(\\d+)/) }}\nshortcut:\nticket_in_title: {{ pr.title | includes(regex=r/(\\w+)\\/sc-(\\d+)/) }}\nticket_in_desc: {{ pr.description | includes(regex=r/(app\\.shortcut\\.com)\\/(\\w+)\\/story\\/(\\d+)\\/(\\w+)/) }}\nprovider: jira\n</code></pre>  Download this example as a CM file."},{"location":"automations/label-prs-without-tests/","title":"Label PRs Without Tests","text":"<p>Apply a <code>missing-tests</code> label to any PRs that don't update tests. gitStream will remove this label if the contributor adds a test change to the PR.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR has no changes to a test.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>missing-tests</code> label.</li> </ul> <p>Label PRs Without Tests</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_prs_without_tests:\nif:\n- {{ files | match(regex=r/[^a-zA-Z0-9](spec|test|tests)[^a-zA-Z0-9]/) | nope }}\nrun: - action: add-label@v1\nargs:\nlabel: 'missing-tests'\ncolor: '#E94637'\n</code></pre>  Download this example as a CM file."},{"location":"automations/label-prs-without-tests/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/languages/golang/","title":"Automation - Integrate gitStream with Golang","text":""},{"location":"automations/languages/golang/#approve-golang-log-output-changes","title":"Approve Golang Log Output Changes","text":"<p>Approve changes to Golang files that only affect lines of code that invoke the logger object.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>All files end in <code>.go</code></li> <li>The changes only affect lines of code that invoke the <code>log</code> object.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>log-output-only</code> label</li> <li>Approve the PR</li> <li>Post a comment explaining that the change only affects logging output.</li> </ul> <p>Approve Golang Log Output Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_golang_log_output:\n# Triggered for Golang changes that only affect the console.log() method\nif: - {{ files | extensions | match(term='go') | every }}\n- {{ source.diff.files | matchDiffLines(regex=r/^.*log\\.Println/, ignoreWhiteSpaces=true) | every }}\nrun: - action: add-label@v1\nargs:\nlabel: 'log-output-only'\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR has been approved because it only contains changes to log output\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/golang/#review-missing-golang-tests","title":"Review Missing Golang Tests","text":"<p>Automatically request changes for Golang PRs that are missing tests.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates one or more new Golang files</li> <li>The PR lacks new test files that match the name of the Golang files</li> </ul> <p>Automation Actions:</p> <ul> <li>The PR lacks new test files that match the name of the Golang files</li> <li>Apply a red missing-tests label</li> </ul> <p>Review Missing Golang Tests</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nnewFiles: {{ source.diff.files | filter(attr='new_file', regex=r/^(pkg|internal)\\/(?!.*\\_test\\.go$).*\\.go$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewTests: {{ source.diff.files | filter(attr='new_file', regex=r/.*\\_test\\.go$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewFilesCount: {{ source.diff.files | filter(attr='new_file', regex=r/^(pkg|internal)\\/(?!.*\\_test\\.go$).*\\.go$/) | filter(attr='original_file', regex=r/^$/) | length }}\nnewTestsCount: {{ source.diff.files | filter(attr='new_file', regex=r/.*\\_test\\.go$/) | filter(attr='original_file', regex=r/^$/) | length }}\nautomations:\nreview_missing_golang_tests:\nif:\n- {{ newFilesCount != newTestsCount }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Tests\"\ncolor: {{ colors.orange }}    - action: request-changes@v1\nargs:\ncomment: |\nSome of your new Golang files are missing corresponding tests. Please ensure that all new files have a corresponding test file.\n**New Files**: {{ newFilesCount }}\n{{ newFiles }}\n**New Tests**: {{ newTestsCount }}\n{{ newTests }}\ncolors:\norange: 'd93f0b'\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/golang/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p> <p>Special thanks to Boemo W Mmopelwa for providing these examples.</p>"},{"location":"automations/languages/golang/approve-golang-log-output/","title":"Approve Golang Log Output Changes","text":"<p>Approve changes to Golang files that only affect lines of code that invoke the logger object.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>All files end in <code>.go</code></li> <li>The changes only affect lines of code that invoke the <code>log</code> object.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>log-output-only</code> label</li> <li>Approve the PR</li> <li>Post a comment explaining that the change only affects logging output.</li> </ul> <p>Approve Golang Log Output Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_golang_log_output:\n# Triggered for Golang changes that only affect the console.log() method\nif: - {{ files | extensions | match(term='go') | every }}\n- {{ source.diff.files | matchDiffLines(regex=r/^.*log\\.Println/, ignoreWhiteSpaces=true) | every }}\nrun: - action: add-label@v1\nargs:\nlabel: 'log-output-only'\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR has been approved because it only contains changes to log output\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/golang/review-missing-golang-tests/","title":"Review Missing Golang Tests","text":"<p>Automatically request changes for Golang PRs that are missing tests.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates one or more new Golang files</li> <li>The PR lacks new test files that match the name of the Golang files</li> </ul> <p>Automation Actions:</p> <ul> <li>The PR lacks new test files that match the name of the Golang files</li> <li>Apply a red missing-tests label</li> </ul> <p>Review Missing Golang Tests</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nnewFiles: {{ source.diff.files | filter(attr='new_file', regex=r/^(pkg|internal)\\/(?!.*\\_test\\.go$).*\\.go$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewTests: {{ source.diff.files | filter(attr='new_file', regex=r/.*\\_test\\.go$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewFilesCount: {{ source.diff.files | filter(attr='new_file', regex=r/^(pkg|internal)\\/(?!.*\\_test\\.go$).*\\.go$/) | filter(attr='original_file', regex=r/^$/) | length }}\nnewTestsCount: {{ source.diff.files | filter(attr='new_file', regex=r/.*\\_test\\.go$/) | filter(attr='original_file', regex=r/^$/) | length }}\nautomations:\nreview_missing_golang_tests:\nif:\n- {{ newFilesCount != newTestsCount }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Tests\"\ncolor: {{ colors.orange }}    - action: request-changes@v1\nargs:\ncomment: |\nSome of your new Golang files are missing corresponding tests. Please ensure that all new files have a corresponding test file.\n**New Files**: {{ newFilesCount }}\n{{ newFiles }}\n**New Tests**: {{ newTestsCount }}\n{{ newTests }}\ncolors:\norange: 'd93f0b'\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/html/","title":"Automation - Integrate gitStream with HTML and CSS","text":""},{"location":"automations/languages/html/#request-changes-for-css-important-tags","title":"Request Changes for CSS Important Tags","text":"<p>Flag the use of <code>!important</code> in CSS files and automatically request changes.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains changes to CSS files.</li> <li>The changes include <code>!important</code></li> </ul> <p>Automation Actions:</p> <ul> <li>Apply an orange label that says <code>\u26a0\ufe0f Includes !important tag</code></li> <li>Request changes and post a comment asking the PR author to remove the important tag.</li> </ul> <p>Review Important Tags in CSS Files</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_css_important:\nif:\n- {{ files | extensions | match(term='css') | some }}\n- {{ source.diff.files | matchDiffLines(regex=r/!important/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\u26a0\ufe0f Includes !important tag'\ncolor: '{{ colors.orange }}'\n- action: request-changes@v1\nargs:\ncomment: |\nPlease remove the `!important` tag from your CSS.\ncolors:\norange: 'd93f0b'\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/html/#flag-missing-html-tags","title":"Flag Missing HTML Tags","text":"<p>Request changes for HTML files that lack the canonical and robots tag.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains only new HTML files</li> <li>One or more files are missing a canonical tag</li> <li>One or more files are missing a robots meta tag</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\u26a0\ufe0f Missing Required Tag</code> label.</li> <li>Post a comment asking the user to add required tags.</li> </ul> <p>Flag Missing HTML Tags</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nflag_missing_html_tags:\nif:\n- {{ is.html and is.new }}\n- {{ source.diff.files | matchDiffLines(regex=r/rel=\"canonical\"/) | nope }}\n- {{ source.diff.files | matchDiffLines(regex=r/meta name=\"robots\"/) | nope }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Required Tag\"\ncolor: {{ colors.yellow }}\n- action: request-changes@v1\nargs:\ncomment: | Please ensure new HTML files contain canonical and robots meta tags.\nis:\nhtml: {{ files | extensions | match(term='html') | every }}\nnew: {{ source.diff.files | map(attr='original_file') | match(regex=r/^$/) | some }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/html/#flag-duplicate-h1","title":"Flag Duplicate H1","text":"<p>Automatically request changes when PRs contain HTML files that have more than one H1 heading.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains more than one H1 heading in an HTML file.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment requesting the author to reduce H1 headings to one per file.</li> </ul> <p>Flag Duplicate H1</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nflag_duplicate_h1:\nif:\n- {{ duplicateH1 &gt; 0 }}\nrun: - action: request-changes@v1\nargs:\ncomment: | This PR contains HTML files with multiple H1 tags. Please ensure that each HTML file has only one H1 tag.\nduplicateH1: {{ source.diff.files | filter(attr='new_content', regex=r/&lt;h1&gt;(.|\\n)*&lt;h1&gt;/) | length }}\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/html/#enforce-html-title-length-requirements","title":"Enforce HTML Title Length Requirements","text":"<p>Automatically request changes for <code>&lt;title&gt;</code> tags that don't comply with best practices.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR adds a <code>&lt;title&gt;</code> tag that is less than 30 or greater than 90 characters.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment asking the author to modify the title.</li> </ul> <p>Enforce HTML Title Length Requirements</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nenforce_html_title_length:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/(&lt;title&gt;([\\w\\W]{1,29})&lt;\\/title&gt;)|(&lt;title&gt;([\\w\\W]{61,})&lt;\\/title&gt;)/) | some }}\nrun: - action: request-changes@v1\nargs:\ncomment: | Please ensure that all HTML titles are between 30 and 60 characters.\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/html/#enforce-image-alt-attributes","title":"Enforce Image Alt Attributes","text":"<p>Automatically request changes for PRs HTML files that are missing image alt attributes.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR adds an image tag to an HTML file.</li> <li>The PR is missing alt attributes for one or more images.</li> </ul> <p>Automation Actions:</p> <ul> <li>Add a <code>\u26a0\ufe0f Missing alt label</code> label</li> <li>Request changes and post a comment asking the author to add alt attributes to images.</li> </ul> <p>Enforce Image Alt Attributes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nenforce_image_alt:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/&lt;img src/) | some }}\n- {{ source.diff.files | matchDiffLines(regex=r/&lt;img src.*alt=/) | nope}}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing alt label\"\ncolor: {{ colors.yellow }}\n- action: request-changes@v1\nargs:\ncomment: | Please ensure that all images in HTML files have an alt attribute. For example: &lt;img alt=\"Alt Message\"&gt;\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/html/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p> <p>Special thanks to Boemo W Mmopelwa for providing these examples.</p>"},{"location":"automations/languages/html/enforce-html-title-length/","title":"Enforce HTML Title Length Requirements","text":"<p>Automatically request changes for <code>&lt;title&gt;</code> tags that don't comply with best practices.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR adds a <code>&lt;title&gt;</code> tag that is less than 30 or greater than 90 characters.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment asking the author to modify the title.</li> </ul> <p>Enforce HTML Title Length Requirements</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nenforce_html_title_length:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/(&lt;title&gt;([\\w\\W]{1,29})&lt;\\/title&gt;)|(&lt;title&gt;([\\w\\W]{61,})&lt;\\/title&gt;)/) | some }}\nrun: - action: request-changes@v1\nargs:\ncomment: | Please ensure that all HTML titles are between 30 and 60 characters.\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/html/enforce-image-alt/","title":"Enforce Image Alt Attributes","text":"<p>Automatically request changes for PRs HTML files that are missing image alt attributes.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR adds an image tag to an HTML file.</li> <li>The PR is missing alt attributes for one or more images.</li> </ul> <p>Automation Actions:</p> <ul> <li>Add a <code>\u26a0\ufe0f Missing alt label</code> label</li> <li>Request changes and post a comment asking the author to add alt attributes to images.</li> </ul> <p>Enforce Image Alt Attributes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nenforce_image_alt:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/&lt;img src/) | some }}\n- {{ source.diff.files | matchDiffLines(regex=r/&lt;img src.*alt=/) | nope}}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing alt label\"\ncolor: {{ colors.yellow }}\n- action: request-changes@v1\nargs:\ncomment: | Please ensure that all images in HTML files have an alt attribute. For example: &lt;img alt=\"Alt Message\"&gt;\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/html/flag-duplicate-h1/","title":"Flag Duplicate H1","text":"<p>Automatically request changes when PRs contain HTML files that have more than one H1 heading.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains more than one H1 heading in an HTML file.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment requesting the author to reduce H1 headings to one per file.</li> </ul> <p>Flag Duplicate H1</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nflag_duplicate_h1:\nif:\n- {{ duplicateH1 &gt; 0 }}\nrun: - action: request-changes@v1\nargs:\ncomment: | This PR contains HTML files with multiple H1 tags. Please ensure that each HTML file has only one H1 tag.\nduplicateH1: {{ source.diff.files | filter(attr='new_content', regex=r/&lt;h1&gt;(.|\\n)*&lt;h1&gt;/) | length }}\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/html/flag-missing-html-tags/","title":"Flag Missing HTML Tags","text":"<p>Request changes for HTML files that lack the canonical and robots tag.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains only new HTML files</li> <li>One or more files are missing a canonical tag</li> <li>One or more files are missing a robots meta tag</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\u26a0\ufe0f Missing Required Tag</code> label.</li> <li>Post a comment asking the user to add required tags.</li> </ul> <p>Flag Missing HTML Tags</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nflag_missing_html_tags:\nif:\n- {{ is.html and is.new }}\n- {{ source.diff.files | matchDiffLines(regex=r/rel=\"canonical\"/) | nope }}\n- {{ source.diff.files | matchDiffLines(regex=r/meta name=\"robots\"/) | nope }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Required Tag\"\ncolor: {{ colors.yellow }}\n- action: request-changes@v1\nargs:\ncomment: | Please ensure new HTML files contain canonical and robots meta tags.\nis:\nhtml: {{ files | extensions | match(term='html') | every }}\nnew: {{ source.diff.files | map(attr='original_file') | match(regex=r/^$/) | some }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/html/review-css-important/","title":"Review Important Tags in CSS Files","text":"<p>Flag the use of <code>!important</code> in CSS files and automatically request changes.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains changes to CSS files.</li> <li>The changes include <code>!important</code></li> </ul> <p>Automation Actions:</p> <ul> <li>Apply an orange label that says <code>\u26a0\ufe0f Includes !important tag</code></li> <li>Request changes and post a comment asking the PR author to remove the important tag.</li> </ul> <p>Review Important Tags in CSS Files</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_css_important:\nif:\n- {{ files | extensions | match(term='css') | some }}\n- {{ source.diff.files | matchDiffLines(regex=r/!important/) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\u26a0\ufe0f Includes !important tag'\ncolor: '{{ colors.orange }}'\n- action: request-changes@v1\nargs:\ncomment: |\nPlease remove the `!important` tag from your CSS.\ncolors:\norange: 'd93f0b'\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/java/","title":"Automation - Integrate gitStream with Java","text":""},{"location":"automations/languages/java/#approve-java-log-output-changes","title":"Approve Java Log Output Changes","text":"<p>Approve changes to Java files that only affect lines of code that invoke the logger object.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>All files end in .java</li> <li>The changes only affect lines of code that invoke logger object.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>log-output-only</code> label</li> <li>Approve the PR</li> <li>Post a comment explaining that the change only affects logging output.</li> </ul> <p>Approve Java Log Output Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_java_log_output:\n# Triggered for Java changes that only affect the logger method\nif: - {{ files | extensions | match(term='java') | every }}\n- {{ source.diff.files | matchDiffLines(regex=r/^.*logger\\.(trace|fatal|debug|info|warn|error)/, ignoreWhiteSpaces=true) | every }}\nrun: - action: add-label@v1\nargs:\nlabel: 'log-output-only'\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR has been approved because it only contains changes to log output\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/java/#review-missing-java-tests","title":"Review Missing Java Tests","text":"<p>Automatically request changes for Java PRs that lack test files.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates one or more new Java files</li> <li>The PR lacks new test files that match the name of the Java files</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a red missing-tests label</li> <li>Request changes and post a comment listing the files that need tests.</li> </ul> <p>Review Missing Java Tests</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nnewFiles: {{ source.diff.files | filter(attr='new_file', regex=r/^src\\/(?!.*Test\\.java$).*\\.java$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewTests: {{ source.diff.files | filter(attr='new_file', regex=r/src\\/.*Test\\.java$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewFilesCount: {{ source.diff.files | filter(attr='new_file', regex=r/^src\\/(?!.*Test\\.java$).*\\.java$/) | filter(attr='original_file', regex=r/^$/) | length }}\nnewTestsCount: {{ source.diff.files | filter(attr='new_file', regex=r/src\\/.*Test\\.java$/) | filter(attr='original_file', regex=r/^$/) | length }}\nautomations:\nreview_missing_java_tests:\nif:\n- {{ newFilesCount != newTestsCount }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Tests\"\ncolor: {{ colors.orange }}    - action: request-changes@v1\nargs:\ncomment: |\nSome of your new Java files are missing corresponding tests. Please ensure that all new files have a corresponding test file.\n**New Files**: {{ newFilesCount }}\n{{ newFiles }}\n**New Tests**: {{ newTestsCount }}\n{{ newTests }}\ncolors:\norange: 'd93f0b'\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/java/#review-java-test-names","title":"Review Java Test Names","text":"<p>Automatically request changes for Java test files that fail to match the required naming convention.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates one or more new Java test files</li> <li>The Java test fails to match the required naming convention.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment that explains the Java test name requirements.</li> </ul> <p>Review Java Test Name</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0  newTests: {{ source.diff.files | filter(attr='new_file', regex=r/^src\\/test\\/) }}\nnewTestsCount: {{ source.diff.files | filter(attr='new_file', regex=r/^src\\/test\\/) | length }}\nautomations:\nreview_java_test_name:\nif:\n- {{ newTestsCount &gt; 0}}     - {{ source.diff.files | filter(attr='new_file', regex=r/^src\\/test\\/) | match(attr='new_file', regex=r/Test.java$/) | nope }}\nrun: - action: request-changes@v1\nargs:\ncomment: |\nThe test file name does not follow the Java test name conventions. A test file name needs to have the word Test at the end of class name. For example, if you are testing a class called Data then the test file name has to be DataTest.java.\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/java/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p> <p>Special thanks to Boemo W Mmopelwa for providing these examples.</p>"},{"location":"automations/languages/java/approve-java-log-output/","title":"Approve Java Log Output Changes","text":"<p>Approve changes to Java files that only affect lines of code that invoke the logger object.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>All files end in .java</li> <li>The changes only affect lines of code that invoke logger object.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>log-output-only</code> label</li> <li>Approve the PR</li> <li>Post a comment explaining that the change only affects logging output.</li> </ul> <p>Approve Java Log Output Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_java_log_output:\n# Triggered for Java changes that only affect the logger method\nif: - {{ files | extensions | match(term='java') | every }}\n- {{ source.diff.files | matchDiffLines(regex=r/^.*logger\\.(trace|fatal|debug|info|warn|error)/, ignoreWhiteSpaces=true) | every }}\nrun: - action: add-label@v1\nargs:\nlabel: 'log-output-only'\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR has been approved because it only contains changes to log output\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/java/review-java-test-name/","title":"Review Java Test Name","text":"<p>Automatically request changes for Java test files that fail to match the required naming convention.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates one or more new Java test files</li> <li>The Java test fails to match the required naming convention.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment that explains the Java test name requirements.</li> </ul> <p>Review Java Test Name</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0  newTests: {{ source.diff.files | filter(attr='new_file', regex=r/^src\\/test\\/) }}\nnewTestsCount: {{ source.diff.files | filter(attr='new_file', regex=r/^src\\/test\\/) | length }}\nautomations:\nreview_java_test_name:\nif:\n- {{ newTestsCount &gt; 0}}     - {{ source.diff.files | filter(attr='new_file', regex=r/^src\\/test\\/) | match(attr='new_file', regex=r/Test.java$/) | nope }}\nrun: - action: request-changes@v1\nargs:\ncomment: |\nThe test file name does not follow the Java test name conventions. A test file name needs to have the word Test at the end of class name. For example, if you are testing a class called Data then the test file name has to be DataTest.java.\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/java/review-missing-java-tests/","title":"Review Missing Java Tests","text":"<p>Automatically request changes for Java PRs that lack test files.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates one or more new Java files</li> <li>The PR lacks new test files that match the name of the Java files</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a red missing-tests label</li> <li>Request changes and post a comment listing the files that need tests.</li> </ul> <p>Review Missing Java Tests</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nnewFiles: {{ source.diff.files | filter(attr='new_file', regex=r/^src\\/(?!.*Test\\.java$).*\\.java$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewTests: {{ source.diff.files | filter(attr='new_file', regex=r/src\\/.*Test\\.java$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewFilesCount: {{ source.diff.files | filter(attr='new_file', regex=r/^src\\/(?!.*Test\\.java$).*\\.java$/) | filter(attr='original_file', regex=r/^$/) | length }}\nnewTestsCount: {{ source.diff.files | filter(attr='new_file', regex=r/src\\/.*Test\\.java$/) | filter(attr='original_file', regex=r/^$/) | length }}\nautomations:\nreview_missing_java_tests:\nif:\n- {{ newFilesCount != newTestsCount }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Tests\"\ncolor: {{ colors.orange }}    - action: request-changes@v1\nargs:\ncomment: |\nSome of your new Java files are missing corresponding tests. Please ensure that all new files have a corresponding test file.\n**New Files**: {{ newFilesCount }}\n{{ newFiles }}\n**New Tests**: {{ newTestsCount }}\n{{ newTests }}\ncolors:\norange: 'd93f0b'\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/javascript/","title":"Automation - Integrate gitStream with JavaScript","text":""},{"location":"automations/languages/javascript/#auto-approve-javascript-log-output-changes","title":"Auto-Approve JavaScript Log Output Changes","text":"<p>Approve changes to JavaScript files that only affect lines of code that invoke the console.log() method.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>All files must end in .js or .ts</li> <li>The changes only affect lines of code that invoke console.log()</li> </ul> <p>Automation Actions:</p> <ul> <li>Applies a <code>log-output-only</code> label</li> <li>Approves the PR</li> <li>Posts a comment explaining that the change only affects logging output.</li> </ul> <p>Approve JavaScript Log Output Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_javascript_log_output:\n# Triggered for JavaScript changes that only affect the console.log() method\nif: - {{ files | match(regex=r/\\.js$|\\.ts$/) | every }}\n- {{ source.diff.files | matchDiffLines(regex=r/^[+-].*console\\.log/, ignoreWhiteSpaces=true) | every }}\nrun: - action: add-label@v1\nargs:\nlabel: 'log-output-only'\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR has been approved because it only contains changes to log output\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/languages/javascript/#auto-approve-javascript-formatting-change","title":"Auto-Approve JavaScript Formatting Change","text":"<p>Approve PRs that only contain formatting changes to JavaScript or TypeScript files.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>All of the files end in <code>.js</code> or <code>.ts</code></li> <li>All changes are non-functional</li> </ul> <p>Automation Actions:</p> <ul> <li>Approve the PR</li> <li>Apply a <code>code-formatting</code> label.</li> <li>Post a comment that explains the automation.</li> </ul> <p>Approve JavaScript Formatting Change</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_javascript_formatting:\nif:\n- {{ files | extensions | match(list=['js', 'ts']) | every }}\n- {{ source.diff.files | isFormattingChange }}\nrun:\n- action: approve@v1\n- action: add-label@v1\nargs:\nlabel: code-formatting\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR only contains formatting changes and has been approved.\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/languages/javascript/#review-missing-javascript-tests","title":"Review Missing JavaScript Tests","text":"<p>Request changes for JavaScript PRs that lack test files.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates one or more new JavaScript files</li> <li>The PR lacks new test files that match the name of the JavaScript files</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a red <code>missing-tests</code> label</li> <li>Request changes and post a comment listing the files that need tests.</li> </ul> <p>Review Missing JavaScript Tests</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nnewFiles: {{ source.diff.files | filter(attr='new_file', regex=r/^src\\/(?!.*\\.test\\.js$).*\\.js$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewTests: {{ source.diff.files | filter(attr='new_file', regex=r/src\\/.*\\.test\\.js$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewFilesCount: {{ source.diff.files | filter(attr='new_file', regex=r/^src\\/(?!.*\\.test\\.js$).*\\.js$/) | filter(attr='original_file', regex=r/^$/) | length }}\nnewTestsCount: {{ source.diff.files | filter(attr='new_file', regex=r/src\\/.*\\.test\\.js$/) | filter(attr='original_file', regex=r/^$/) | length }}\nautomations:\nreview_missing_javascript_tests:\nif:\n- {{ newFilesCount != newTestsCount }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Tests\"\ncolor: {{ colors.orange }}    - action: request-changes@v1\nargs:\ncomment: |\nSome of your new JavaScript files are missing corresponding tests. Please ensure that all new files have a corresponding test file.\n**New Files**: {{ newFilesCount }}\n{{ newFiles }}\n**New Tests**: {{ newTestsCount }}\n{{ newTests }}\ncolors:\norange: 'd93f0b'\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/javascript/#review-javascript-test-name","title":"Review JavaScript Test Name","text":"<p>Automatically request changes for JavaScript test files that fail to match the required naming convention.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates one or more new JavaScript test files</li> <li>The JavaScript test fails to match the required naming convention.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment that explains the JavaScript test name requirements.</li> </ul> <p>Review JavaScript Test Name</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nnewTests: {{ source.diff.files | filter(attr='new_file', regex=r/^test/) }}\nnewTestsCount: {{ source.diff.files | filter(attr='new_file', regex=r/^test/) | length }}\nautomations:\nreview_javascript_test_name:\nif:\n- {{ newTestsCount &gt; 0}}     - {{ source.diff.files | filter(attr='new_file', regex=r/^test/) | match(attr='new_file', regex=r/.test.js$/) | nope }}\nrun: - action: request-changes@v1\nargs:\ncomment: |\nThe test file name does not follow the JavaScript test name conventions. A test file name needs to have the suffix .test after class name. For example, if you are testing a class file called Data.js then the test file name has to be data.test.js.\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/javascript/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/languages/javascript/approve-javascript-formatting-change/","title":"Approve JavaScript Formatting Changes","text":"<p>Approve PRs that only contain formatting changes to JavaScript or TypeScript files.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>All of the files end in <code>.js</code> or <code>.ts</code></li> <li>All changes are non-functional</li> </ul> <p>Automation Actions:</p> <ul> <li>Approve the PR</li> <li>Apply a <code>code-formatting</code> label.</li> <li>Post a comment that explains the automation.</li> </ul> <p>Approve JavaScript Formatting Change</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_javascript_formatting:\nif:\n- {{ files | extensions | match(list=['js', 'ts']) | every }}\n- {{ source.diff.files | isFormattingChange }}\nrun:\n- action: approve@v1\n- action: add-label@v1\nargs:\nlabel: code-formatting\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR only contains formatting changes and has been approved.\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/languages/javascript/approve-javascript-log-output/","title":"Approve JavaScript Log Output Changes","text":"<p>Approve changes to JavaScript files that only affect lines of code that invoke the console.log() method.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>All files must end in .js or .ts</li> <li>The changes only affect lines of code that invoke console.log()</li> </ul> <p>Automation Actions:</p> <ul> <li>Applies a <code>log-output-only</code> label</li> <li>Approves the PR</li> <li>Posts a comment explaining that the change only affects logging output.</li> </ul> <p>Approve JavaScript Log Output Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_javascript_log_output:\n# Triggered for JavaScript changes that only affect the console.log() method\nif: - {{ files | match(regex=r/\\.js$|\\.ts$/) | every }}\n- {{ source.diff.files | matchDiffLines(regex=r/^[+-].*console\\.log/, ignoreWhiteSpaces=true) | every }}\nrun: - action: add-label@v1\nargs:\nlabel: 'log-output-only'\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR has been approved because it only contains changes to log output\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/languages/javascript/review-javascript-test-name/","title":"Review JavaScript Test Name","text":"<p>Automatically request changes for JavaScript test files that fail to match the required naming convention.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates one or more new JavaScript test files</li> <li>The JavaScript test fails to match the required naming convention.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment that explains the JavaScript test name requirements.</li> </ul> <p>Review JavaScript Test Name</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nnewTests: {{ source.diff.files | filter(attr='new_file', regex=r/^test/) }}\nnewTestsCount: {{ source.diff.files | filter(attr='new_file', regex=r/^test/) | length }}\nautomations:\nreview_javascript_test_name:\nif:\n- {{ newTestsCount &gt; 0}}     - {{ source.diff.files | filter(attr='new_file', regex=r/^test/) | match(attr='new_file', regex=r/.test.js$/) | nope }}\nrun: - action: request-changes@v1\nargs:\ncomment: |\nThe test file name does not follow the JavaScript test name conventions. A test file name needs to have the suffix .test after class name. For example, if you are testing a class file called Data.js then the test file name has to be data.test.js.\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/javascript/review-missing-javascript-tests/","title":"Review Missing JavaScript Tests","text":"<p>Request changes for JavaScript PRs that lack test files.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates one or more new JavaScript files</li> <li>The PR lacks new test files that match the name of the JavaScript files</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a red <code>missing-tests</code> label</li> <li>Request changes and post a comment listing the files that need tests.</li> </ul> <p>Review Missing JavaScript Tests</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nnewFiles: {{ source.diff.files | filter(attr='new_file', regex=r/^src\\/(?!.*\\.test\\.js$).*\\.js$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewTests: {{ source.diff.files | filter(attr='new_file', regex=r/src\\/.*\\.test\\.js$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewFilesCount: {{ source.diff.files | filter(attr='new_file', regex=r/^src\\/(?!.*\\.test\\.js$).*\\.js$/) | filter(attr='original_file', regex=r/^$/) | length }}\nnewTestsCount: {{ source.diff.files | filter(attr='new_file', regex=r/src\\/.*\\.test\\.js$/) | filter(attr='original_file', regex=r/^$/) | length }}\nautomations:\nreview_missing_javascript_tests:\nif:\n- {{ newFilesCount != newTestsCount }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Tests\"\ncolor: {{ colors.orange }}    - action: request-changes@v1\nargs:\ncomment: |\nSome of your new JavaScript files are missing corresponding tests. Please ensure that all new files have a corresponding test file.\n**New Files**: {{ newFilesCount }}\n{{ newFiles }}\n**New Tests**: {{ newTestsCount }}\n{{ newTests }}\ncolors:\norange: 'd93f0b'\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/python/","title":"Automation - Integrate gitStream with Python","text":""},{"location":"automations/languages/python/#auto-approve-python-log-output-changes","title":"Auto-Approve Python Log Output Changes","text":"<p>Approve changes to Python files that only affect lines of code that invoke a specified logging object.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>All files must end in .py</li> <li>The changes only affect lines of code that invoke a <code>logger</code> object. This should be customized to your environment.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>log-output-only</code> label</li> <li>Approve the PR</li> <li>Post a comment explaining that the change only affects logging output.</li> </ul> <p>Approve Python Log Output Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_python_log_output:\n# Triggered for python changes that only affect lines of code that invoke a logger object. \n# Modify 'logger' to match your dev environment.\nif: - {{ files | match(regex=r/\\.py$/) | every }}\n- {{ source.diff.files | matchDiffLines(regex=r/^[+-].*logger\\.(trace|debug|info|warn|error)/, ignoreWhiteSpaces=true) | every }}\nrun: - action: add-label@v1\nargs:\nlabel: 'log-output-only'\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR has been approved because it only contains changes to log output\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/languages/python/#auto-approve-python-formatting-changes","title":"Auto-Approve Python Formatting Changes","text":"<p>Approve PRs that only contain formatting changes to Python files.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>All of the files end in <code>.py</code>.</li> <li>All changes are non-functional</li> </ul> <p>Automation Actions:</p> <ul> <li>Approve the PR</li> <li>Apply a <code>code-formatting</code> label.</li> <li>Post a comment that explains the automation.</li> </ul> <p>Approve Python Formatting Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_python_formatting:\nif:\n- {{ files | extensions | match(list=['py']) | every }}\n- {{ source.diff.files | isFormattingChange }}\nrun:\n- action: approve@v1\n- action: add-label@v1\nargs:\nlabel: code-formatting\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR only contains formatting changes and has been approved.\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/languages/python/#review-missing-python-tests","title":"Review Missing Python Tests","text":"<p>Automatically request changes for Python PRs that lack test files.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates one or more new Python files</li> <li>The PR lacks new test files that match the name of the Python files</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a red missing-tests label</li> <li>Request changes and post a comment listing the files that need tests.</li> </ul> <p>Review Missing Python Tests</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nnewFiles: {{ source.diff.files | filter(attr='new_file', regex=r/^src\\/(?!test_.*\\.py$).*\\.py$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewTests: {{ source.diff.files | filter(attr='new_file', regex=r/^tests\\/test_.*\\.py$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewFilesCount: {{ source.diff.files | filter(attr='new_file', regex=r/^src\\/(?!test_.*\\.py$).*\\.py$/) | filter(attr='original_file', regex=r/^$/) | length }}\nnewTestsCount: {{ source.diff.files | filter(attr='new_file', regex=r/^tests\\/test_.*\\.py$/) | filter(attr='original_file', regex=r/^$/) | length }}\nautomations:\nreview_missing_python_tests:\nif:\n- {{ newFilesCount != newTestsCount }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Tests\"\ncolor: {{ colors.orange }}    - action: request-changes@v1\nargs:\ncomment: |\nSome of your new Python files are missing corresponding tests. Please ensure that all new files have a corresponding test file.\n**New Files**: {{ newFilesCount }}\n{{ newFiles }}\n**New Tests**: {{ newTestsCount }}\n{{ newTests }}\ncolors:\norange: 'd93f0b'\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/python/#review-python-test-name","title":"Review Python Test Name","text":"<p>Automatically request changes for Python test files that fail to match the required naming convention.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates one or more new Python test files</li> <li>The Python test fails to match the required naming convention.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment that explains the Python test name requirements.</li> </ul> <p>Review Python Test Name</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nnewTests: {{ source.diff.files | filter(attr='new_file', regex=r/^tests/) }}\nnewTestsCount: {{ source.diff.files | filter(attr='new_file', regex=r/^tests/) | length }}\nautomations:\nreview_python_test_name:\nif:\n- {{ newTestsCount &gt; 0}}     - {{ source.diff.files | filter(attr='new_file', regex=r/^tests/) | match(attr='new_file', regex=r/test_.*\\.py$/) | nope }}   run: - action: request-changes@v1\nargs:\ncomment: |\nThe test file name does not follow the Python test name conventions. A test file name needs to have the prefix test_ before class name. For example, if you are testing a class file called Data.py then the test file name has to be test_data.py.\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/python/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/languages/python/approve-python-formatting-change/","title":"Approve Python Formatting Changes","text":"<p>Approve PRs that only contain formatting changes to Python files.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>All of the files end in <code>.py</code>.</li> <li>All changes are non-functional</li> </ul> <p>Automation Actions:</p> <ul> <li>Approve the PR</li> <li>Apply a <code>code-formatting</code> label.</li> <li>Post a comment that explains the automation.</li> </ul> <p>Approve Python Formatting Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_python_formatting:\nif:\n- {{ files | extensions | match(list=['py']) | every }}\n- {{ source.diff.files | isFormattingChange }}\nrun:\n- action: approve@v1\n- action: add-label@v1\nargs:\nlabel: code-formatting\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR only contains formatting changes and has been approved.\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/languages/python/approve-python-log-output/","title":"Approve Python Log Output Changes","text":"<p>Approve changes to Python files that only affect lines of code that invoke a specified logging object.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>All files must end in .py</li> <li>The changes only affect lines of code that invoke a <code>logger</code> object. This should be customized to your environment.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>log-output-only</code> label</li> <li>Approve the PR</li> <li>Post a comment explaining that the change only affects logging output.</li> </ul> <p>Approve Python Log Output Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_python_log_output:\n# Triggered for python changes that only affect lines of code that invoke a logger object. \n# Modify 'logger' to match your dev environment.\nif: - {{ files | match(regex=r/\\.py$/) | every }}\n- {{ source.diff.files | matchDiffLines(regex=r/^[+-].*logger\\.(trace|debug|info|warn|error)/, ignoreWhiteSpaces=true) | every }}\nrun: - action: add-label@v1\nargs:\nlabel: 'log-output-only'\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR has been approved because it only contains changes to log output\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/languages/python/review-missing-python-tests/","title":"Review Missing Python Tests","text":"<p>Automatically request changes for Python PRs that lack test files.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates one or more new Python files</li> <li>The PR lacks new test files that match the name of the Python files</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a red missing-tests label</li> <li>Request changes and post a comment listing the files that need tests.</li> </ul> <p>Review Missing Python Tests</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nnewFiles: {{ source.diff.files | filter(attr='new_file', regex=r/^src\\/(?!test_.*\\.py$).*\\.py$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewTests: {{ source.diff.files | filter(attr='new_file', regex=r/^tests\\/test_.*\\.py$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewFilesCount: {{ source.diff.files | filter(attr='new_file', regex=r/^src\\/(?!test_.*\\.py$).*\\.py$/) | filter(attr='original_file', regex=r/^$/) | length }}\nnewTestsCount: {{ source.diff.files | filter(attr='new_file', regex=r/^tests\\/test_.*\\.py$/) | filter(attr='original_file', regex=r/^$/) | length }}\nautomations:\nreview_missing_python_tests:\nif:\n- {{ newFilesCount != newTestsCount }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Tests\"\ncolor: {{ colors.orange }}    - action: request-changes@v1\nargs:\ncomment: |\nSome of your new Python files are missing corresponding tests. Please ensure that all new files have a corresponding test file.\n**New Files**: {{ newFilesCount }}\n{{ newFiles }}\n**New Tests**: {{ newTestsCount }}\n{{ newTests }}\ncolors:\norange: 'd93f0b'\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/python/review-python-test-name/","title":"Review Python Test Name","text":"<p>Automatically request changes for Python test files that fail to match the required naming convention.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates one or more new Python test files</li> <li>The Python test fails to match the required naming convention.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment that explains the Python test name requirements.</li> </ul> <p>Review Python Test Name</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nnewTests: {{ source.diff.files | filter(attr='new_file', regex=r/^tests/) }}\nnewTestsCount: {{ source.diff.files | filter(attr='new_file', regex=r/^tests/) | length }}\nautomations:\nreview_python_test_name:\nif:\n- {{ newTestsCount &gt; 0}}     - {{ source.diff.files | filter(attr='new_file', regex=r/^tests/) | match(attr='new_file', regex=r/test_.*\\.py$/) | nope }}   run: - action: request-changes@v1\nargs:\ncomment: |\nThe test file name does not follow the Python test name conventions. A test file name needs to have the prefix test_ before class name. For example, if you are testing a class file called Data.py then the test file name has to be test_data.py.\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/ruby/","title":"Automation - Integrate gitStream with Ruby","text":""},{"location":"automations/languages/ruby/#approve-ruby-log-output-changes","title":"Approve Ruby Log Output Changes","text":"<p>Approve changes to Ruby files that only affect lines of code that invoke the logger object.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>All files end in .rb</li> <li>The changes only affect lines of code that invoke logger object.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>log-output-only</code> label</li> <li>Approve the PR</li> <li>Post a comment explaining that the change only affects logging output.</li> </ul> <p>Approve Ruby Log Output Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_ruby_log_output:\n# Triggered for Ruby changes that only affect the logger method\nif: - {{ files | extensions | match(term='rb') | every }}\n- {{ source.diff.files | matchDiffLines(regex=r/^.*logger\\.(fatal|debug|info|warn|error)/, ignoreWhiteSpaces=true) | every }}\nrun: - action: add-label@v1\nargs:\nlabel: 'log-output-only'\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR has been approved because it only contains changes to log output\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/ruby/#review-missing-ruby-tests","title":"Review Missing Ruby Tests","text":"<p>Automatically request changes for Ruby PRs that lack test files.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates one or more new Ruby files</li> <li>The PR lacks new test files that match the name of the Ruby files</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a red missing-tests label</li> <li>Request changes and post a comment listing the files that need tests.</li> </ul> <p>Review Missing Ruby Tests</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nnewFiles: {{ source.diff.files | filter(attr='new_file', regex=r/^app\\/(?!.*\\_spec\\.rb$).*\\.rb$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewTests: {{ source.diff.files | filter(attr='new_file', regex=r/spec\\/.*\\_spec\\.rb$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewFilesCount: {{ source.diff.files | filter(attr='new_file', regex=r/^app\\/(?!.*\\_spec\\.rb$).*\\.rb$/) | filter(attr='original_file', regex=r/^$/) | length }}\nnewTestsCount: {{ source.diff.files | filter(attr='new_file', regex=r/spec\\/.*\\_spec\\.rb$/) | filter(attr='original_file', regex=r/^$/) | length }}\nautomations:\nreview_missing_ruby_tests:\nif:\n- {{ newFilesCount != newTestsCount }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Tests\"\ncolor: {{ colors.orange }}    - action: request-changes@v1\nargs:\ncomment: |\nSome of your new Ruby files are missing corresponding tests. Please ensure that all new files have a corresponding test file.\n**New Files**: {{ newFilesCount }}\n{{ newFiles }}\n**New Tests**: {{ newTestsCount }}\n{{ newTests }}\ncolors:\norange: 'd93f0b'\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/ruby/#review-ruby-test-name","title":"Review Ruby Test Name","text":"<p>Automatically request changes for Ruby test files that fail to match the required naming convention.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates one or more new Ruby test files</li> <li>The Ruby test fails to match the required naming convention.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment that explains the Ruby test name requirements.</li> </ul> <p>Review Ruby Test Name</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nnewTests: {{ source.diff.files | filter(attr='new_file', regex=r/^spec/) }}\nnewTestsCount: {{ source.diff.files | filter(attr='new_file', regex=r/^spec/) | length }}\nautomations:\nreview_ruby_test_name:\nif:\n- {{ newTestsCount &gt; 0}}     - {{ source.diff.files | filter(attr='new_file', regex=r/^spec/) | match(attr='new_file', regex=r/_spec.rb$/) | nope }}\nrun: - action: request-changes@v1\nargs:\ncomment: |\nThe test file name does not follow the Ruby test name conventions. A test file name needs to have the suffix _spec after class name. For example, if you are testing a class file called data.rb then the test file name has to be data_spec.rb.\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/ruby/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p> <p>Special thanks to Boemo W Mmopelwa for providing these examples.</p>"},{"location":"automations/languages/ruby/approve-ruby-log-output/","title":"Approve Ruby Log Output Changes","text":"<p>Approve changes to Ruby files that only affect lines of code that invoke the logger object.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>All files end in .rb</li> <li>The changes only affect lines of code that invoke logger object.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>log-output-only</code> label</li> <li>Approve the PR</li> <li>Post a comment explaining that the change only affects logging output.</li> </ul> <p>Approve Ruby Log Output Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_ruby_log_output:\n# Triggered for Ruby changes that only affect the logger method\nif: - {{ files | extensions | match(term='rb') | every }}\n- {{ source.diff.files | matchDiffLines(regex=r/^.*logger\\.(fatal|debug|info|warn|error)/, ignoreWhiteSpaces=true) | every }}\nrun: - action: add-label@v1\nargs:\nlabel: 'log-output-only'\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR has been approved because it only contains changes to log output\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/ruby/review-missing-ruby-tests/","title":"Review Missing Ruby Tests","text":"<p>Automatically request changes for Ruby PRs that lack test files.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates one or more new Ruby files</li> <li>The PR lacks new test files that match the name of the Ruby files</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a red missing-tests label</li> <li>Request changes and post a comment listing the files that need tests.</li> </ul> <p>Review Missing Ruby Tests</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nnewFiles: {{ source.diff.files | filter(attr='new_file', regex=r/^app\\/(?!.*\\_spec\\.rb$).*\\.rb$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewTests: {{ source.diff.files | filter(attr='new_file', regex=r/spec\\/.*\\_spec\\.rb$/) | filter(attr='original_file', regex=r/^$/) | map(attr='new_file') }}\nnewFilesCount: {{ source.diff.files | filter(attr='new_file', regex=r/^app\\/(?!.*\\_spec\\.rb$).*\\.rb$/) | filter(attr='original_file', regex=r/^$/) | length }}\nnewTestsCount: {{ source.diff.files | filter(attr='new_file', regex=r/spec\\/.*\\_spec\\.rb$/) | filter(attr='original_file', regex=r/^$/) | length }}\nautomations:\nreview_missing_ruby_tests:\nif:\n- {{ newFilesCount != newTestsCount }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Tests\"\ncolor: {{ colors.orange }}    - action: request-changes@v1\nargs:\ncomment: |\nSome of your new Ruby files are missing corresponding tests. Please ensure that all new files have a corresponding test file.\n**New Files**: {{ newFilesCount }}\n{{ newFiles }}\n**New Tests**: {{ newTestsCount }}\n{{ newTests }}\ncolors:\norange: 'd93f0b'\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/ruby/review-ruby-test-name/","title":"Review Ruby Test Name","text":"<p>Automatically request changes for Ruby test files that fail to match the required naming convention.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates one or more new Ruby test files</li> <li>The Ruby test fails to match the required naming convention.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment that explains the Ruby test name requirements.</li> </ul> <p>Review Ruby Test Name</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nnewTests: {{ source.diff.files | filter(attr='new_file', regex=r/^spec/) }}\nnewTestsCount: {{ source.diff.files | filter(attr='new_file', regex=r/^spec/) | length }}\nautomations:\nreview_ruby_test_name:\nif:\n- {{ newTestsCount &gt; 0}}     - {{ source.diff.files | filter(attr='new_file', regex=r/^spec/) | match(attr='new_file', regex=r/_spec.rb$/) | nope }}\nrun: - action: request-changes@v1\nargs:\ncomment: |\nThe test file name does not follow the Ruby test name conventions. A test file name needs to have the suffix _spec after class name. For example, if you are testing a class file called data.rb then the test file name has to be data_spec.rb.\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/rust/","title":"Automation - Integrate gitStream with Rust","text":""},{"location":"automations/languages/rust/#approve-rust-log-output-changes","title":"Approve Rust Log Output Changes","text":"<p>Approve changes to Rust files that only affect lines of code that invoke the logging marcos.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>All files end in <code>.rs</code></li> <li>The changes only affect lines of code that invoke <code>print</code>, <code>println</code> or <code>dbg</code> macros or use the <code>log</code> crate macros.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>log-output-only</code> label</li> <li>Approve the PR</li> <li>Post a comment explaining that the change only affects logging output.</li> </ul> <p>Approve Rust Log Output Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_rust_log_output:\n# Triggered for Rust changes that only affect the logging macros\nif: - {{ files | extensions | match(term='rs') | every }}\n- {{ source.diff.files | matchDiffLines(regex=r/^.*\\b(println|print|dbg|error|warn|info|debug|trace)\\b!/, ignoreWhiteSpaces=true) | every }}\nrun: - action: add-label@v1\nargs:\nlabel: 'log-output-only'\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR has been approved because it only contains changes to log output\n</code></pre>  Download this example as a CM file."},{"location":"automations/languages/rust/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/languages/rust/approve-rust-log-output/","title":"Approve Rust Log Output Changes","text":"<p>Approve changes to Rust files that only affect lines of code that invoke the logging marcos.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>All files end in <code>.rs</code></li> <li>The changes only affect lines of code that invoke <code>print</code>, <code>println</code> or <code>dbg</code> macros or use the <code>log</code> crate macros.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>log-output-only</code> label</li> <li>Approve the PR</li> <li>Post a comment explaining that the change only affects logging output.</li> </ul> <p>Approve Rust Log Output Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_rust_log_output:\n# Triggered for Rust changes that only affect the logging macros\nif: - {{ files | extensions | match(term='rs') | every }}\n- {{ source.diff.files | matchDiffLines(regex=r/^.*\\b(println|print|dbg|error|warn|info|debug|trace)\\b!/, ignoreWhiteSpaces=true) | every }}\nrun: - action: add-label@v1\nargs:\nlabel: 'log-output-only'\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR has been approved because it only contains changes to log output\n</code></pre>  Download this example as a CM file."},{"location":"automations/percent-new-code/","title":"Calculate the Percentage of New Code","text":"<p>Post a comment that indicates what percentage of the PR contains new code.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>Any PR</li> </ul> <p>Automation Actions:</p> <ul> <li>Use the <code>changes</code> custom expression to post a comment that indicates what percentage of the PR is new code.</li> </ul> <p>Calculate the Percentage of New Code</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\npercent_new_code:\nif:\n- true\nrun: - action: add-comment@v1\nargs:\ncomment: |\nThis PR is {{ changes.ratio }}% new code.\nchanges:\n# Sum all the lines added/edited in the PR\nadditions: {{ branch.diff.files_metadata | map(attr='additions') | sum }}\n# Sum all the line removed in the PR\ndeletions: {{ branch.diff.files_metadata | map(attr='deletions') | sum }}\n# Calculate the ratio of new code\nratio: {{ (changes.additions / (changes.additions + changes.deletions)) * 100 | round(2) }}\n</code></pre>  Download this example as a CM file."},{"location":"automations/percent-new-code/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/pr-checklist-general/","title":"PR Checklist General","text":"<p>Automatically evaluate PRs against code requirement checklists.</p> <p></p> <p>Configuration Description</p> <p>There are no conditions for this action - if included as presented in the demo, it's run every time.</p> <p>Automation Actions:</p> <ul> <li>Post a comment containing a checklist with each completed item checked off.</li> </ul> <p>PR Checklist General</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nchecklist: if:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: {{ \"\" | checklist(branch, files, pr, repo, env, source) }}\n</code></pre>  Download this example as a CM file."},{"location":"automations/pr-checklist-general/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/provide-estimated-time-to-review/","title":"Provide Estimated Time to Review","text":"<p>Label all PRs with an estimated number of minutes it would take someone to review. gitStream will automatically update this label whenever a PR changes.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>Any new PR or change to an existing PR.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a color coded label that provides an estimated number of minutes someone will need to review the PR.</li> </ul> <p>Provide Estimated Time to Review</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nestimated_time_to_review:\nif:\n- true\nrun:\n- action: add-label@v1\nargs:\nlabel: \"{{ calc.etr }} min review\"\ncolor: {{ colors.red if (calc.etr &gt;= 20) else ( colors.yellow if (calc.etr &gt;= 5) else colors.green ) }}\ncalc:\netr: {{ branch | estimatedReviewTime }}\ncolors:\nred: 'b60205'\nyellow: 'fbca04'\ngreen: '0e8a16'\n</code></pre>  Download this example as a CM file."},{"location":"automations/provide-estimated-time-to-review/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/request-screenshot/","title":"Request Screenshot","text":"<p>If the PR lacks an image file, or link to an image in the description, apply a <code>no-screenshot</code> label and post a comment to request a screenshot. If the PR author updates the description, gitStream will remove the label.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR description lacks an image or link to an image.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>no-screenshot</code> label.</li> <li>Post a comment that requests a screenshot. Update this action to provide specific context for your project.</li> </ul> <p>Request Screenshot</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations: request_screenshot:\n# Triggered for PRs that lack an image file or link to an image in the PR description\nif:\n- {{ not (has.screenshot_link or has.image_uploaded) }}\nrun:\n- action: add-label@v1\nargs:\nlabel: 'no-screenshot'\ncolor: '#FF000A'\n- action: add-comment@v1\nargs:\ncomment: |\nBe a life saver \ud83d\udedf by adding a screenshot of the changes you made.\nhas:\nscreenshot_link: {{ pr.description | includes(regex=r/!\\[.*\\]\\(.*(jpg|svg|png|gif|psd).*\\)/) }}\nimage_uploaded: {{ pr.description | includes(regex=r/&lt;img.*src.*(jpg|svg|png|gif|psd).*&gt;/) }}\n</code></pre>  Download this example as a CM file."},{"location":"automations/request-screenshot/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/branch-management/","title":"Manage git Branches With gitStream","text":"<p>Use gitStream to enforce branch naming conventions, review assignment, and other branch managment workflows.</p> <p>Enforce Branch Naming Conventions - Automatically enforce prefixes or keywords in PR branch names.</p> <p>Branch-Based Review Policies - Automatically assign PR reviewers for target branches that include a specified keyword.</p> <p></p>"},{"location":"automations/standard/branch-management/#enforce-branch-naming-conventions","title":"Enforce Branch Naming Conventions","text":"<p>Automatically enforce prefixes or keywords in PR branch names.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The incoming branch name is missing a required prefix <code>feature</code> <code>fix</code> or <code>stable</code></li> <li>The invoming branch name fails to match a specified regex pattern. In this case <code>abc-</code> followed by a number.</li> <li>The incoming branch name is not listed in an <code>ignoreList</code> custom expression.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment explaining the branch name requirements.</li> <li>Apply a red label: <code>\u2757 Incorrect Branch Name</code></li> <li>Close the PR.</li> </ul> <p>Enforce Branch Naming Conventions</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nenforce_branch_name: if:  - {{ not has.requiredBranchPrefix }}\n- {{ not has.requiredBranchKeyword }}\n- {{ not ignoreList }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\u2757 Incorrect Branch Name\"\ncolor: {{ colors.red }}\n- action: add-comment@v1\nargs:\ncomment: |\nAll PR branch names must be prefixed by feature, stable, or fix, and must contain a reference to a Jira ticket. E.g. 'feature-abc-1234'\nPlease move your changes to a new branch that meets these requirements and open a new PR.\n- action: close@v1\nhas:\nrequiredBranchPrefix: {{ branch.name | includes(regex=r/^(feature|stable|fix)/) }}\nrequiredBranchKeyword: {{ branch.name | includes(regex=r/abc+-\\d+/) }}\nignoreList: {{ branch.name | match(regex=r/^(development|staging)/) }}\n</code></pre>  Download this example as a CM file. </p> <p></p>"},{"location":"automations/standard/branch-management/#branch-based-review-policies","title":"Branch-Based Review Policies","text":"<p>Automatically route and manage PRs based on the target or destination branch.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The target or source branch name contains a specified prefix.</li> </ul> <p>Automation Actions:</p> <ul> <li>Implement custom review policies for the branch.</li> </ul> By Target BranchBy Source Branch <p>Review Target Branch</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in branches %}\nreview_target_branch_{{ item.name }}: if:       - {{ pr.target| match(regex=item.prefix) }}\nrun:\n- action: set-required-approvals@v1\nargs:\napprovals: {{ item.reviews }}\n- action: add-comment@v1\nargs: comment: | PRs to the {{ item.name }} branch require {{ item.reviews }} review(s).\n- action: add-reviewers@v1\nargs:\nreviewers: [{{ item.reviewers }}]\n{% endfor %}\nbranches:\n- name: Release\nprefix: r/^release/\nreviewers: org/release-team\nreviews: 4\n- name: Experimental\nprefix: r/^experimental-/\nreviewers: org/experiment-team\nreviews: 1\n</code></pre>  Download this example as a CM file. </p> <p>Review Source Branch</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in branches %}\nreview_source_branch{{ item.name }}: if:       - {{ branch.name | match(regex=item.prefix) }}\nrun:\n- action: set-required-approvals@v1\nargs:\napprovals: {{ item.reviews }}\n- action: add-comment@v1\nargs: comment: | Reviewers from the {{ item.name }} team have automatically been assigned to this PR.\n- action: add-reviewers@v1\nargs:\nreviewers: [{{ item.reviewers }}]\n{% endfor %}\nbranches:\n- name: ABC\nprefix: r/^ABC/\nreviewers: org/a-team\n- name: XYZ\nprefix: r/^XYZ-/\nreviewers: org/x-team\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/standard/branch-management/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Assign additional reviewers for large PRs</li> <li>Assign or suggest reviewers based on level of code expertise for the code changed in a PR.</li> <li>Assign reviewers based on modified directories and files</li> <li>Assign reviewers to share knowledge based on pre-determined criteria</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/branch-management/enforce-branch-name/","title":"Enforce Branch Naming Conventions","text":"<p>Automatically enforce prefixes or keywords in PR branch names.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The incoming branch name is missing a required prefix <code>feature</code> <code>fix</code> or <code>stable</code></li> <li>The invoming branch name fails to match a specified regex pattern. In this case <code>abc-</code> followed by a number.</li> <li>The incoming branch name is not listed in an <code>ignoreList</code> custom expression.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment explaining the branch name requirements.</li> <li>Apply a red label: <code>\u2757 Incorrect Branch Name</code></li> <li>Close the PR.</li> </ul> <p>Enforce Branch Naming Conventions</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nenforce_branch_name: if:  - {{ not has.requiredBranchPrefix }}\n- {{ not has.requiredBranchKeyword }}\n- {{ not ignoreList }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\u2757 Incorrect Branch Name\"\ncolor: {{ colors.red }}\n- action: add-comment@v1\nargs:\ncomment: |\nAll PR branch names must be prefixed by feature, stable, or fix, and must contain a reference to a Jira ticket. E.g. 'feature-abc-1234'\nPlease move your changes to a new branch that meets these requirements and open a new PR.\n- action: close@v1\nhas:\nrequiredBranchPrefix: {{ branch.name | includes(regex=r/^(feature|stable|fix)/) }}\nrequiredBranchKeyword: {{ branch.name | includes(regex=r/abc+-\\d+/) }}\nignoreList: {{ branch.name | match(regex=r/^(development|staging)/) }}\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/standard/branch-management/enforce-branch-name/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Assign additional reviewers for large PRs</li> <li>Assign or suggest reviewers based on level of code expertise for the code changed in a PR.</li> <li>Assign reviewers based on modified directories and files</li> <li>Assign reviewers to share knowledge based on pre-determined criteria</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/enforce-copyright-header/","title":"Enforce Copyright Headers","text":"<p>Automatically require copyright headers for all new source code files.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates a new file inside the /src directory that lacks a specified copyright header at the top of the file.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment that explains the copyright header requirement.</li> </ul> <p>Enforce Copyright Headers</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nenforce_copyright_header: if:   - {{ source.diff.files | filter(attr='new_file', regex=r/src\\//) | map(attr='original_file') | match(regex=r/^$/) | some }}\n- {{ source.diff.files | matchDiffLines(regex=licence.licenceRegex) | nope }}\nrun:\n- action: add-comment@v1\nargs: comment: | All new files in the '/src' directory must include the required copyright header at the top of the file. For example:\n// Copyright (c) ORG  and contributors. All rights reserved.\n// Licensed under the MIT license. See LICENSE file in the project root for details.\nlicence:\nlicenceRegex: r/(Copyright \\(c\\) )|(Licensed under the MIT license)/\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/standard/enforce-copyright-header/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Require changelog updates for PRs to specific branches</li> <li>Flag the use of deprecated APIs, functions, or other components.</li> <li>Restrict portions of your code base to authorized teams only.</li> <li>Require changes when PRs include !important tags in CSS files</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/enforce-pr-title/","title":"Enforce PR Semantic Title Names","text":"<p>Automatically enforce PR naming conventions; this example expects the format: <code>&lt;type&gt;(&lt;scope&gt;): &lt;short summary&gt;</code></p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR fails to follow a predefined semantic release format:</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment explaining why.</li> </ul> <p>Enforce PR Semantic Title Names</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nenforce_pr_title: if:       - {{ pr.title | match(regex=titlePolicy.titleRegex) | nope }}\nrun:\n- action: request-changes@v1\nargs: comment: | All PRs must be titled according to our semantic naming policy: `&lt;type&gt;(&lt;scope&gt;): &lt;short summary&gt;`\nType must be one of the following:\n* build\n* ci \n* docs\n* feature\n* fix\nScope must be one of the following:\n* common\n* core\n* elements\n* forms\n* http \ntitlePolicy:\ntitleRegex: r/\\b(build|ci|docs|feature|fix)\\b\\s*\\((common|core|elements|forms|http)\\):\\s*\\w+.*/\n</code></pre>  Download this example as a CM file."},{"location":"automations/standard/enforce-pr-title/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Require changelog updates for PRs to specific branches</li> <li>Flag the use of deprecated APIs, functions, or other components.</li> <li>Restrict portions of your code base to authorized teams only.</li> <li>Require changes when PRs include !important tags in CSS files</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/explain-code-experts/","title":"Explain Code Experts","text":"<p>Post a comment that uses git blame and history to list the most relevant experts for all PRs. The comment will automatically update as additional commits are added to the PR.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR has the 'suggest-reviewer' label.</li> </ul> <p>Explicit Triggers:</p> <ul> <li>When a PR is created (<code>pr_created</code>)</li> <li>When a PR becomes ready for review (<code>pr_ready_for_review</code>)</li> <li>When a new commit is pushed to the PR (<code>commit</code>)</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment that identifies the people with the highest level of code expertise.</li> </ul> <p>Explain Code Experts</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nexplain_code_experts:\non:\n- pr_created\n- pr_ready_for_review\n- commit\nif:\n- {{ pr.labels | match(term='suggest-reviewer') | some }}\nrun:\n- action: explain-code-experts@v1\nargs:\ngt: 10\n</code></pre>  Download this example as a CM file."},{"location":"automations/standard/explain-code-experts/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Assign additional reviewers for large PRs</li> <li>Assign reviewers based on modified directories and files</li> <li>Assign reviewers to share knowledge based on pre-determined criteria</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/flag-merged-no-review/","title":"Flag Code That's Merged Without Review","text":"<p>Automatically send notifications to your team when code is merged without review.</p> <p></p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is merged without at least one review.</li> </ul> <p>Automation Actions:</p> <ul> <li>Send a Slack notification to alert your team.</li> <li>Apply a red <code>DCF5-merged-without-review</code> label.</li> <li>Post a comment explaining SOC II requirements.</li> </ul> <p>Flag Code That's Merged Without Review</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- merge\n# https://docs.gitstream.cm/automation-actions/#send-slack-message\nslack_webhook: {{ env.SLACK_WEBHOOK }}\n# Update security_team to match your organization\nsecurity_team: 'my-org/app-sec'\nautomations:\nflag_merged_no_review:\nif:\n- {{ pr.approvals | length == 0 }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"DCF5-merged-without-review\"\ncolor: {{ colors.red }}\n- action: send-slack-message@v1\nargs:\nmessage: \"PR #{{ pr.number }} - {{ pr.title }} - was merged without peer reviews. SOC2 requires code reviews for every code change. _SOC2 ref: CC8.1_\"\nwebhook_url: \"{{ slack_webhook }}\"\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR was merged without peer reviews. SOC2 requires code reviews for every code change.\n_SOC2 ref: CC8.1_\n@{{ security_team }}\ncolors:\nred: 'F6443B'\n</code></pre>  Download this example as a CM file."},{"location":"automations/standard/label-management/","title":"PR Label Management with gitStream","text":"<p>Use YAML to automate label management on your git repo with gitStream.</p> <p></p>"},{"location":"automations/standard/label-management/#enforce-required-labels","title":"Enforce Required Labels","text":"<p>Automatically enforce the use of required PR labels.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR lacks one or more labels from a list of required labels.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>Missing Required Labels</code> label.</li> <li>Post a comment explaining why the label was applied and which labels are required.</li> </ul> <p>Enforce Required Labels</p> <p><pre><code>manifest:\nversion: 1.0\nautomations:\nenforce_required_labels:\nif:\n- {{ pr.labels | match(list=['Core', 'Mobile', 'UI']) | nope }}\nrun:\n- action: request-changes@v1\nargs:\ncomment: Please ensure that your PR is labeled with either 'Core', 'Mobile', or 'UI'. These labels help us to better track and manage your contribution. Thank you.\n</code></pre>  Download this example as a CM file. <p></p>"},{"location":"automations/standard/label-management/#label-modified-resources","title":"Label Modified Resources","text":"<p>Apply a label to all PRs that indicates what percentage of new lines of code modify one or more specified resources.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR modifies resources listed in one or more specified locations.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply labels that indicate what percentage of new code lines modify the specified resources.</li> </ul> <p>Label Changed Resources By Percent</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in labels %}\nlabel_resource_percent_{{ item.name }}:\nif:\n- {{ files | match(list=item.resources) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: '{{ item.additions | round }}% {{ item.name }}'\n{% endfor %}\nresources:\ncore:\n- src/app\n- src/core\nmobile: - src/android\n- src/ios\ndocs:\n- docs/\nlabels:\n- name: Core\nresources: {{ resources.core }}\nadditions: {{ branch.diff.files_metadata | filter(attr='file', list=resources.core ) | map(attr='additions') | sum / total.additions * 100 }}\n- name: Mobile\nresources: {{ resources.mobile }}\nadditions: {{ branch.diff.files_metadata | filter(attr='file', list=resources.mobile ) | map(attr='additions') | sum / total.additions * 100 }}\n- name: Docs\nresources: {{ resources.docs }}\nadditions: {{ branch.diff.files_metadata | filter(attr='file', list=resources.docs ) | map(attr='additions') | sum / total.additions * 100 }}\ntotal:\nadditions: {{ branch.diff.files_metadata | map(attr='additions') | sum }}\n</code></pre>  Download this example as a CM file. <p></p>"},{"location":"automations/standard/label-management/#label-prs-by-language","title":"Label PRs by Language","text":"<p>Automatically detect which programming languages are contained in PRs and automatically label the PRs appropriately.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created or updated.</li> </ul> <p>Automation Actions:</p> <ul> <li>Label the PR for each programming language that is included.</li> </ul> <p>Label PRs by Language</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in labels %}\nlabel_{{ item.name }}_pr:\nif:\n- {{ files | match(regex=item.resources) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: '{{ item.name }}'\n{% endfor %}\nlabels:\n- name: Java\nresources: r/.java$/\n- name: Rust\nresources: r/.rs$/\n- name: HTML\nresources: r/.html$/\n- name: JavaScript\nresources: r/.js$/\n- name: Python\nresources: r/.py$/\n- name: Golang\nresources: r/.go$/\n- name: Ruby\nresources: r/.rb$/\n- name: CSS\nresources: r/.css/\n</code></pre>  Download this example as a CM file. </p> <p></p>"},{"location":"automations/standard/label-management/#label-the-number-of-unresolved-code-review-threads","title":"Label the Number of Unresolved Code Review Threads","text":"<p>Automatically label PRs when there are unresolved code review comments.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR has one or more unresolved code review comments.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a label that indicates how many unresolved comments the PR has.</li> </ul> <p>Label Unresolved Review Threads</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_unresolved_threads:\nif:\n- {{ pr.unresolved_threads &gt; 0 }}\nrun:\n- action: add-label@v1\nargs:\nlabel: {{ pr.unresolved_threads }} Unresolved Thread(s)\ncolor: {{ colors.yellow }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file. <p></p>"},{"location":"automations/standard/label-management/#automatically-recommend-labels-for-new-prs","title":"Automatically Recommend Labels for New PRs","text":"<p>Automatically suggest labels to apply to new PRs.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created or updated that has no labels.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment that suggest labels the author can apply to the PR.</li> </ul> <p>Suggest Labels</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nsuggest_labels:  if:  - {{ pr.labels | length == 0}}\nrun:\n- action: add-comment@v1\nargs: comment: | All PRs must contain labels that indicate which CI/CD systems must be run. PLease update your PR to include one of the following labels: `Build: Mobile`, `Build: UI`, `Build: All`, `Build: None`\nAdditionally, Here are some labels you can apply to this PR that may be helpful:\n* Suggest Reviewer - Use this if you aren't sure who to assign as the reviewer.\n* WIP - Indicate this is a work in progress that shouldn't be merged.\n</code></pre>  Download this example as a CM file. <p></p>"},{"location":"automations/standard/label-management/#label-prs-with-the-number-of-approvals","title":"Label PRs with the Number of Approvals","text":"<p>Automatically label PRs with the number of completed reviews that approve the PR.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created or updated.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply or update a label that indicates how many merge approvals have been granted.</li> </ul> <p>Label the Number of Approvals</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_approvals: if:  - {{ pr.approvals | length &gt; 0 }}\nrun:\n- action: add-label@v1\nargs:\nlabel: {{ pr.approvals | length }} Approved Review(s)\n</code></pre>  Download this example as a CM file."},{"location":"automations/standard/label-management/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p> <p>Special thanks to Boemo W Mmopelwa for help with these examples.</p>"},{"location":"automations/standard/label-management/enforce-labels/","title":"Enforce Required Labels","text":"<p>Automatically enforce the use of required PR labels.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR lacks one or more labels from a list of required labels.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>Missing Required Labels</code> label.</li> <li>Post a comment explaining why the label was applied and which labels are required.</li> </ul> <p>Enforce Required Labels</p> <p><pre><code>manifest:\nversion: 1.0\nautomations:\nenforce_required_labels:\nif:\n- {{ pr.labels | match(list=['Core', 'Mobile', 'UI']) | nope }}\nrun:\n- action: request-changes@v1\nargs:\ncomment: Please ensure that your PR is labeled with either 'Core', 'Mobile', or 'UI'. These labels help us to better track and manage your contribution. Thank you.\n</code></pre>  Download this example as a CM file."},{"location":"automations/standard/label-management/enforce-labels/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/label-management/label-approvals/","title":"Label the Number of Approvals","text":"<p>Automatically label PRs with the number of completed reviews that approve the PR.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created or updated.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply or update a label that indicates how many merge approvals have been granted.</li> </ul> <p>Label the Number of Approvals</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_approvals: if:  - {{ pr.approvals | length &gt; 0 }}\nrun:\n- action: add-label@v1\nargs:\nlabel: {{ pr.approvals | length }} Approved Review(s)\n</code></pre>  Download this example as a CM file."},{"location":"automations/standard/label-management/label-approvals/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/label-management/label-modified-resources/","title":"Label Based on Modified Resources","text":"<p>Automatically label PRs to indicate what resources are being changed.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created or updated.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply labels based on the branch name or modified resources.</li> </ul> <p>Label Modified Resources</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in labels %}\nlabel_resource_{{ item.name }}:\nif:\n-{{ branch.name | includes(regex=item.branch) or files | match(list=item.resources) }}\nrun:\n- action: add-label@v1\nargs:\nlabel: {{ item.name }}\n{% endfor %}\nlabels:\n- name: Core\nresources:\n- src/app\nbranch: r/^core-/\n- name: mobile\nresources:\n- src/android\n- src/ios\nbranch: r/^mobile-/\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/standard/label-management/label-modified-resources/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/label-management/label-prs-by-language/","title":"Label PRs by Language","text":"<p>Automatically detect which programming languages are contained in PRs and automatically label the PRs appropriately.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created or updated.</li> </ul> <p>Automation Actions:</p> <ul> <li>Label the PR for each programming language that is included.</li> </ul> <p>Label PRs by Language</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in labels %}\nlabel_{{ item.name }}_pr:\nif:\n- {{ files | match(regex=item.resources) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: '{{ item.name }}'\n{% endfor %}\nlabels:\n- name: Java\nresources: r/.java$/\n- name: Rust\nresources: r/.rs$/\n- name: HTML\nresources: r/.html$/\n- name: JavaScript\nresources: r/.js$/\n- name: Python\nresources: r/.py$/\n- name: Golang\nresources: r/.go$/\n- name: Ruby\nresources: r/.rb$/\n- name: CSS\nresources: r/.css/\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/standard/label-management/label-prs-by-language/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/label-management/label-resources-percent/","title":"Label Changed Resources By Percent","text":"<p>Apply a label to all PRs that indicates what percentage of new lines of code modify one or more specified resources.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR modifies resources listed in one or more specified locations.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply labels that indicate what percentage of new code lines modify the specified resources.</li> </ul> <p>Label Changed Resources By Percent</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in labels %}\nlabel_resource_percent_{{ item.name }}:\nif:\n- {{ files | match(list=item.resources) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: '{{ item.additions | round }}% {{ item.name }}'\n{% endfor %}\nresources:\ncore:\n- src/app\n- src/core\nmobile: - src/android\n- src/ios\ndocs:\n- docs/\nlabels:\n- name: Core\nresources: {{ resources.core }}\nadditions: {{ branch.diff.files_metadata | filter(attr='file', list=resources.core ) | map(attr='additions') | sum / total.additions * 100 }}\n- name: Mobile\nresources: {{ resources.mobile }}\nadditions: {{ branch.diff.files_metadata | filter(attr='file', list=resources.mobile ) | map(attr='additions') | sum / total.additions * 100 }}\n- name: Docs\nresources: {{ resources.docs }}\nadditions: {{ branch.diff.files_metadata | filter(attr='file', list=resources.docs ) | map(attr='additions') | sum / total.additions * 100 }}\ntotal:\nadditions: {{ branch.diff.files_metadata | map(attr='additions') | sum }}\n</code></pre>  Download this example as a CM file."},{"location":"automations/standard/label-management/label-resources-percent/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/label-management/label-unresolved-threads/","title":"Label Unresolved Review Threads","text":"<p>Automatically label PRs when there are unresolved code review comments.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR has one or more unresolved code review comments.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a label that indicates how many unresolved comments the PR has.</li> </ul> <p>Label Unresolved Review Threads</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_unresolved_threads:\nif:\n- {{ pr.unresolved_threads &gt; 0 }}\nrun:\n- action: add-label@v1\nargs:\nlabel: {{ pr.unresolved_threads }} Unresolved Thread(s)\ncolor: {{ colors.yellow }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"automations/standard/label-management/label-unresolved-threads/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/label-management/suggest-labels/","title":"Suggest Labels","text":"<p>Automatically suggest labels to apply to new PRs.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created or updated that has no labels.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment that suggest labels the author can apply to the PR.</li> </ul> <p>Suggest Labels</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nsuggest_labels:  if:  - {{ pr.labels | length == 0}}\nrun:\n- action: add-comment@v1\nargs: comment: | All PRs must contain labels that indicate which CI/CD systems must be run. PLease update your PR to include one of the following labels: `Build: Mobile`, `Build: UI`, `Build: All`, `Build: None`\nAdditionally, Here are some labels you can apply to this PR that may be helpful:\n* Suggest Reviewer - Use this if you aren't sure who to assign as the reviewer.\n* WIP - Indicate this is a work in progress that shouldn't be merged.\n</code></pre>  Download this example as a CM file."},{"location":"automations/standard/label-management/suggest-labels/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/link-issue-tracker/","title":"Automatic Project Tracker Links","text":"<p>Post a PR comment that links the associated resource in your issue tracker, such as Jira, Azure Boards, Shortcut, Asana, and more.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains a reference to project tracking tickets in the title or branch name.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment that provides a link to the associated project tracking resource.</li> </ul> <p>Link Issue Tracker</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\n# Configure these to match your organization.\nprovider: jira\norgName: org\nasanaProject: 1234\nazureProject: my_project\n{% set ticketid = \"\" %}\n{% for ticket in tickets %}\n{% if (ticket | includes(regex=r/.+/)) %}\n{% set ticketid = ticket %}\n{% endif %}\n{% endfor %}\nautomations:\ncomment_issue_tracker:\nif:\n- {{ has.ticket_in_title or has.ticket_in_branch }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: Issue Tracker Link - [{{ticketid}}]({{tracker[provider].baseurl}}{{ticketid}})\nhas:\nticket_in_title: {{ pr.title | includes(regex=tracker[provider].pattern) }}\nticket_in_branch: {{ branch.name | includes(regex=tracker[provider].pattern) }}\ntracker:\njira:\nbaseurl: https://{{orgName}}.atlassian.net/browse/\npattern: r/\\b[A-Za-z]+-\\d+\\b/\nasana:\nbaseurl: https://app.asana.com/0/{{asanaProject}}/0/\npattern: r/asana-(\\d+)/\nazure:\nbaseurl: https://dev.azure.com/{{orgName}}/{{azureProject}}/_workitems/\npattern: r/(\\w+)-(\\w+)-(\\d+)/\nshortcut:\nbaseurl: https://app.shortcut.com/{{orgName}}/story/\npattern: r/(\\w+)\\/sc-(\\d+)/\ntickets:\n- {{branch.name | capture(regex=tracker[provider].pattern)}}\n- {{pr.title | capture(regex=tracker[provider].pattern)}}\n</code></pre>  Download this example as a CM file."},{"location":"automations/standard/review-assignment/","title":"Use gitStream for Automatic Code Review Assignment","text":"<p>Automatically assign code reviews based on changed resources, code expertise, branch, and more.</p> <p></p>"},{"location":"automations/standard/review-assignment/#assign-code-experts","title":"Assign Code Experts","text":"<p>When someone applies a <code>suggest-reviewers</code> label to a PR, use codeExperts to assign recommended reviewers and post a comment with the <code>explainCodeExperts</code> automation action.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR has a suggest-reviewers label attached to it.</li> </ul> <p>Automation Actions:</p> <ul> <li>Use <code>codeExperts</code> to assign recommended reviewers.</li> <li>Use <code>explainCodeExperts</code> to post a comment that lists the top code experts for the PR.</li> </ul> <p>Assign Code Experts</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nassign_code_experts:\n# Triggered when someone applies a suggest-reviewer label to a PR.\nif: - {{ pr.labels | match(term='suggest-reviewer') | some }}\n# More info about code experts\n# https://docs.gitstream.cm/filter-functions/#codeexperts\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: {{ repo | codeExperts(gt=10) }}\n- action: explain-code-experts@v1 args:\ngt: 10 </code></pre>  Download this example as a CM file. <p></p>"},{"location":"automations/standard/review-assignment/#branch-based-review-policies","title":"Branch-Based Review Policies","text":"<p>Automatically route and manage PRs based on the target or destination branch.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The target or source branch name contains a specified prefix.</li> </ul> <p>Automation Actions:</p> <ul> <li>Implement custom review policies for the branch.</li> </ul> By Target BranchBy Source Branch <p>Review Target Branch</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in branches %}\nreview_target_branch_{{ item.name }}: if:       - {{ pr.target| match(regex=item.prefix) }}\nrun:\n- action: set-required-approvals@v1\nargs:\napprovals: {{ item.reviews }}\n- action: add-comment@v1\nargs: comment: | PRs to the {{ item.name }} branch require {{ item.reviews }} review(s).\n- action: add-reviewers@v1\nargs:\nreviewers: [{{ item.reviewers }}]\n{% endfor %}\nbranches:\n- name: Release\nprefix: r/^release/\nreviewers: org/release-team\nreviews: 4\n- name: Experimental\nprefix: r/^experimental-/\nreviewers: org/experiment-team\nreviews: 1\n</code></pre>  Download this example as a CM file. </p> <p>Review Source Branch</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in branches %}\nreview_source_branch{{ item.name }}: if:       - {{ branch.name | match(regex=item.prefix) }}\nrun:\n- action: set-required-approvals@v1\nargs:\napprovals: {{ item.reviews }}\n- action: add-comment@v1\nargs: comment: | Reviewers from the {{ item.name }} team have automatically been assigned to this PR.\n- action: add-reviewers@v1\nargs:\nreviewers: [{{ item.reviewers }}]\n{% endfor %}\nbranches:\n- name: ABC\nprefix: r/^ABC/\nreviewers: org/a-team\n- name: XYZ\nprefix: r/^XYZ-/\nreviewers: org/x-team\n</code></pre>  Download this example as a CM file. </p> <p></p>"},{"location":"automations/standard/review-assignment/#review-sensitive-files","title":"Review Sensitive Files","text":"<p>Compare the changed files to a pre-defined list of files and directories in. If any files match, require a review from the team <code>my-organization/security</code>.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>Any files match the files or directories listed in the <code>sensitive_files</code> custom expression. Customize this list for your project.</li> </ul> <p>Automation Actions:</p> <ul> <li>Assign <code>my-organization/security</code> to review the PR. Customize this value to match your organization.</li> <li>Require 2 approvals.</li> <li>Post a comment that explains the automation.</li> </ul> <p>Review Sensitive Files</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n# Assign special teams to review sensitive files. \n# This requires the `sensitive` custom expression found at the bottom of this file.\nreview_sensitive_files:\n# For all files listed in the sensitive custom expression.\nif:\n- {{ files | match(list=sensitive_files) | some }}\nrun:\n# Add reviewers from the dev-leads team, and require two approvals\n# Modify `my-organization/security` to match your organization.\n- action: add-reviewers@v1\nargs:\nreviewers: [my-organization/security]\n- action: set-required-approvals@v1\nargs:\napprovals: 2\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR affects one or more sensitive files and requires review from the security team.\n# The `sensitive_file_review` automation requires this custom expression.\n# Modify this list to suit your security needs.\nsensitive_files:\n- src/app/auth/\n- src/app/routing/\n- src/app/resources/\n</code></pre>  Download this example as a CM file. <p></p>"},{"location":"automations/standard/review-assignment/#custom-team-review-policies","title":"Custom Team Review Policies","text":"<p>Automatically assign the PR author's team to review PRs.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR author is a member of one of the teams specified in the <code>teams</code> custom expression.</li> </ul> <p>Automation Actions:</p> <ul> <li>Assign that team to review the PR.</li> </ul> <p>Assign the Author's Team for Review</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in teams %}\nreview_team_{{ item.name }}: if:  - {{ pr.author_teams | match(regex=item.regex) }}\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: [{{ item.team }}] - action: add-comment@v1\nargs: comment: | This {{ item.name }} team has been automatically assigned to review this PR.\n{% endfor %}\nteams:\n- regex: r/ui-team/\nname: UI Team\nteam: org/ui-team\n- regex: r/mobile-team/\nname: Mobile\nteam: org/mobile-team\n</code></pre>  Download this example as a CM file. <p></p>"},{"location":"automations/standard/review-assignment/#distribute-code-reviews-to-share-knowledge","title":"Distribute Code Reviews to Share Knowledge","text":"<p>Require the reviewer as a previous contributor with code expertise between set thresholds when PR contains <code>Share Knowledge</code> label.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A <code>Share Knowledge</code> label has been applied to the PR</li> </ul> <p>Automation Actions:</p> <ul> <li>Choose a previous contributor between specified expertise thresholds and assign them as a reviewer.</li> <li>Post a comment explaining why this action was taken.</li> </ul> <p>Knowledge Share</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nshare_knowledge:\nif:\n- {{ pr.labels | match(term='Share Knowledge') | some }}\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: {{ repo | codeExperts(gt=30, lt=60) | random }}\n- action: add-comment@v1\nargs:\ncomment: |\ngitStream has assigned a reviewer to increase knowledge sharing on this PR.\n</code></pre>  Download this example as a CM file. <p></p>"},{"location":"automations/standard/review-assignment/#notify-watcher","title":"Notify Watcher","text":"<p>Automatically notify code reviewers based on a resource watchlist.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR modifies any files listed under the <code>watchers</code> custom expression.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment that notifies the responsible team or individual of the changes.</li> </ul> <p>Notify Watcher</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\n## change orgName to match your git organization name.\norgName: company\nautomations:\n{% for item in watchers %}\nnotify_watcher_{{ item.owner if item.owner else item.team }}:\nif:\n- {{ (files | match(list=item.files) | some) or (source.diff.files | match(attr=\"diff\", list=item.diffs) | some) }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\n@{{ item.owner if item.owner else ([\"{{ orgName }}/\", item.team] | join) }} - this PR has changes you're watching\n{% if files | match(list=item.files) | some -%}\nfiles:\n{%- for file in files | filter(list=item.files) %}\n- {{ file }}\n{%- endfor -%}\n{%- endif %}\n{% if source.diff.files | match(attr=\"diff\", list=item.diffs) | some -%}\ndiffs:\n{%- for diff in item.diffs -%}\n{%- if source.diff.files | match(attr=\"diff\", list=diff) | some %}\n- {{ diff }}\n{%- for file in source.diff.files | filter(attr=\"diff\", list=diff) | map(attr=\"new_file\") %}\n- {{ file }}\n{%- endfor -%}\n{%- endif -%}\n{%- endfor -%}\n{%- endif %}\n- action: add-reviewers@v1\nargs:\nreviewers: {{ item.owner }}\nteam_reviewers: {{ item.team }}\n{% endfor %}\nwatchers:\n- owner: juliaspencer\nfiles:\n- src/auth\n- team: release\nfiles:\n- package.json\n- yarn.lock\n</code></pre>  Download this example as a CM file."},{"location":"automations/standard/review-assignment/assign-code-experts/","title":"Assign Code Experts","text":"<p>When someone applies a <code>suggest-reviewers</code> label to a PR, use codeExperts to assign recommended reviewers and post a comment with the <code>explainCodeExperts</code> automation action.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR has a suggest-reviewers label attached to it.</li> </ul> <p>Automation Actions:</p> <ul> <li>Use <code>codeExperts</code> to assign recommended reviewers.</li> <li>Use <code>explainCodeExperts</code> to post a comment that lists the top code experts for the PR.</li> </ul> <p>Assign Code Experts</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nassign_code_experts:\n# Triggered when someone applies a suggest-reviewer label to a PR.\nif: - {{ pr.labels | match(term='suggest-reviewer') | some }}\n# More info about code experts\n# https://docs.gitstream.cm/filter-functions/#codeexperts\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: {{ repo | codeExperts(gt=10) }}\n- action: explain-code-experts@v1 args:\ngt: 10 </code></pre>  Download this example as a CM file."},{"location":"automations/standard/review-assignment/assign-code-experts/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Assign additional reviewers for large PRs</li> <li>Assign reviewers based on modified directories and files</li> <li>Assign reviewers to share knowledge based on pre-determined criteria</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/review-assignment/notify-watcher/","title":"Notify Watchlist","text":"<p>Automatically notify code reviewers based on a resource watchlist.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR modifies any files listed under the <code>watchers</code> custom expression.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment that notifies the responsible team or individual of the changes.</li> </ul> <p>Notify Watcher</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\n## change orgName to match your git organization name.\norgName: company\nautomations:\n{% for item in watchers %}\nnotify_watcher_{{ item.owner if item.owner else item.team }}:\nif:\n- {{ (files | match(list=item.files) | some) or (source.diff.files | match(attr=\"diff\", list=item.diffs) | some) }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\n@{{ item.owner if item.owner else ([\"{{ orgName }}/\", item.team] | join) }} - this PR has changes you're watching\n{% if files | match(list=item.files) | some -%}\nfiles:\n{%- for file in files | filter(list=item.files) %}\n- {{ file }}\n{%- endfor -%}\n{%- endif %}\n{% if source.diff.files | match(attr=\"diff\", list=item.diffs) | some -%}\ndiffs:\n{%- for diff in item.diffs -%}\n{%- if source.diff.files | match(attr=\"diff\", list=diff) | some %}\n- {{ diff }}\n{%- for file in source.diff.files | filter(attr=\"diff\", list=diff) | map(attr=\"new_file\") %}\n- {{ file }}\n{%- endfor -%}\n{%- endif -%}\n{%- endfor -%}\n{%- endif %}\n- action: add-reviewers@v1\nargs:\nreviewers: {{ item.owner }}\nteam_reviewers: {{ item.team }}\n{% endfor %}\nwatchers:\n- owner: juliaspencer\nfiles:\n- src/auth\n- team: release\nfiles:\n- package.json\n- yarn.lock\n</code></pre>  Download this example as a CM file."},{"location":"automations/standard/review-assignment/notify-watcher/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Assign additional reviewers for large PRs</li> <li>Assign or suggest reviewers based on level of code expertise for the code changed in a PR.</li> <li>Assign reviewers based on modified directories and files</li> <li>Assign reviewers to share knowledge based on pre-determined criteria</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/review-assignment/review-branch/","title":"Branch-Based Review Policies","text":"<p>Automatically route and manage PRs based on the target or destination branch.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The target or source branch name contains a specified prefix.</li> </ul> <p>Automation Actions:</p> <ul> <li>Implement custom review policies for the branch.</li> </ul> By Target BranchBy Source Branch <p>Review Target Branch</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in branches %}\nreview_target_branch_{{ item.name }}: if:       - {{ pr.target| match(regex=item.prefix) }}\nrun:\n- action: set-required-approvals@v1\nargs:\napprovals: {{ item.reviews }}\n- action: add-comment@v1\nargs: comment: | PRs to the {{ item.name }} branch require {{ item.reviews }} review(s).\n- action: add-reviewers@v1\nargs:\nreviewers: [{{ item.reviewers }}]\n{% endfor %}\nbranches:\n- name: Release\nprefix: r/^release/\nreviewers: org/release-team\nreviews: 4\n- name: Experimental\nprefix: r/^experimental-/\nreviewers: org/experiment-team\nreviews: 1\n</code></pre>  Download this example as a CM file. </p> <p>Review Source Branch</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in branches %}\nreview_source_branch{{ item.name }}: if:       - {{ branch.name | match(regex=item.prefix) }}\nrun:\n- action: set-required-approvals@v1\nargs:\napprovals: {{ item.reviews }}\n- action: add-comment@v1\nargs: comment: | Reviewers from the {{ item.name }} team have automatically been assigned to this PR.\n- action: add-reviewers@v1\nargs:\nreviewers: [{{ item.reviewers }}]\n{% endfor %}\nbranches:\n- name: ABC\nprefix: r/^ABC/\nreviewers: org/a-team\n- name: XYZ\nprefix: r/^XYZ-/\nreviewers: org/x-team\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/standard/review-assignment/review-branch/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Assign additional reviewers for large PRs</li> <li>Assign or suggest reviewers based on level of code expertise for the code changed in a PR.</li> <li>Assign reviewers based on modified directories and files</li> <li>Assign reviewers to share knowledge based on pre-determined criteria</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/review-assignment/review-sensitive-files/","title":"Review Sensitive Files","text":"<p>Compare the changed files to a pre-defined list of files and directories in. If any files match, require a review from the team <code>my-organization/security</code>.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>Any files match the files or directories listed in the <code>sensitive_files</code> custom expression. Customize this list for your project.</li> </ul> <p>Automation Actions:</p> <ul> <li>Assign <code>my-organization/security</code> to review the PR. Customize this value to match your organization.</li> <li>Require 2 approvals.</li> <li>Post a comment that explains the automation.</li> </ul> <p>Review Sensitive Files</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n# Assign special teams to review sensitive files. \n# This requires the `sensitive` custom expression found at the bottom of this file.\nreview_sensitive_files:\n# For all files listed in the sensitive custom expression.\nif:\n- {{ files | match(list=sensitive_files) | some }}\nrun:\n# Add reviewers from the dev-leads team, and require two approvals\n# Modify `my-organization/security` to match your organization.\n- action: add-reviewers@v1\nargs:\nreviewers: [my-organization/security]\n- action: set-required-approvals@v1\nargs:\napprovals: 2\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR affects one or more sensitive files and requires review from the security team.\n# The `sensitive_file_review` automation requires this custom expression.\n# Modify this list to suit your security needs.\nsensitive_files:\n- src/app/auth/\n- src/app/routing/\n- src/app/resources/\n</code></pre>  Download this example as a CM file."},{"location":"automations/standard/review-assignment/review-sensitive-files/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Assign additional reviewers for large PRs</li> <li>Assign or suggest reviewers based on level of code expertise for the code changed in a PR.</li> <li>Assign reviewers based on modified directories and files</li> <li>Assign reviewers to share knowledge based on pre-determined criteria</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/review-assignment/review-team/","title":"Assign the Author's Team for Review","text":"<p>Automatically assign the PR author's team to review PRs.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR author is a member of one of the teams specified in the <code>teams</code> custom expression.</li> </ul> <p>Automation Actions:</p> <ul> <li>Assign that team to review the PR.</li> </ul> <p>Assign the Author's Team for Review</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in teams %}\nreview_team_{{ item.name }}: if:  - {{ pr.author_teams | match(regex=item.regex) }}\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: [{{ item.team }}] - action: add-comment@v1\nargs: comment: | This {{ item.name }} team has been automatically assigned to review this PR.\n{% endfor %}\nteams:\n- regex: r/ui-team/\nname: UI Team\nteam: org/ui-team\n- regex: r/mobile-team/\nname: Mobile\nteam: org/mobile-team\n</code></pre>  Download this example as a CM file."},{"location":"automations/standard/review-assignment/review-team/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Assign additional reviewers for large PRs</li> <li>Assign or suggest reviewers based on level of code expertise for the code changed in a PR.</li> <li>Assign reviewers based on modified directories and files</li> <li>Assign reviewers to share knowledge based on pre-determined criteria</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/review-assignment/share-knowledge/","title":"Knowledge Share","text":"<p>Require the reviewer as a previous contributor with code expertise between set thresholds when PR contains <code>Share Knowledge</code> label.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A <code>Share Knowledge</code> label has been applied to the PR</li> </ul> <p>Automation Actions:</p> <ul> <li>Choose a previous contributor between specified expertise thresholds and assign them as a reviewer.</li> <li>Post a comment explaining why this action was taken.</li> </ul> <p>Knowledge Share</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nshare_knowledge:\nif:\n- {{ pr.labels | match(term='Share Knowledge') | some }}\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: {{ repo | codeExperts(gt=30, lt=60) | random }}\n- action: add-comment@v1\nargs:\ncomment: |\ngitStream has assigned a reviewer to increase knowledge sharing on this PR.\n</code></pre>  Download this example as a CM file."},{"location":"automations/standard/review-assignment/share-knowledge/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Assign additional reviewers for large PRs</li> <li>Assign or suggest reviewers based on level of code expertise for the code changed in a PR.</li> <li>Assign reviewers based on modified directories and files</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/review-changelog/","title":"Enforce Changelog Updates","text":"<p>Request changes if a PR that meets specified criteria lacks an update to the project's changelog.</p> <p></p> <p>Configuration Description</p> <p>Conditions (All must be true):</p> <ul> <li>The branch name contains the phrase <code>feature</code></li> <li>The PR lacks changes to the docs/changelog.md file</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a yellow label that says <code>\u26a0\ufe0f Missing Changelog</code></li> <li>Request changes and post a comment explaining why.</li> </ul> <p>Review Changelog</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n# Request changes for new features that lack changelog updates.\nreview_changelog: if: - {{ branch.name | includes(term=\"feature\") }}\n- {{ files | match(regex=r/^docs\\/changelog\\.md$/) | nope }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Changelog\"\ncolor: {{ colors.yellow }}\n- action: add-comment@v1\nargs: comment: | All new features require an update to the changelog. Please modify your PR to include any relevant changelog updates.\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file. <p>Special thanks to Boemo W Mmopelwa for providing this example.</p>"},{"location":"automations/standard/review-changelog/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Flag the use of deprecated APIs, functions, or other components.</li> <li>Restrict portions of your code base to authorized teams only.</li> <li>Require changes when PRs include !important tags in CSS files</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/standard/review-todo-comments/","title":"Review TODO Comments","text":"<p>Request changes for a PR that contains a TODO statement.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains a TODO statement</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment explaining why.</li> </ul> <p>Review TODO Comments</p> <p><pre><code>manifest:\nversion: 1.0\nautomations:\nreview_todo_comments:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/^[+].*(TODO|todo)/) | some }}\nrun:\n- action: request-changes@v1\nargs:\ncomment: |\nThis PR contains a TODO statement. Please check to see if they should be removed.\n</code></pre>  Download this example as a CM file."},{"location":"automations/standard/summarize-language-changes/","title":"Summarize Language Changes","text":"<p>Post a comment that summarizes which programming languages are contained in PRs.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment containing a table that shows the percent of total changes for each programming language present in the PR.</li> </ul> <p>Summarize Language Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non: - pr_created\nautomations:\nsummarize_language_changes:\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment:  &lt;h3&gt;Summary of Changes by Language&lt;/h3&gt;\n&lt;table&gt;\n&lt;tr&gt;\n&lt;td&gt;Language&lt;/td&gt;\n&lt;td&gt;Language Change Percentage&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Java&lt;/td&gt;\n&lt;td&gt;{{ total.java | round }}%&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;JavaScript&lt;/td&gt;\n&lt;td&gt;{{ total.javascript | round }}%&lt;/td&gt;\n&lt;/tr&gt;\n&lt;td&gt;Rust&lt;/td&gt;\n&lt;td&gt;{{ total.rust | round }}%&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Ruby&lt;/td&gt;\n&lt;td&gt;{{ total.ruby  | round }}%&lt;/td&gt;\n&lt;/tr&gt;\n&lt;td&gt;HTML&lt;/td&gt;\n&lt;td&gt;{{ total.html  | round }}%&lt;/td&gt;\n&lt;/tr&gt;\n&lt;td&gt;CSS&lt;/td&gt;\n&lt;td&gt;{{ total.css  | round }}%&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Golang&lt;/td&gt;\n&lt;td&gt;{{ total.golang  | round }}%&lt;/td&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n&lt;td&gt;Python&lt;/td&gt;\n&lt;td&gt;{{ total.python  | round }}%&lt;/td&gt;\n&lt;/tr&gt;\n&lt;/table&gt;\ntotal:\nadditions: {{ branch.diff.files_metadata | map(attr='additions') | sum }}\njava: {{ branch.diff.files_metadata | filter(attr='file', regex=r/.java$/ ) | map(attr='additions') | sum / total.additions * 100 }}\njavascript: {{ branch.diff.files_metadata | filter(attr='file', regex=r/.js$/ ) | map(attr='additions') | sum / total.additions * 100 }}\nrust: {{ branch.diff.files_metadata | filter(attr='file', regex=r/.rs$/ ) | map(attr='additions') | sum / total.additions * 100 }}\nruby: {{ branch.diff.files_metadata | filter(attr='file', regex=r/.rb$/ ) | map(attr='additions') | sum / total.additions * 100 }}\nhtml: {{ branch.diff.files_metadata | filter(attr='file', regex=r/.html$/ ) | map(attr='additions') | sum / total.additions * 100 }}\ncss: {{ branch.diff.files_metadata | filter(attr='file', regex=r/.css$/ ) | map(attr='additions') | sum / total.additions * 100 }}\ngolang: {{ branch.diff.files_metadata | filter(attr='file', regex=r/.go$/ ) | map(attr='additions') | sum / total.additions * 100 }}\npython: {{ branch.diff.files_metadata | filter(attr='file', regex=r/.py$/ ) | map(attr='additions') | sum / total.additions * 100 }}\n</code></pre>  Download this example as a CM file."},{"location":"automations/standard/summarize-language-changes/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/utilities/cm-header/","title":"CM File Header","text":"<p>This header is useful to add to the top of any configuration files you create for your organization. This will help others who want to make improvements to your configurations in the future.</p> <p>CM File Header</p> <p><pre><code># -*- mode: yaml -*-\n# +----------------------------------------------------------------------------+\n# | WARNING: This file controls repo automations, use caution when modifying   |\n# +----------------------------------------------------------------------------+\n# | This file contains one or more /:\\ gitStream automations:                  |\n# | https:// docs.gitstream.cm                                                 |\n# |                                                                            |\n# | gitStream uses YAML syntax with nunjucks templating via Jinja 2.           |\n# |                                                                            |\n# | Automations follow an \"if this, then that\" execution format.               |\n# | More info here: https://docs.gitstream.cm/how-it-works/                    |\n# |                                                                            |\n# +----------------------------------------------------------------------------+\n# /:\\ gitStream Reference Docs: \n#    Context Variables: https://docs.gitstream.cm/context-variables/\n#    Filter Functions: https://docs.gitstream.cm/filter-functions/\n#    Automation Actions: https://docs.gitstream.cm/automation-actions/\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/utilities/cm-header/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>A custom expression that makes it easy to implement color-coded labels that match the GitHub UI.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/utilities/colors-custom-expression/","title":"Colors Custom Expression","text":"<p>This automation demonstrates all of GitHub's default label colors, implemented as a <code>colors</code> custom expression. This is meant to help improve other automations rather than being used on its own.</p> <p>Colors Custom Expression</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\n# This automation demonstrates all of GitHub's default label colors.\n# This is meant to be used as a reference, not as an automation in your repo.\nautomations:\nlabel_colors:\nif:\n- true\nrun:\n- action: add-label@v1\nargs:\nlabel: \"Test Label\"\ncolor: {{ colors.green }}\n# These are all of the colors in GitHub's default label color palette.\ncolors:\nred: 'b60205'\norange: 'd93f0b'\nyellow: 'fbca04'\ngreen: '0e8a16'\nteal: '006b75'\nblue: '1d76db'\ndark-blue: '0052cc'\npurple: '5319e7'\nlight-red: 'e99695'\nlight-orange: 'f9d0c4'\nlight-yellow: 'fef2c0'\nlight-green: 'c2e0c6'\nlight-teal: 'bfdadc'\nlight-blue: 'c5def5'\nlight-dark-blue: 'bfd4f2'\nlight-purple: 'd4c5f9'\n</code></pre>  Download this example as a CM file. </p>"},{"location":"automations/utilities/colors-custom-expression/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>An informative header you can add to your CM files to help others.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"automations/welcome-newcomer/","title":"Welcome Newcomer","text":"<p>Post a welcome message when someone makes their first PR to a repo, and provide context to help them know what's next.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR author made their first contribution to the repo during the current day.</li> </ul> <p>Automation Actions:</p> <ul> <li>Add the <code>my-organization/mentors</code> team to review the PR. Customize this to match your organization.</li> <li>Apply a <code>new-contributor</code> label to the PR.</li> <li>Post a comment explaining the next steps. Customize this to match your project.</li> </ul> <p>Welcome Newcomer</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n# Help newcomers find mentors to guide them.\nwelcome_newcomer:\n# If the PR author made their first contirbution on the current day\nif:\n- {{ repo.author_age &lt; 1 and repo.age &gt; 0 }}\n# 1. Add reviewers from the team `my_organization/mentors`. Replace this string to match your organization\n# 2. Apply a new-contributor label.\n# 3 Post a comment that explains the next steps.\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: [my_organization/mentors]\n- action: add-label@v1\nargs:\nlabel: 'new-contributor'\ncolor: '#FBBD10'\n- action : add-comment@v1\nargs:\ncomment: |\nHello {{ pr.author }} \ud83d\udc4b Thanks for making your first PR, and welcome to our project!\nOur mentor team has automatically been assigned to review this PR and guide you through the process.\nPlease reach out to that team if you have questions about the next steps.\n</code></pre>  Download this example as a CM file."},{"location":"automations/welcome-newcomer/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/","title":"gitStream Integrations","text":"<p> AI Assistance</p> <p>  LinearB</p> <p> LinearB AI</p>"},{"location":"integrations/#github-gitlab","title":"GitHub / GitLab","text":"<p> GitHub Actions</p> <p> PR Labels</p> <p> Branch Management</p> <p> PR Reviews</p>"},{"location":"integrations/#ai-tools","title":"AI Tools","text":"<p> GitHub Copilot</p> <p> Cursor</p> <p> Amazon Q</p> <p> Claude Code</p> <p> Windsurf</p>"},{"location":"integrations/#security-compliance","title":"Security &amp; Compliance","text":"<p>  Orca</p> <p> SonarCloud</p> <p> Dependabot</p> <p> Jit</p> <p> Renovate</p> <p> Snyk</p> <p> SOC 2</p>"},{"location":"integrations/#project-management","title":"Project Management","text":"<p> Jira</p> <p> Asana</p> <p> Shortcut</p> <p> Azure Boards</p>"},{"location":"integrations/#chat-communications","title":"Chat &amp; Communications","text":"<p> Slack</p> <p> Microsoft Teams</p>"},{"location":"integrations/#feature-flags","title":"Feature Flags","text":"<p>DevCycle</p> <p>Launch Darkly</p> <p>Flagsmith</p> <p>Unleash</p> <p>Flagr</p>"},{"location":"integrations/#languages","title":"Languages","text":"<p> JavaScript</p> <p> Go</p> <p> Python</p> <p> Java</p> <p> Ruby</p> <p> HTML/CSS</p> <p> Rust</p>"},{"location":"integrations/#documentation","title":"Documentation","text":"<p> Swimm</p> <p> Javadoc</p> <p> JSDoc</p> <p> RDoc</p> <p> Godoc</p>"},{"location":"integrations/#other","title":"Other","text":"<p> Terraform</p> <p> Zapier</p>"},{"location":"integrations/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p>"},{"location":"integrations/LinearBAI/","title":"Integrate gitStream with LinearB's AI","text":"<p>User Commands</p> <p>LinearB's AI is available also with <code>/gs</code> user commands, read more about them here.</p>"},{"location":"integrations/LinearBAI/#automation-examples","title":"Automation Examples","text":""},{"location":"integrations/LinearBAI/#code-review-using-linearbs-ai","title":"Code Review using LinearB's AI","text":"<p>Use LinearB's AI with the <code>code-review</code> action to automatically review the introduced changes to the code.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created or new code has been committed to the PR.</li> <li>The PR is not on Draft staten and was not created by a bot.</li> </ul> <p>Automation Actions:</p> <ul> <li>Perform an AI-driven code review and append the review comments to the PR.</li> <li>Use <code>guidelines</code> to add your prompts to the team or org review.</li> <li>Use <code>issues_limit</code> to control how many issues are included in the review comment (number or <code>unlimited</code>).</li> </ul> <p>Configuration Example</p> <p><pre><code>manifest:\nversion: 1.0\nautomations:\nlinearb_ai_review:\n# Triggers only when PR is created or has new commits, see docs\n#   https://docs.gitstream.cm/execution-model/#action-level-execution-control\nif:\n- {{ not pr.draft }}\n- {{ not (is.bot_author or is.bot_branch) }}\nrun:\n- action: code-review@v1\nargs:\napprove_on_LGTM: {{ approve_pr_on_lgtm }} # optional arg, you can remove it\nissues_limit: 10 # optional arg; set to a positive integer or \"unlimited\"\nguidelines: {{ guidelines }}\n# Define variables\n# Add conditions for PR approvals. For example - allow approval only for specific users\napprove_pr_on_lgtm: false\n# Add `guidelines` to customize the code review prompts:\n# - For repository-specific guidelines: Place `REVIEW_RULES.md` at your repository root\n# - For organization-wide guidelines: Place the file in your CM repository root and use `../cm/REVIEW_RULES.md`\n# - For team-specific guidelines: Place the file in the team repository root\n# The `dump` filter ensures proper YAML formatting when the file content is inserted\nguidelines: {{ \"./REVIEW_RULES.md\" | readFile() | dump }}\nis:\nbot_author: {{ pr.author | match(list=['github-actions', '_bot_', '[bot]', 'dependabot']) | some }}\nbot_branch: {{ branch.name | match(list=['renovate/']) | some }}\n</code></pre>  Download this example as a CM file. </p>"},{"location":"integrations/LinearBAI/#localization-support","title":"Localization Support","text":"<p>You can request the AI to provide code review comments in your preferred language by adding it to the guidelines:</p> <pre><code>automations:\nlinearb_ai_review:\nif:\n- {{ not pr.draft }}\nrun:\n- action: code-review@v1\nargs:\nguidelines: |\n- Use Spanish language for all comments\n- Focus on code quality and best practices\n</code></pre>"},{"location":"integrations/LinearBAI/#repository-rules-file-example","title":"Repository rules file example","text":"<ol> <li> <p>Add the rules file to your repo root:</p> ./REVIEW_RULES.md<pre><code>- Do not comment on missing documentation.\n- Do not comment on missing tests.\n- For JavaScript code, enforce using camelCase for variables and functions.\n</code></pre> </li> <li> <p>Load the file in the code review automation:</p> <pre><code>automations:\n  linearb_ai_review:\n    if:\n      - {{ not pr.draft }}\n    run:\n      - action: code-review@v1\n        args:\n          guidelines: {{ \"./REVIEW_RULES.md\" | readFile() | dump }}\n</code></pre> </li> </ol>"},{"location":"integrations/LinearBAI/#pr-description-using-linearbs-ai","title":"PR Description Using LinearB's AI","text":"<p>Use the <code>describe-changes</code> automation action to automatically generate and append a concise, AI-generated description to a pull request. This ensures that all PRs include meaningful and helpful descriptions, improving review efficiency.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created or new code has been committed to the PR.</li> </ul> <p>Automation Actions:</p> <ul> <li>Append the AI-generated description to the PR description.</li> </ul> <p>Configuration Example</p> <p><pre><code>manifest:\nversion: 1.0\nautomations:\nlinearb_ai_description:\n# Triggers only when PR is created or has new commits, see docs\n#   https://docs.gitstream.cm/execution-model/#action-level-execution-control\n# Skip description for Draft PRs and PRs from bots\nif:\n- {{ not pr.draft }}\n- {{ not (is.bot_author or is.bot_branch) }}\nrun:\n- action: describe-changes@v1\nargs:\nconcat_mode: append\nis:\nbot_author: {{ pr.author | match(list=['github-actions', '_bot_', '[bot]', 'dependabot']) | some }}\nbot_branch: {{ branch.name | match(list=['renovate/']) | some }}\n</code></pre>  Download this example as a CM file. </p>"},{"location":"integrations/LinearBAI/#localization-support_1","title":"Localization Support","text":"<p>You can request the AI to add PR descriptions in your preferred language by adding it to the guidelines:</p> <pre><code>automations:\nlinearb_ai_desc:\nif:\n- {{ not pr.draft }}\nrun:\n- action: describe-changes@v1\nargs:\nconcat_mode: append\nguidelines: |\n- Use Korean language for all comments\n</code></pre>"},{"location":"integrations/LinearBAI/#repository-rules-file-example_1","title":"Repository rules file example","text":"<ol> <li> <p>Add the rules file to your repo root:</p> ./DESCRIPTION_RULES.md<pre><code>-  Add emojis to highlight important changes.\n-  Use clear and concise language.\n-  Avoid using jargon or technical terms.\n</code></pre> </li> <li> <p>Load the file in the PR descriptions automation:</p> <pre><code>automations:\n  linearb_ai_desc:\n    if:\n      - {{ not pr.draft }}\n    run:\n      - action: describe-changes@v1\n        args:\n          concat_mode: append\n          guidelines: {{ \"./DESCRIPTION_RULES.md\" | readFile() | dump }}\n</code></pre> </li> </ol>"},{"location":"integrations/LinearBAI/#additional-resources","title":"Additional Resources","text":"<p>title: gitStream Reference - User Commands description: User commands enable manual triggering of gitStream actions through PR comments.</p>"},{"location":"integrations/LinearBAI/#user-commands","title":"User Commands","text":"<p>User commands allow you to trigger specific gitStream actions manually by adding comments to pull requests. These commands provide on-demand execution of automation actions without requiring changes to your <code>.cm</code> configuration files.</p> <p>GitHub Only &amp; v2 Action Required</p> <p>User commands are only supported on GitHub and require the <code>linear-b/gitstream-github-action@v2</code>. This feature is not available on GitLab or Bitbucket.</p>"},{"location":"integrations/LinearBAI/#overview","title":"Overview","text":"<p>gitStream supports comment-triggered actions that allow you to execute specific automations on-demand. Commands are only processed when new comments are added, not when existing comments are edited.</p> <p>gitStream provides visual feedback through emoji reactions on command comments.  is added when a command is recognized and processing begins and  is added when the command has been successfully executed.</p>"},{"location":"integrations/LinearBAI/#available-commands","title":"Available Commands","text":"Command Platform Description Action <code>/gs review</code> Run an AI-powered code review on this PR Executes <code>code-review@v1</code> once on the current PR <code>/gs desc</code> Generate a description of the changes in this PR Executes <code>describe-changes@v1</code> once on the current PR with <code>concat_mode: append</code> <code>/gs etr</code> Add estimated time to review label Adds a label with the estimated review time based on the PR changes <code>/gs experts</code> Add a comment with codeExperts suggestion for current changes Executes <code>explain-code-experts@v1</code> once on the current PR <code>/gs help</code> Show help message with available commands Displays a comment with the list of all available gitStream commands <p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/amazon-q/","title":"Integrate gitStream with Amazon Q","text":""},{"location":"integrations/amazon-q/#automatically-label-amazon-q-assisted-prs","title":"Automatically Label Amazon Q-Assisted PRs","text":"<p>Automatically apply labels to PRs that are assisted by Amazon Q. You can apply labels based on a known list of Amazon Q users, PR tags, or by prompting the PR author to indicate if they used Amazon Q.</p> Label by PromptLabel by Known UsersLabel by Tag <p>Prompt PR authors to indicate if they used Amazon Q for the PR and automatically label the PR if they did. This requires two separate automation files to handle posting the prompt and labeling accordingly.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is created</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment prompting the author to indicate if Amazon Q assisted the author with writing the code in the PR.</li> </ul> <p>Ask the PR author about Amazon Q usage</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\nautomations:\ncomment_amazon_q_prompt:\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nPlease mark whether you used Amazon Q to assist coding in this PR\n- [ ] Amazon Q Assisted\n- [ ] Not Amazon Q Assisted \n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is updated or merged where the author indicates they used Amazon Q via a prompt.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Amazon Q</code> label to the PR</li> </ul> <p>Label PRs where the user indicated Amazon Q usage</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_amazon_q_pr:\nif:\n- {{ pr.comments | filter(attr='commenter', term='gitstream-cm') | filter (attr='content', regex=r/\\- \\[x\\] Amazon Q Assisted/) | some}}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Amazon Q' </code></pre>  Download this example as a CM file. </p> <p>Automatically apply labels to PRs that are created by known users of generative AI coding tools.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The PR author is one of a specified list of contributors</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Amazon Q</code> label to the PR</li> </ul> <p>Label by Contributors</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_amazon_q_contributors:\nif:\n- {{ pr.author | match(list=amazon_q_contributors) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Amazon Q'\namazon_q_contributors:\n- username1\n- username2\n- etc </code></pre>  Download this example as a CM file. </p> <p>Look for a specific tag in the PR title, description, comments or commit messages and if found add a label to the PR</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li> <p>The <code>#amazon_q#</code> tag is found in any of the PR title, description, comments or commit messages for commits in the PR Automation Actions:</p> </li> <li> <p>Apply a <code>\ud83e\udd16 Amazon Q</code> label to the PR</p> </li> </ul> <p>Label Amazon Q by Tag</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- comment_added\n- commit\n- pr_created\nautomations:\nlabel_amazon_q:\nif:\n- {{ amazon_q_tag.pr_title or amazon_q_tag.pr_desc or amazon_q_tag.pr_comments or amazon_q_tag.commit_messages }}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Amazon Q'\namazon_q_tag:\npr_title: {{ pr.title | includes(regex=r/#amazon_q#/) }}\npr_desc: {{pr.description | includes(regex=r/#amazon_q#/) }}\npr_comments: {{ pr.comments | map(attr='content') | match(regex=r/#amazon_q#/) | some }}\ncommit_messages: {{ branch.commits.messages | match(regex=r/#amazon_q#/) | some }} </code></pre>  Download this example as a CM file. </p>"},{"location":"integrations/amazon-q/#track-the-business-impact","title":"\ud83d\udcc8 Track the Business Impact","text":"<p>By labeling PRs assisted by Amazon Q, you can measure:</p> <ul> <li>Time savings (via Cycle Time, Review Time)</li> <li>PR risk (via Refactor Rate, CFR)</li> <li>Productivity lift from AI tools</li> </ul>"},{"location":"integrations/amazon-q/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/asana/","title":"Integrate gitStream with Asana","text":"<p>Learn how to integrate gitStream with Asana </p>"},{"location":"integrations/asana/#label-missing-asana-info","title":"Label Missing Asana Info","text":"<p>Automatically label PRs that are missing references to Asana resources.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR is missing an Asana ticket reference in the PR title and a link to an Asana resource in the PR description.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a red <code>\u26a0\ufe0f Missing Asana Link</code> label</li> <li>Post a comment that asks the author to add an Asana reference to the PR.</li> </ul> <p>Label Missing Asana</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_missing_asana:\nif:\n- {{not (has.asana.ticket_in_title or has.asana.ticket_in_desc)}}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Asana Link\"\ncolor: {{ colors.red }}\n- action: add-comment@v1\nargs:\ncomment: Please provide a link to the associated Asana resource.\nhas:\nasana:\nticket_in_title: {{ pr.title | includes(regex=r/asana-(\\d+)/) }}\nticket_in_desc: {{ pr.description | includes(regex=r/app\\.asana.\\com\\/(\\d+)\\/(\\d+)\\/(\\d+)\\/(\\d+)\\/(\\d+)/) }}\ncolors:\nred: 'b60205'\n</code></pre>  Download this example as a CM file. <p></p>"},{"location":"integrations/asana/#automatically-link-prs-to-related-asana-cards","title":"Automatically Link PRs to Related Asana Cards","text":"<p>Provide automatic links to Asana cards that are associated with PRs.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains a reference to an Asana card in the title or branch name.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment that provides a link to the associated Asana Card.</li> </ul> <p>Automatically Link to the Related Asana Card</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nprovider: asana\n# Configure this to match your organization. It is used in tracker.asana.baseurl.\nasanaProject: 1234\n{% set ticketid = \"\" %}\n{% for ticket in tickets %}\n{% if (ticket | includes(regex=r/.+/)) %}\n{% set ticketid = ticket %}\n{% endif %}\n{% endfor %} automations:\nlink_asana:\nif:\n- {{ has.ticket_in_title or has.ticket_in_branch }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: Issue Tracker Link - [{{ticketid}}]({{tracker[provider].baseurl}}{{ticketid}})\nhas:\nticket_in_title: {{ pr.title | includes(regex=tracker[provider].pattern) }}\nticket_in_branch: {{ branch.name | includes(regex=tracker[provider].pattern) }}\ntracker:\nasana:\nbaseurl: https://app.asana.com/0/[asanaProject]/0/\npattern: r/asana-(\\d+)/\ntickets:\n- {{branch.name | capture(regex=tracker[provider].pattern)}}\n- {{pr.title | capture(regex=tracker[provider].pattern)}}\n</code></pre>  Download this example as a CM file."},{"location":"integrations/asana/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/azure-boards/","title":"Integrate gitStream with Azure Boards","text":"<p>Learn how to integrate gitStream with Azure Boards.</p> <p></p>"},{"location":"integrations/azure-boards/#label-missing-azure-boards-info","title":"Label Missing Azure Boards Info","text":"<p>Automatically label PRs that are missing references to Azure Boards resources.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR is missing one of the following:<ul> <li>An Azure Boards ticket reference in the PR title.</li> <li>A link to an Azure Boards resource in the PR description.</li> </ul> </li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a red <code>\u26a0\ufe0f Missing Azure Boards Link</code> label</li> <li>Post a comment that asks the author to add an Azure Boards reference to the PR.</li> </ul> <p>Label Missing Azure Boards</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_missing_azure:\nif:\n- {{not (has.azure.ticket_in_title or has.azure.ticket_in_desc)}}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Azure Boards Link\"\ncolor: {{ colors.red }}\n- action: add-comment@v1\nargs:\ncomment: Please provide a link to the associated resource in Azure Boards.\nhas:\nazure:\nticket_in_title: {{ pr.title | includes(regex=r/(\\w+)-(\\w+)-(\\d+)/) }}\nticket_in_desc: {{ pr.description | includes(regex=r/(dev\\.azure\\.com|(\\w+)\\.visualstudio\\.com)\\/(\\w+)\\/(\\w+)\\/_workitems\\/edit\\/(\\d+)/) }}\ncolors:\nred: 'b60205'\n</code></pre>  Download this example as a CM file. <p></p>"},{"location":"integrations/azure-boards/#automatically-link-prs-to-related-azure-boards-resources","title":"Automatically Link PRs to Related Azure Boards Resources","text":"<p>Provide automatic links to Azure Boards resources that are associated with PRs.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains a reference to an Azure Boards resource in the title or branch name.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment that provides a link to the associated Azure Boards Resource.</li> </ul> <p>Automatically Link to the Related Azure Boards Resource</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\n# Configure these to match your organization.\nprovider: azure\n# The name of your Azure organization\norgName: org\n# The name of your Azure project\nazureProject: my_project\n{% set ticketid = \"\" %}\n{% for ticket in tickets %}\n{% if (ticket | includes(regex=r/.+/)) %}\n{% set ticketid = ticket %}\n{% endif %}\n{% endfor %}\nautomations:\nlink_azure_boards:\nif:\n- {{ has.ticket_in_title or has.ticket_in_branch }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: Issue Tracker Link - [{{ticketid}}]({{tracker[provider].baseurl}}{{ticketid}})\nhas:\nticket_in_title: {{ pr.title | includes(regex=tracker[provider].pattern) }}\nticket_in_branch: {{ branch.name | includes(regex=tracker[provider].pattern) }}\ntracker:\nazure:\nbaseurl: https://dev.azure.com/{{orgName}}/{{azureProject}}/_workitems/\npattern: r/(\\w+)-(\\w+)-(\\d+)/\ntickets:\n- {{branch.name | capture(regex=tracker[provider].pattern)}}\n- {{pr.title | capture(regex=tracker[provider].pattern)}}\n</code></pre>  Download this example as a CM file."},{"location":"integrations/azure-boards/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/claude-code/","title":"Integrate gitStream with Claude Code","text":""},{"location":"integrations/claude-code/#automation-examples","title":"Automation Examples","text":""},{"location":"integrations/claude-code/#automatically-label-claude-code-assisted-prs","title":"Automatically Label Claude Code-Assisted PRs","text":"<p>Automatically apply labels to PRs that are assisted by Claude Code. You can apply labels based on a known list of Claude Code users, PR tags, or by prompting the PR author to indicate if they used Claude Code.</p> Label Co-authorLabel by PromptLabel by Known UsersLabel by Tag <p>Automatically apply labels to PRs that are authored by Claude or have Claude as a co-author in commit messages.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The PR author's name contains \"Claude\" (case-insensitive), OR</li> <li>Any commit message in the PR contains a \"Co-Authored-By\" line with Claude</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Claude Code</code> label to the PR</li> </ul> <p>Label Claude Code by Co-author</p> <p><pre><code>manifest:\nversion: 1.0\nautomations:\ntag_claude_pr:\nif:\n- {{ is.claude_author or is.claude_co_author }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83e\udd16 Claude Code\"\nis:\nclaude_author: {{ pr.author | lower | includes(regex=r/claude/) }}\nclaude_co_author: {{ branch.commits.messages | match(regex=r/[Cc]o-[Aa]uthored-[Bb]y:.*[Cc]laude/) | some }}\n</code></pre>  Download this example as a CM file. </p> <p>Prompt PR authors to indicate if they used Claude Code for the PR and automatically label the PR if they did. This requires two separate automation files to handle posting the prompt and labeling accordingly.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is created</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment prompting the author to indicate if Claude Code assisted the author with writing the code in the PR.</li> </ul> <p>Ask the PR author about Claude Code usage.</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\nautomations:\ncomment_claude_code_prompt:\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nPlease mark whether you used Claude Code to assist coding in this PR\n- [ ] Claude Code Assisted\n- [ ] Not Claude Code Assisted \n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is updated or merged where the author indicates they used Claude Code via a prompt.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Claude Code</code> label to the PR</li> </ul> <p>Label PRs where the user indicated Claude Code usage</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_claude_code_pr:\nif:\n- {{ pr.comments | filter(attr='commenter', term='gitstream-cm') | filter (attr='content', regex=r/\\- \\[x\\] Claude Code Assisted/) | some}}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Claude Code' </code></pre>  Download this example as a CM file. </p> <p>Automatically apply labels to PRs that are created by known users of generative AI coding tools.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The PR author is one of a specified list of contributors</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Claude Code</code> label to the PR</li> </ul> <p>Label by Contributors</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_claude_code_contributors:\nif:\n- {{ pr.author | match(list=claude_code_contributors) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Claude Code'\nclaude_code_contributors:\n- username1\n- username2\n- etc </code></pre>  Download this example as a CM file. </p> <p>Look for a specific tag in the PR title, description, comments or commit messages and if found add a label to the PR</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The <code>#claude_code#</code> tag is found in any of the PR title, description, comments or commit messages for commits in the PR</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Claude Code</code> label to the PR</li> </ul> <p>Label Claude Code by Tag</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- comment_added\n- commit\n- pr_created\nautomations:\nlabel_claude_code:\nif:\n- {{ claude_code_tag.pr_title or claude_code_tag.pr_desc or claude_code_tag.pr_comments or claude_code_tag.commit_messages }}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Claude Code'\nclaude_code_tag:\npr_title: {{ pr.title | includes(regex=r/#claude_code#/) }}\npr_desc: {{pr.description | includes(regex=r/#claude_code#/) }}\npr_comments: {{ pr.comments | map(attr='content') | match(regex=r/#claude_code#/) | some }}\ncommit_messages: {{ branch.commits.messages | match(regex=r/#claude_code#/) | some }} </code></pre>  Download this example as a CM file. </p>"},{"location":"integrations/claude-code/#track-the-business-impact","title":"\ud83d\udcc8 Track the Business Impact","text":"<p>By labeling PRs assisted by Claude Code, you can measure:</p> <ul> <li>Time savings (via Cycle Time, Review Time)</li> <li>PR risk (via Refactor Rate, CFR)</li> <li>Productivity lift from AI tools</li> </ul>"},{"location":"integrations/claude-code/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/cursor/","title":"Integrate gitStream with Cursor","text":""},{"location":"integrations/cursor/#automation-examples","title":"Automation Examples","text":""},{"location":"integrations/cursor/#automatically-label-cursor-assisted-prs","title":"Automatically Label Cursor-Assisted PRs","text":"<p>Automatically apply labels to Pull Requests that are assisted by Cursor AI. This automation helps track the impact and usage of Cursor's AI capabilities across your development workflow.</p> Label by PromptLabel by Known UsersLabel by Tag <p>Prompt PR authors to indicate if they used Cursor for the PR and automatically label the PR if they did. This requires two separate automation files to handle posting the prompt and labeling accordingly.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is created</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment prompting the author to indicate if Cursor assisted the author with writing the code in the PR.</li> </ul> <p>Ask the PR author about Cursor usage</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\nautomations:\ncomment_cursor_prompt:\n# Post a comment for all PRs to prompt the PR author to indicate whether they used Cursor to assist coding in this PR\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nPlease mark whether you used Cursor to assist coding in this PR\n- [ ] Cursor Assisted\n- [ ] Not Cursor Assisted \n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is updated or merged where the author indicates they used Cursor via a prompt.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Cursor</code> label to the PR</li> </ul> <p>Label PRs where the user indicated Cursor usage</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n# You should use this automation in conjunction with comment_cursor_prompt.cm\nlabel_cursor_pr:\n# If the PR author has indicated that they used Cursor to assist coding in this PR, \n# apply a label indicating the PR was supported by Cursor\nif:\n- {{ pr.comments | filter(attr='commenter', term='gitstream-cm') | filter (attr='content', regex=r/\\- \\[x\\] Cursor Assisted/) | some}}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Cursor' </code></pre>  Download this example as a CM file. </p> <p>Automatically apply labels to PRs that are created by known users of generative AI coding tools.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The PR author is one of a specified list of contributors</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Cursor</code> label to the PR</li> </ul> <p>Label by Contributors</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_cursor_contributors:\n# For all PRs authored by someone who is specified in the cursor_contributors list\nif:\n- {{ pr.author | match(list=cursor_contributors) | some }}\n# Apply a label indicating the user has adopted Cursor\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Cursor'\ncursor_contributors:\n- username1\n- username2\n- etc </code></pre>  Download this example as a CM file. </p> <p>Look for a specific tag in the PR title, description, comments or commit messages and if found add a label to the PR</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The <code>#cursor#</code> tag is found in any of the PR title, description, comments or commit messages for commits in the PR</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Cursor</code> label to the PR</li> </ul> <p>Label Cursor by Tag</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- comment_added\n- commit\n- pr_created\nautomations:\nlabel_cursor:\n# Detect PRs that contain the text '#cursor#' in the title, description, comments, or commit messages\nif:\n- {{ cursor_tag.pr_title or cursor_tag.pr_desc or cursor_tag.pr_comments or cursor_tag.commit_messages }}\n# Apply a label indicating the user has adopted Cursor\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Cursor'\ncursor_tag:\npr_title: {{ pr.title | includes(regex=r/#cursor#/) }}\npr_desc: {{pr.description | includes(regex=r/#cursor#/) }}\npr_comments: {{ pr.comments | map(attr='content') | match(regex=r/#cursor#/) | some }}\ncommit_messages: {{ branch.commits.messages | match(regex=r/#cursor#/) | some }} </code></pre>  Download this example as a CM file. </p>"},{"location":"integrations/cursor/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/dependabot/","title":"Integrate gitStream with Dependabot","text":""},{"location":"integrations/dependabot/#approve-and-merge-dependabot-changes","title":"Approve and Merge Dependabot Changes","text":"<p>Auto-merge Dependabot PRs</p> By Release TypeAll Updates <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR author is Dependabot.</li> <li>The branch name includes 'dependabot'</li> <li>The dependency change is a patch or minor update.</li> </ul> <p>Automation Actions:</p> <ul> <li>Approve the PR</li> <li>Apply an <code>approved-dependabot</code> label to the PR</li> <li>Merge the PR if all status checks pass.</li> </ul> <p>Configuration Example</p> <p><pre><code>manifest:\nversion: 1.0\nautomations:\nmerge_dependabot_minor:\non:\n- pr_created\n- commit\nif:\n- {{ bump == 'minor' }}\n- {{ branch.name | includes(term=\"dependabot\") }}\n- {{ branch.author | includes(term=\"dependabot\") }}\nrun:\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nDependabot `minor` version bumps are approved automatically.\nmerge_dependabot_minor_patch:\non:\n- pr_created\n- commit\nif:\n- {{ bump == 'patch' }}\n- {{ branch.name | includes(term=\"dependabot\") }}\n- {{ branch.author | includes(term=\"dependabot\") }}\nrun:\n- action: approve@v1\n- action: merge@v1\n- action: add-comment@v1\nargs:\ncomment: |\nDependabot `patch` version bumps are approved and merged automatically.\nbump: {{ pr.description | checkDependabot | checkSemver }}\n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR author is Dependabot.</li> <li>The branch name includes 'dependabot'</li> </ul> <p>Automation Actions:</p> <ul> <li>Approve the PR</li> <li>Apply an <code>approved-dependabot</code> label to the PR</li> <li>Merge the PR if all status checks pass.</li> </ul> <p>Configuration Example</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_dependabot:\non:\n- pr_created\n- commit\nif:\n- {{ branch.name | includes(term=\"dependabot\") }}\n- {{ branch.author | includes(term=\"dependabot\") }}\nrun:\n- action: approve@v1\n- action: add-label@v1\nargs:\nlabel: \"approved-dependabot\"\n- action: merge@v1\nargs:\nwait_for_all_checks: true\nsquash_on_merge: true\n</code></pre>  Download this example as a CM file. </p>"},{"location":"integrations/dependabot/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/devcycle/","title":"Integrate gitStream with DevCycle","text":""},{"location":"integrations/devcycle/#label-devcycle-feature-flags","title":"Label DevCycle Feature Flags","text":"<p>Automatically label code that contians specified feature flags.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR adds one or more feature flag keys.</li> </ul> <p>Automation Actions:</p> <ul> <li>Label the PR for each feature flag key introduced in the PR.</li> </ul> <p>Label PRs Based on Feature Flags</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in feature_flags %}\nlabel_ff_devcycle_{{ item.name }}:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/key = '/) | some }}\n      - {{ source.diff.files | matchDiffLines(regex=item.regex) | some }}\n    run:\n      - action: add-label@v1\n        args:\n          label: {{ item.name }}\n          color: {{ colors.yellow }}\n  {% endfor %}\nfeature_flags:\n   - name: engineering_rollback_plan_activated \n     regex: r/engineering_rollback_plan_activated/\n   - name: marketing_premium_plan_features_unlocked \n     regex: r/marketing_premium_plan_features_unlocked/\n   - name: mobile_push_notifications_enabled\n     regex: r/mobile_push_notifications_enabled/\ncolors:\n  yellow: 'ffb300'   \n</code></pre>  Download this example as a CM file."},{"location":"integrations/devcycle/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/flagr/","title":"Integrate gitStream with Flagr","text":""},{"location":"integrations/flagr/#label-flagr-feature-flags","title":"Label Flagr Feature Flags","text":"<p>Automatically label code that contians specified feature flags.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR adds one or more feature flag keys.</li> </ul> <p>Automation Actions:</p> <ul> <li>Label the PR for each feature flag key introduced in the PR.</li> </ul> <p>Label PRs Based on Feature Flags</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in feature_flags %}\nlabel_ff_flagr_{{ item.name }}:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/evaluation_result.variant_id ==/) | some }}\n- {{ source.diff.files | matchDiffLines(regex=item.regex) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: {{ item.name }}\ncolor: {{ colors.yellow }}\n{% endfor %}\nfeature_flags:\n- name: engineering_rollback_plan_activated regex: r/engineering_rollback_plan_activated/\n- name: marketing_premium_plan_features_unlocked regex: r/marketing_premium_plan_features_unlocked/\n- name: mobile_push_notifications_enabled\nregex: r/mobile_push_notifications_enabled/\ncolors:\nyellow: 'ffb300'   </code></pre>  Download this example as a CM file."},{"location":"integrations/flagr/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/flagsmith/","title":"Integrate gitStream with Flagsmith","text":""},{"location":"integrations/flagsmith/#label-flagsmith-feature-flags","title":"Label Flagsmith Feature Flags","text":"<p>Automatically label code that contians specified feature flags.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR adds one or more feature flag keys.</li> </ul> <p>Automation Actions:</p> <ul> <li>Label the PR for each feature flag key introduced in the PR.</li> </ul> <p>Label PRs Based on Feature Flags</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in feature_flags %}\nlabel_ff_flagsmith_{{ item.name }}:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/flagsmith.hasFeature\\(/) | some }}\n- {{ source.diff.files | matchDiffLines(regex=item.regex) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: {{ item.name }}\ncolor: {{ colors.yellow }}\n{% endfor %}\nfeature_flags:\n- name: engineering_rollback_plan_activated regex: r/engineering_rollback_plan_activated/\n- name: marketing_premium_plan_features_unlocked regex: r/marketing_premium_plan_features_unlocked/\n- name: mobile_push_notifications_enabled\nregex: r/mobile_push_notifications_enabled/\ncolors:\nyellow: 'ffb300'   </code></pre>  Download this example as a CM file."},{"location":"integrations/flagsmith/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/github-actions/","title":"Integrate gitStream with GitHub Actions","text":""},{"location":"integrations/github-actions/#dispatch-github-actions","title":"Dispatch GitHub Actions","text":"<p>Automatically trigger GitHub Actions based on PR content like changed resources, source or target branch, slash commands, and more.</p> <p></p> By BranchUsing LabelsBy Modified Resources <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR source or target branch matches a specified format.</li> </ul> <p>Automation Actions:</p> <ul> <li>Trigger a manual dispatch for the specified CI pipeline.</li> </ul> <p>Dispatch GitHub Actions by Branch</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\n- commit\nautomations:\n{% for item in pipelines %}\n# Change pr.target to branch.name if you want to trigger on the source branch rather then the target branch.\ndispatch_github_action_branch_{{ item.name }}:\nif:\n- {{ pr.target | includes(term=item.branch_prefix) }}\nrun:\n- action: run-github-workflow@v1\nargs:\nworkflow: .github/workflows/{{ item.workflow }}\ncheck_name: {{ item.name }}\n- action: add-label@v1\nargs:\nlabel: {{ item.label }}\n{% endfor %}\npipelines:\n- name: mobile_ci\nlabel: Mobile CI\nbranch_prefix: 'mobile-'\nworkflow: mobile.yml\n- name: backend_ci\nlabel: Backend CI\nbranch_prefix: 'backend-'\nworkflow: 'backend.yml'\n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR has one or more specified labels applied to it.</li> </ul> <p>Automation Actions:</p> <ul> <li>Trigger a manual dispatch for the specified CI pipeline.</li> </ul> <p>Dispatch GitHub Actions Using Labels</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- label_added\n- label_removed\nautomations:\n{% for item in pipelines %}\ndispatch_github_action_label_{{ item.name }}:\nif:\n- {{ pr.labels | match(term=item.label) | some }}\nrun:\n- action: run-github-workflow@v1\nargs:\nworkflow: .github/workflows/{{ item.workflow }}\ncheck_name: {{ item.name }}\n{% endfor %}\npipelines:\n- name: mobile-ci\nlabel: Mobile CI\nworkflow: mobile.yml\n- name: backend-ci\nlabel: Backend CI\nworkflow: 'backend.yml'\n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR modifies one or more specified resources.</li> </ul> <p>Automation Actions:</p> <ul> <li>Trigger a manual dispatch for the specified CI pipeline.</li> </ul> <p>Dispatch GitHub Actions Based on Modified Resources</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\n- commit\nautomations:\n{% for item in pipelines %}\ndispatch_github_action_resource_{{ item.name }}:\nif:\n- {{ files | match(list=item.resources) | some }}\nrun:\n- action: run-github-workflow@v1\nargs:\nworkflow: .github/workflows/{{ item.workflow }}\ncheck_name: {{ item.name }}\n- action: add-label@v1\nargs:\nlabel: {{ item.label }}\n{% endfor %}\npipelines:\n- name: mobile-ci\nlabel: Mobile CI\nresources:\n- 'src/android/'\n- 'src/ios/'\nworkflow: mobile.yml\n- name: backend-ci\nlabel: Backend CI\nresources:\n- 'src/api/'\n- 'src/services'\nworkflow: 'backend.yml'\n- name: frontend-ci\nlabel: Frontend CI\nresources:\n- 'src/app/'\nworkflow: 'frontend.yml'\n</code></pre>  Download this example as a CM file. </p> <p></p>"},{"location":"integrations/github-actions/#skip-github-actions","title":"Skip GitHub Actions","text":"<p>Automatically skip GitHub Actions based on branch names, modified resource, slash commands, and more.</p> <p></p> <p>Prerequisite Config for Required Statuses</p> <p>If you want to skip a required status check, you will need to make sure that your branch protection is configured to allow gitStream to bypass status check requirements.</p> <p></p> By BranchUsing LabelsBy Modified Resource <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The target branch name includes a specified keyword. Optionally, you can modify this to detect the source branch name.</li> </ul> <p>Automation Actions:</p> <ul> <li>Skip the specified CI pipelines.</li> </ul> <p>Automatically Skip GitHub Actions by Branch</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\n- commit\n# Optionally, you can change pr.target to branch.name\n# if you want to trigger based on the source branch name rather then the target branch name.\nautomations:\nskip_github_action_branch:\nif:\n- {{ pr.target | includes(term='release') }}\nrun:\n- action: add-github-check@v1\nargs:\ncheck_name: staging-ci\nconclusion: skipped\n- action: add-comment@v1\nargs:\ncomment: |\n[gitStream](https://docs.gitstream.cm) automatically skipped staging CI pipelines because this PR targets the release branch.\n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>Someone applies one or more specified labels to a PR.</li> </ul> <p>Automation Actions:</p> <ul> <li>Skip the specified CI pipelines.</li> </ul> <p>Use Labels to Automatically Skip GitHub Actions</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- label_added\n- label_removed\nautomations:\nskip_github_action_label:\nif:\n- {{ pr.labels | match(term='experimental') | some }}\nrun:\n- action: add-github-check@v1\nargs:\ncheck_name: production-ci\nconclusion: skipped\n- action: add-comment@v1\nargs:\ncomment: |\n[gitStream](https://docs.gitstream.cm) automatically skipped production CI pipelines because this is labeled for experimental release.\n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR modifies specific files or directories.</li> </ul> <p>Automation Actions:</p> <ul> <li>Skip a specified GitHub Action.</li> </ul> <p>Automatically Skip GitHub Actions Based on Modified Resources</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\n- commit\nautomations:\nskip_github_action_resource:\nif:\n- {{ files | match(term='docs/') | every }}\nrun:\n- action: add-github-check@v1\nargs:\ncheck_name: release-ci\nconclusion: skipped\n- action: add-github-check@v1\nargs:\ncheck_name: mobile-ci\nconclusion: skipped\n- action: add-comment@v1\nargs:\ncomment: |\n[gitStream](https://docs.gitstream.cm) automatically skipped production CI pipelines because this PR only contains docs changes.\n</code></pre>  Download this example as a CM file. </p>"},{"location":"integrations/github-actions/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/github-copilot/","title":"Integrate gitStream with GitHub Copilot","text":""},{"location":"integrations/github-copilot/#automation-examples","title":"Automation Examples","text":""},{"location":"integrations/github-copilot/#automatically-label-copilot-assisted-prs","title":"Automatically Label Copilot-Assisted PRs","text":"<p>Automatically apply labels to PRs that are assisted by GitHub Copilot. You can apply labels based on a known list of Copilot users, PR tags, or by prompting the PR author to indicate if they used Copilot.</p> Label by PromptLabel by Known UsersLabel by TagLabel by Copilot code comment <p>Prompt PR authors to indicate if they used Copilot for the PR and automatically label the PR if they did. This requires two separate automation files to handle posting the prompt and labeling accordingly.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is created</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment prompting the author to indicate if Copilot assisted the author with writing the code in the PR.</li> </ul> <p>Ask the PR author about Copilot usage.</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\nautomations:\ncomment_copilot_prompt:\n# Post a comment for all PRs to prompt the PR author to indicate whether they used Copilot to assist coding in this PR\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nPlease mark whether you used Copilot to assist coding in this PR\n- [ ] Copilot Assisted\n- [ ] Not Copilot Assisted\n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is updated or merged where the author indicates they used Copilot via a prompt.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Copilot</code> label to the PR</li> </ul> <p>Label PRs where the user indicated Copilot usage</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n# You should use this automation in conjunction with comment_copilot_prompt.cm\nlabel_copilot_pr:\n# If the PR author has indicated that they used Copilot to assist coding in this PR, \n# apply a label indicating the PR was supported by Copilot\nif:\n- {{ pr.comments | filter(attr='commenter', term='gitstream-cm') | filter (attr='content', regex=r/\\- \\[x\\] Copilot Assisted/) | some}}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Copilot'\n</code></pre>  Download this example as a CM file. </p> <p>Automatically apply labels to PRs that are created by known users of generative AI coding tools.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The PR author is one of a specified list of contributors</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Copilot</code> label to the PR</li> </ul> <p>Label by Contributors</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_copilot_by_contributors:\n# For all PRs authored by someone who is specified in the genai_contributors list\nif:\n- {{ pr.author | match(list=genai_contributors) | some }}\n# Apply a label indicating the user has adopted Copilot\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 ai-copilot'\ngenai_contributors:\n- username1\n- username2\n- usernameN\n</code></pre>  Download this example as a CM file. </p> <p>Look for a specific tag  in the PR title, description, comments or commit messages and if found add a label to the PR</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The <code>#copilot#</code> tag is found in any of the PR title, description, comments or commit messages for commits in the PR</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Copilot</code> label to the PR</li> </ul> <p>Label Copilot by Tag</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- comment_added\n- commit\n- pr_created\nautomations:\nlabel_copilot:\n# Detect PRs that contain the text '#copilot#' in the title, description, comments, or commit messages\nif:\n- {{ copilot_tag.pr_title or copilot_tag.pr_desc or copilot_tag.pr_comments or copilot_tag.commit_messages  }}\n# Apply a label indicating the user has adopted Copilot\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Copilot'\ncopilot_tag:\npr_title: {{ pr.title | includes(regex=r/#copilot#/) }}\npr_desc: {{pr.description | includes(regex=r/#copilot#/) }}\npr_comments: {{ pr.comments | map(attr='content') | match(regex=r/#copilot#/) | some }}\ncommit_messages: {{ branch.commits.messages | match(regex=r/#copilot#/) | some }}\n</code></pre>  Download this example as a CM file. </p> <p>Experimental</p> <p>Code generation instructions is an experimental setting which might change in future GitHub Copilot versions.</p> <p>Use Code generation instructions to instruct copilot to add a comment at the beginning of the AI generated code. Use gitStream automation to automatically identify PRs with this comment </p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The comment <code>Generated by Copilot</code> is added to the code in this PR</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Copilot</code> label to the PR</li> </ul> <p>Label Copilot by comment</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_copilot_pr:\n# Look for the comment 'Generated by Copilot' in the added code\nif:\n- {{ source.diff.files | matchDiffLines(regex=copilot_comment, ignoreWhiteSpaces=true) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Copilot'\ncopilot_comment: \"r/^\\\\+.*Generated by Copilot/\"\n</code></pre>  Download this example as a CM file. </p>"},{"location":"integrations/github-copilot/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/godoc/","title":"Integrate gitStream with Godoc","text":""},{"location":"integrations/godoc/#automation-examples","title":"Automation Examples","text":""},{"location":"integrations/godoc/#review-godoc-changes","title":"Review Godoc Changes","text":"<p>Approve PRs that only contain changes to Godoc and assign optional reviewers.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR only contains changes to Godoc content.</li> </ul> <p>Automation Actions:</p> <ul> <li>Assign the org/tech-writers team for optional review.</li> <li>Apply a green <code>\ud83d\udcd3 Godoc Only</code> label</li> <li>Approve the PR</li> </ul> <p>Review Godoc</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n#Assign PRs that only affect godocs to the technical writing team and add docs label\nreview_godoc:\nif:\n- {{ source.diff.files | match(attr='diff', regex=r/^\\/\\/.*/) | every }}\n- {{ files | extensions | match(regex=r/go/) | every }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83d\udcd3godoc Only\"\ncolor: {{ colors.green }}\n- action: add-reviewers@v1\nargs:\nreviewers: [org/tech-writers]\n- action: approve@v1\ncolors:\ngreen: '0e8a16'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/godoc/#enforce-godoc-requirements-for-new-classes","title":"Enforce Godoc Requirements for New Classes","text":"<p>Require Godoc for all new Golang classes.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates a new Golang class.</li> <li>The PR lacks Godoc content.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment explaining that Godoc is required</li> <li>Apply a yellow <code>\u26a0\ufe0f Missing Godoc</code> label.</li> </ul> <p>Enforce Godoc for New Golang Classes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_godoc_new_class: if:  - {{ is.go and is.new }} - {{ source.diff.files | match(attr='diff', regex=r/\\/*[\\s\\S]*?\\//) | nope }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing godoc\"\ncolor: {{ colors.yellow }}\n- action: add-comment@v1\nargs: comment: | godoc is required for all Golang classes. Please add godoc to all new classes in this PR.\nis:\ngo: {{ files | extensions | match(regex=r/go/) | every }}\nnew: {{ source.diff.files | map(attr='original_file') | match(regex=r/^$/) | some }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/godoc/#review-godoc-for-large-changes","title":"Review Godoc for Large changes","text":"<p>Require more extensive reviews for large Golang changes that lack Godoc updates.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR changes more than 100 lines of Golang code.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment asking the author to review all relevant Godoc to identify necessary updates.</li> <li>Require a review from the <code>ORG/tech-writers</code> team.</li> <li>Apply a yellow <code>\u26a0\ufe0f Missing Godoc</code> Label</li> </ul> <p>Review Godoc</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n#Require more extensive reviews for large Golang changes that lack Godoc updates.\nreview_godoc_large:\nif:\n- {{ changes.additions &gt; 100}}\n- {{ source.diff.files | matchDiffLines(regex=r/^\\/\\/.*/) | nope }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Godoc\"\ncolor: {{ colors.yellow }}\n- action: add-comment@v1\nargs: comment: | This PR makes major changes to Golang classes, but is missing updates to Godoc. Please double check for any necessary Godoc updates.\n- action: add-reviewers@v1\nargs:\nreviewers: [fourth-organization/tech-writers]\nchanges:\n# Sum all the lines added/edited in the PR\nadditions: {{ branch.diff.files_metadata | map(attr='additions') | sum }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/godoc/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p> <p>Special thanks to Boemo W Mmopelwa for providing these examples.</p>"},{"location":"integrations/javadoc/","title":"Integrate gitStream with Javadoc","text":""},{"location":"integrations/javadoc/#automation-examples","title":"Automation Examples","text":""},{"location":"integrations/javadoc/#review-javadoc-changes","title":"Review Javadoc Changes","text":"<p>Unblock PRs that only change Javadoc content.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR only contains changes to Javadoc content.</li> </ul> <p>Automation Actions:</p> <ul> <li>Assign the <code>org/tech-writers</code>team for optional review.</li> <li>Apply a green <code>\ud83d\udcd3 Javadoc Only</code> label</li> <li>Approve the PR</li> </ul> <p>Review Javadoc Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n# Assign PRs that only affect JavaDocs to the technical writing team and add docs label\nreview_javadoc:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/\\/*\\*([\\s\\S]*?)\\//) | every }}\n- {{ source.diff.files | matchDiffLines(regex=r/\\b(public|protected|private|static|final|synchronized)?\\s+\\w+\\s+\\w+\\s*\\(([^)]*)\\)\\s*\\{/) | nope }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83d\udcd3 Javadoc Only\"\ncolor: {{ colors.green }}\n- action: add-reviewers@v1\nargs:\nreviewers: [org/tech-writers]\n- action: approve@v1\ncolors:\ngreen: '0e8a16'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/javadoc/#review-java-input-parameters-for-javadoc-changes","title":"Review Java Input Parameters for Javadoc Changes","text":"<p>If a PR modifies the input parameters for a Java method, but not the associated Javadocs, notify reviewers to check for Javadoc updates.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR changes one or more input parameters in Java methods.<ul> <li>Note: This may not trigger for methods with annotations, methods that throw exceptions, multi-line method definitions, and other non-standard use cases.</li> </ul> </li> <li>The PR lacks changes to \u2018@param\u2019 declarations.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment warning the user to review the method\u2019s Javadoc to identify necessary updates.</li> </ul> <p>Review Javadoc</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_javadoc_input_parameters: if:  - {{ source.diff.files | matchDiffLines(regex=r/\\*\\s@param/) | nope }}\n- {{ source.diff.files | matchDiffLines(regex=r/\\b(public|protected|private|static|final|synchronized)?\\s+\\w+\\s+\\w+\\s*\\(([^)]*)\\)\\s*\\{/) | some }}\nrun:\n- action: add-comment@v1\nargs: comment: | This PR modifies method input parameters, but is missing Javadoc changes. Please check to ensure no Javadoc changes are necessary.\n</code></pre>  Download this example as a CM file."},{"location":"integrations/javadoc/#review-javadoc-for-large-changes","title":"Review Javadoc for Large Changes","text":"<p>Require more extensive reviews for large Java changes that lack Javadoc updates.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR changes more than 25% of a Java class.</li> <li>The PR lacks Javadoc changes.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment asking the author to review all relevant Javadoc to identify necessary updates.</li> <li>Require a review from the <code>my-organization/tech-writers</code> team.</li> <li>Apply a yellow <code>\u26a0\ufe0f Missing Javadoc</code> Label</li> </ul> <p>Review Javadoc for Large Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n#Require more extensive reviews for large Java changes that lack Javadoc updates.\nreview_javadoc_large:\nif:\n- {{ changes.ratio &gt; 25}}\n- {{ source.diff.files | matchDiffLines(regex=r/\\/*\\*([\\s\\S]*?)\\//) | nope }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Javadoc\"\ncolor: {{ colors.yellow }}\n- action: add-comment@v1\nargs: comment: | This PR makes major changes to Java classes, but is missing updates to Javadoc. Please double check for any necessary Javadoc updates.\n- action: add-reviewers@v1\nargs:\nreviewers: [fourth-organization/tech-writers]\nchanges:\n# Sum all the lines added/edited in the PR\nadditions: {{ branch.diff.files_metadata | map(attr='additions') | sum }}\n# Sum all the line removed in the PR\ndeletions: {{ branch.diff.files_metadata | map(attr='deletions') | sum }}\n# Calculate the ratio of new code\nratio: {{ (changes.additions / (changes.additions + changes.deletions)) * 100 | round(2) }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/javadoc/#enforce-javadoc-requirements-for-new-classes","title":"Enforce Javadoc Requirements for New Classes","text":"<p>Automatically request changes when someone creates a new Java class that lacks Javadoc content.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates a new Java class.</li> <li>The PR lacks Javadoc content.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\u26a0\ufe0f Missing Javadoc</code> label.</li> <li>Request changes, and post a comment explaining that Javadoc is required</li> </ul> <p>Review Javadoc Requirements for New Classes</p> <p><pre><code>manifest:\nversion: 1.0\nautomations:\nreview_new_class_javadoc:\n# Triggered for new Java files that lack Javadoc content.\nif:\n- {{ is.java and is.new }}\n- {{ source.diff.files | matchDiffLines(regex=r/\\/*\\*([\\s\\S]*?)\\//) | nope }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Javadoc\"\ncolor: {{ colors.yellow }}\n- action: request-changes@v1\nargs:\ncomment: | This PR creates new Java classes, but is missing updates to Javadoc. Please double check for any necessary Javadoc updates.\nis:\njava: {{ files | extensions | match(term='java') | every }}\nnew: {{ source.diff.files | map(attr='original_file') | match(regex=r/^$/) | some }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/javadoc/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p> <p>Special thanks to Boemo W Mmopelwa for providing these examples.</p>"},{"location":"integrations/jit/","title":"Integrate gitStream with Jit","text":"<p>Included with gitStream Core Functionality</p> <p>This integration is part of gitStream core functionality, and requires no additional configuration.</p>"},{"location":"integrations/jit/#automation-examples","title":"Automation Examples","text":""},{"location":"integrations/jit/#review-jit-security-alerts","title":"Review Jit Security Alerts","text":"<p>Manage review assignment for high and medium risk Jit security alerts.</p> <p></p> <p>Configuration Description</p> <pre><code>**Review Jit High Alerts**\n\n* Conditions (all must be true):\n    * Jit reports one or more high vulnerabilities for the PR\n* Automation Actions:\n    * Require a review from the organization\u2019s security team.\n    * Require 2 reviewers.\n    * Post a comment explaining why this action was taken.\n\n**Review Jit Medium Alerts**\n\n* Conditions (all must be true):\n    * Jit reports one or more medium vulnerabilities for the PR\n* Automation Actions:\n    * Require 2 reviewers\n    * Post a comment explaining why this action was taken.\n</code></pre> <p>Review Jit Security Alerts</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_jit_high_alerts:\nif:\n- {{ jit.metrics.HIGH &gt; 0 }}\nrun:\n- action: require-reviewers@v1\nargs:\nreviewers: [my-organization/security-team]\n- action: set-required-approvals@v1\nargs:\napprovals: 2\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR requires additional review because Jit reported one or more high risk vulnerabilities.\nreview_jit_medium_alerts:\nif:\n- {{ jit.metrics.MEDIUM &gt; 0 }}\nrun:\n- action: set-required-approvals@v1\nargs:\napprovals: 2\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR requires additional reviewers because Jit reported one or more medium risk vulnerabilities.\njit: {{ pr | extractJitFindings }}\n</code></pre>  Download this example as a CM file."},{"location":"integrations/jit/#review-jit-secret-detection","title":"Review Jit Secret Detection","text":"<p>Close PRs where Jit detects a secret and post a comment explaining steps to remedy the situation.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>Jit detects a secret in the PR.</li> </ul> <p>Automation Actions:</p> <ul> <li>Close the PR</li> <li>Post a comment explaining why this action was taken and to outline the necessary steps to remedy the situation.</li> </ul> <p>Review Jit Security Control</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_jit_secret:\nif:\n- true\n- {{ jit.vulnerabilities | match(attr='security_control', term='Secret Detection') | some }}\nrun:\n- action: add-comment@v1\nargs: comment: |\nJit detects secrets in this PR. Please complete the following steps:\n1. Undo the commit with git reset and remove all secrets from the files you modified.\n2. Deactivate the secret in any locations its used and replace it with a new key\n3. Commit your changes and resubmit your PR.\n- action: close@v1\njit: {{ pr | extractJitFindings }}\n</code></pre>  Download this example as a CM file."},{"location":"integrations/jit/#label-jit-alerts","title":"Label Jit Alerts","text":"<p>Label the number of high, medium, and low risk vulnerabilities Jit reports for PRs.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>Jit reports one or more high, medium, or low risk security vulnerabilities for the PR.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply labels to indicate the number of each type of vulnerability</li> </ul> <p>Label Jit Alerts</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in reports %}\nlabel_jit_{{ item.name }}:\nif:\n- {{ item.count &gt; 0}}\nrun:\n- action: add-label@v1\nargs:\nlabel: 'Jit: {{ item.count }} {{ item.name }} vulnerabilities'\ncolor: {{ colors.red if (item.name == 'high') else (colors.orange if (item.name == 'medium' ) else colors.yellow) }}\n{% endfor %}\njit: {{ pr | extractJitFindings }}\nreports:\n- name: high\ncount: {{ jit.metrics.HIGH }}\n- name: medium\ncount: {{ jit.metrics.MEDIUM }}\n- name: low\ncount: {{ jit.metrics.LOW }}\ncolors:\nred: 'b60205'\norange: 'd93f0b'\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/jit/#review-jit-ignore-and-accept","title":"Review Jit Ignore and Accept","text":"<p>Notify your Security team when someone ignores a Jit vulnerability report and accepts the risk.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>Someone ignores and accepts a Jit finding</li> </ul> <p>Automation Actions:</p> <ul> <li>Request review from the organization\u2019s security team.</li> <li>Label the PR to indicate someone accepted the risk of a Jit security alert.</li> <li>Post a comment explaining why this action was taken.</li> </ul> <p>Review Jit Ignore and Accept</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_jit_ignore_accept:\nif:\n- {{ pr.conversations | reject(attr='commenter', term='jit-ci') | filter(attr='content', term='#jit_ignore_accept') | some }}\nrun:\n- action: add-reviewers@v1\nargs:\nreviewers: [my-organziation/security]\n- action: add-label@v1\nargs:\nlabel: '\u2755 Jit: Ignore - Accept Risk'\n- action: add-comment@v1\nargs:\ncomment: |\nThe security team has been assigned for optional review because this PR ignores a Jit alert and accepts the associated risks.\njit: {{ pr | extractJitFindings }}\n</code></pre>  Download this example as a CM file."},{"location":"integrations/jit/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/jsdoc/","title":"Integrate gitStream with JSDoc","text":""},{"location":"integrations/jsdoc/#automation-examples","title":"Automation Examples","text":""},{"location":"integrations/jsdoc/#review-jsdoc-changes","title":"Review JSDoc Changes","text":"<p>Approve PRs that only contain changes to JSDoc and assign optional reviewers.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR only affects JavaScript and TypeScript files</li> <li>The PR only contains changes to JSDoc content.</li> </ul> <p>Automation Actions:</p> <ul> <li>Assign the <code>ORG/tech-writers</code> team.</li> <li>Apply a green <code>\ud83d\udcd3 JSDoc Only label</code></li> <li>Approve the PR</li> </ul> <p>Review JSDoc</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n#Assign PRs that only affect JSDocs to the technical writing team and add docs label\nreview_jsdoc:\nif:\n- {{ source.diff.files | match(attr='diff', regex=r/\\/*\\*[\\s\\S]*?\\//) | every }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83d\udcd3JSDoc Only\"\ncolor: {{ colors.green }}\n- action: add-reviewers@v1\nargs:\nreviewers: [fourth-organization/tech-writers]\n- action: approve@v1\ncolors:\ngreen: '0e8a16'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/jsdoc/#review-jsdoc-input-parameters","title":"Review JSDoc Input Parameters","text":"<p>Warn PR authors when they change JavaScript function or constructor input parameters without updating JSDoc content.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR changes an input parameter in one or more JavaScript methods.</li> <li>The PR lacks changes to \u2018@param\u2019 declarations.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment warning the user to review the method\u2019s JSDoc to identify necessary updates.</li> </ul> <p>Review JSDoc Input Parameters</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_jsdoc_input: if:  - {{ source.diff.files | matchDiffLines(regex=r/.*\\s@param/) | nope }}\n- {{ source.diff.files | matchDiffLines(regex=r/\\((?:.*\\:.*\\))/) | some }}\nrun:\n- action: add-comment@v1\nargs: comment: | This PR appears to modify method input parameters, but is missing JSDoc changes. Please check to ensure no JSDoc changes are necessary.\n</code></pre>  Download this example as a CM file."},{"location":"integrations/jsdoc/#review-jsdoc-for-large-changes","title":"Review JSDoc for Large Changes","text":"<p>Require more extensive reviews for large JavaScript changes that lack JSDoc updates.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR changes more than 25% of a JavaScript class.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment asking the author to review all relevant JSDoc to identify necessary updates.</li> <li>Require a review from the <code>ORG/tech-writers</code> team.</li> <li>Apply a yellow <code>\u26a0\ufe0f Missing JSDoc</code> Label</li> </ul> <p>Review JSDoc</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n#Require more extensive reviews for large Javascript changes that lack JSDoc updates.\nreview_jsdoc_large:\nif:\n- {{ changes.ratio &gt; 25}}\n- {{ source.diff.files | matchDiffLines(regex=r/\\/*\\*([\\s\\S]*?)\\//) | nope }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f No JSDoc\"\ncolor: {{ colors.yellow }}\n- action: add-comment@v1\nargs: comment: | This PR makes major changes to JavaScript classes, but is missing updates to JSDoc. Please double check for any necessary JSDoc updates.\n- action: add-reviewers@v1\nargs:\nreviewers: [fourth-organization/tech-writers]\nchanges:\n# Sum all the lines added/edited in the PR\nadditions: {{ branch.diff.files_metadata | map(attr='additions') | sum }}\n# Sum all the line removed in the PR\ndeletions: {{ branch.diff.files_metadata | map(attr='deletions') | sum }}\n# Calculate the ratio of new code\nratio: {{ (changes.additions / (changes.additions + changes.deletions)) * 100 | round(2) }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/jsdoc/#enforce-jsdoc-for-new-javascript-classes","title":"Enforce JSDoc for New JavaScript Classes","text":"<p>Require JSDoc for all new JavaScript classes.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates a new JavaScript class.</li> <li>The PR lacks JSDoc content.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment explaining that JSDoc is required</li> <li>Apply a yellow <code>\u26a0\ufe0f Missing JSDoc</code> label.</li> </ul> <p>Enforce JSDoc for New JavaScript Classes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_jsdoc_new_class: if:  - {{ is.javascript and is.new }} - {{ source.diff.files | matchDiffLines(regex=r/\\/*\\*([\\s\\S]*?)\\//) | nope }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing JSDoc\"\ncolor: {{ colors.yellow }}\n- action: request-changes@v1\nargs: comment: | JSDoc is required for all JavaScript classes. Please add JSDoc to all new classes in this PR.\nis:\njavascript: {{ files | extensions | match(list=['js', 'ts']) | every }}\nnew: {{ source.diff.files | map(attr='original_file') | match(regex=r/^$/) | some }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/jsdoc/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p> <p>Special thanks to Boemo W Mmopelwa for help with these examples.</p>"},{"location":"integrations/launch-darkly/","title":"Integrate gitStream with Launch Darkly","text":""},{"location":"integrations/launch-darkly/#label-launch-darkly-feature-flags","title":"Label Launch Darkly Feature Flags","text":"<p>Automatically label code that contians specified feature flags.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR adds one or more feature flag keys.</li> </ul> <p>Automation Actions:</p> <ul> <li>Label the PR for each feature flag key introduced in the PR.</li> </ul> <p>Label PRs Based on Feature Flags</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in feature_flags %}\nlabel_ff_launchdarkly_{{ item.name }}:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/var flagValue = ldclient/) | some }}\n- {{ source.diff.files | matchDiffLines(regex=item.regex) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: {{ item.name }}\ncolor: {{ colors.yellow }}\n{% endfor %}\nfeature_flags:\n- name: engineering_rollback_plan_activated regex: r/engineering_rollback_plan_activated/\n- name: marketing_premium_plan_features_unlocked regex: r/marketing_premium_plan_features_unlocked/\n- name: mobile_push_notifications_enabled\nregex: r/mobile_push_notifications_enabled/\ncolors:\nyellow: 'ffb300'   </code></pre>  Download this example as a CM file."},{"location":"integrations/launch-darkly/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/linearb/","title":"Integrate gitStream with LinearB","text":"<p>LinearB is a software delivery management platform that makes it easy to benchmark your engineering organization, track engineering metrics and identify opportunities for improvement.</p>"},{"location":"integrations/linearb/#track-the-impact-of-generative-ai-initiatives","title":"Track the Impact of Generative AI Initiatives","text":"<p>These examples show how to label PRs that are assisted by GitHub Copilot so you can easily track productivity within LinearB. These examples can be adapted for any other generative AI solutions you might use.</p> <p></p> <p>Automatically apply labels to PRs that are assisted by GitHub Copilot. You can apply labels based on a known list of Copilot users, PR tags, or by prompting the PR author to indicate if they used Copilot.</p> Label by PromptLabel by Known UsersLabel by TagLabel by Copilot code comment <p>Prompt PR authors to indicate if they used Copilot for the PR and automatically label the PR if they did. This requires two separate automation files to handle posting the prompt and labeling accordingly.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is created</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment prompting the author to indicate if Copilot assisted the author with writing the code in the PR.</li> </ul> <p>Ask the PR author about Copilot usage.</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\nautomations:\ncomment_copilot_prompt:\n# Post a comment for all PRs to prompt the PR author to indicate whether they used Copilot to assist coding in this PR\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nPlease mark whether you used Copilot to assist coding in this PR\n- [ ] Copilot Assisted\n- [ ] Not Copilot Assisted\n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is updated or merged where the author indicates they used Copilot via a prompt.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Copilot</code> label to the PR</li> </ul> <p>Label PRs where the user indicated Copilot usage</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n# You should use this automation in conjunction with comment_copilot_prompt.cm\nlabel_copilot_pr:\n# If the PR author has indicated that they used Copilot to assist coding in this PR, \n# apply a label indicating the PR was supported by Copilot\nif:\n- {{ pr.comments | filter(attr='commenter', term='gitstream-cm') | filter (attr='content', regex=r/\\- \\[x\\] Copilot Assisted/) | some}}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Copilot'\n</code></pre>  Download this example as a CM file. </p> <p>Automatically apply labels to PRs that are created by known users of generative AI coding tools.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The PR author is one of a specified list of contributors</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Copilot</code> label to the PR</li> </ul> <p>Label by Contributors</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_copilot_by_contributors:\n# For all PRs authored by someone who is specified in the genai_contributors list\nif:\n- {{ pr.author | match(list=genai_contributors) | some }}\n# Apply a label indicating the user has adopted Copilot\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 ai-copilot'\ngenai_contributors:\n- username1\n- username2\n- usernameN\n</code></pre>  Download this example as a CM file. </p> <p>Look for a specific tag  in the PR title, description, comments or commit messages and if found add a label to the PR</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The <code>#copilot#</code> tag is found in any of the PR title, description, comments or commit messages for commits in the PR</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Copilot</code> label to the PR</li> </ul> <p>Label Copilot by Tag</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- comment_added\n- commit\n- pr_created\nautomations:\nlabel_copilot:\n# Detect PRs that contain the text '#copilot#' in the title, description, comments, or commit messages\nif:\n- {{ copilot_tag.pr_title or copilot_tag.pr_desc or copilot_tag.pr_comments or copilot_tag.commit_messages  }}\n# Apply a label indicating the user has adopted Copilot\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Copilot'\ncopilot_tag:\npr_title: {{ pr.title | includes(regex=r/#copilot#/) }}\npr_desc: {{pr.description | includes(regex=r/#copilot#/) }}\npr_comments: {{ pr.comments | map(attr='content') | match(regex=r/#copilot#/) | some }}\ncommit_messages: {{ branch.commits.messages | match(regex=r/#copilot#/) | some }}\n</code></pre>  Download this example as a CM file. </p> <p>Experimental</p> <p>Code generation instructions is an experimental setting which might change in future GitHub Copilot versions.</p> <p>Use Code generation instructions to instruct copilot to add a comment at the beginning of the AI generated code. Use gitStream automation to automatically identify PRs with this comment </p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The comment <code>Generated by Copilot</code> is added to the code in this PR</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Copilot</code> label to the PR</li> </ul> <p>Label Copilot by comment</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_copilot_pr:\n# Look for the comment 'Generated by Copilot' in the added code\nif:\n- {{ source.diff.files | matchDiffLines(regex=copilot_comment, ignoreWhiteSpaces=true) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Copilot'\ncopilot_comment: \"r/^\\\\+.*Generated by Copilot/\"\n</code></pre>  Download this example as a CM file. </p>"},{"location":"integrations/linearb/#label-changes-to-track-in-linearb","title":"Label Changes to Track in LinearB","text":"<p>These examples show how to label PRs based on the changed code so you can more easily compare metrics across languages, frameworks, changed directories, and more.</p> <p></p> by Modified Resourceby Language <p>Automatically label PRs to indicate what resources are being changed.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created or updated.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply labels based on the branch name or modified resources.</li> </ul> <p>Label Modified Resources</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in labels %}\nlabel_resource_{{ item.name }}:\nif:\n-{{ branch.name | includes(regex=item.branch) or files | match(list=item.resources) }}\nrun:\n- action: add-label@v1\nargs:\nlabel: {{ item.name }}\n{% endfor %}\nlabels:\n- name: Core\nresources:\n- src/app\nbranch: r/^core-/\n- name: mobile\nresources:\n- src/android\n- src/ios\nbranch: r/^mobile-/\n</code></pre>  Download this example as a CM file. </p> <p>Automatically detect which programming languages are contained in PRs and automatically label the PRs appropriately.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created or updated.</li> </ul> <p>Automation Actions:</p> <ul> <li>Label the PR for each programming language that is included.</li> </ul> <p>Label PRs by Language</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in labels %}\nlabel_{{ item.name }}_pr:\nif:\n- {{ files | match(regex=item.resources) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: '{{ item.name }}'\n{% endfor %}\nlabels:\n- name: Java\nresources: r/.java$/\n- name: Rust\nresources: r/.rs$/\n- name: HTML\nresources: r/.html$/\n- name: JavaScript\nresources: r/.js$/\n- name: Python\nresources: r/.py$/\n- name: Golang\nresources: r/.go$/\n- name: Ruby\nresources: r/.rb$/\n- name: CSS\nresources: r/.css/\n</code></pre>  Download this example as a CM file. </p>"},{"location":"integrations/linearb/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/orca-security/","title":"Integrate gitStream with Orca Security","text":""},{"location":"integrations/orca-security/#auto-label-orca-security-scan-results","title":"Auto-Label Orca Security Scan Results","text":"<p>Automatically apply labels to PRs that indicate the result of Orca Security scans.</p> <p>Required gitStream Plugin</p> <p>This example requires you to install the <code>extractOrcaFindings</code> plugin.</p> <p>Learn more about gitStream plugins.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>Orca Security detects one or more issues with the code in the PR.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a label that indicates which issue was identified.</li> </ul> <p>Auto-Label Orca Scan Results</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in reports %}\nlabel_orca_{{ item.name }}:\nif:\n- {{ item.count &gt; 0 }}\nrun:\n- action: add-label@v1\nargs:\nlabel: 'orca:{{ item.name }}'\n{% endfor %}\norca: {{ pr | extractOrcaFindings }}\nreports:\n- name: introduced-cves\ncount: {{ orca.vulnerabilities.count }}\n- name: iac-misconfigurations\ncount: {{ orca.infrastructure_as_code.count }}\n- name: exposed-secrets count: {{ orca.secrets.count }}\ncolors:\nred: 'b60205'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/orca-security/#require-security-review-for-orca-violations","title":"Require Security Review for Orca Violations","text":"<p>Automatically require review from your SecOps team for Orca Security violations in pull requests.</p> <p> </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains a vulnerability, IAC problem, or secret that is flagged as High or Medium.</li> </ul> <p>Automation Actions:</p> <ul> <li>Require review from your organization's security team.</li> <li>Post a comment explaining the requirement.</li> </ul> <p>Review Orca Security Alerts</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_orca_alerts:\nif:\n- {{ has.vulnerability or has.iac_violation or has.secret }}\nrun:\n- action: require-reviewers@v1\nargs:\nreviewers: [my-organization/security-team]\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR requires additional review because it fails to meet Orca Security safe code standards.\norca: {{ pr | extractOrcaFindings }}\nhas:\nvulnerability: {{ orca.vulnerabilities.priority == 'High' or orca.vulnerabilities.priority == 'Medium' }}\niac_violation: {{ orca.infrastructure_as_code.priority == 'High' or orca.infrastructure_as_code.priority == 'Medium' }}\nsecret: {{ orca.secrets.priority == 'High' or orca.secrets.priority == 'Medium' }}\n</code></pre>  Download this example as a CM file."},{"location":"integrations/orca-security/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/rdoc/","title":"Integrate gitStream with RDoc","text":"<p>Integrate gitStream with RDoc: a documentation generation framework for Ruby.</p>"},{"location":"integrations/rdoc/#automation-examples","title":"Automation Examples","text":""},{"location":"integrations/rdoc/#review-rdoc-changes","title":"Review RDoc Changes","text":"<p>Approve PRs that only contain changes to RDoc and assign optional reviewers.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR only contains changes to RDoc content.</li> </ul> <p>Automation Actions:</p> <ul> <li>Assign the org/tech-writers team for optional review.</li> <li>Apply a green <code>\ud83d\udcd3 RDoc Only</code> label</li> <li>Approve the PR</li> </ul> <p>Review RDoc</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_rdoc:\nif:\n- {{ source.diff.files | match(attr='diff', regex=r/^[\\s\\t]*#.*/) | every }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\ud83d\udcd3RDoc Only\"\ncolor: {{ colors.green }}\n- action: add-reviewers@v1\nargs:\nreviewers: [org/tech-writers]\n- action: approve@v1\ncolors:\ngreen: '0e8a16'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/rdoc/#enforce-rdoc-requirements-for-new-classes","title":"Enforce RDoc Requirements for New Classes","text":"<p>Require RDoc for all new Ruby classes.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates a new Ruby class.</li> <li>The PR lacks RDoc content.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment explaining that RDoc is required</li> <li>Apply a yellow <code>\u26a0\ufe0f Missing RDoc</code> label.</li> </ul> <p>Enforce RDoc for New Ruby Classes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_rdoc_new_class: if:  - {{ is.rb and is.new }} - {{ source.diff.files | match(attr='diff', regex=r/(\\#.*\\n.*)*def/) | nope }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing RDoc\"\ncolor: {{ colors.yellow }}\n- action: add-comment@v1\nargs: comment: | RDoc is required for all Ruby classes. Please add documentation for this PR.\nis:\nrb: {{ files | extensions | match(regex=r/rb/) | every }}\nnew: {{ source.diff.files | map(attr='original_file') | match(regex=r/^$/) | some }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/rdoc/#review-rdoc-for-large-changes","title":"Review RDoc for Large changes","text":"<p>Require more extensive reviews for large Ruby changes that lack RDoc updates.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR changes more than 150 lines of Ruby code.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment asking the author to review all relevant RDoc to identify necessary updates.</li> <li>Require a review from the <code>ORG/tech-writers</code> team.</li> <li>Apply a yellow <code>\u26a0\ufe0f Missing RDoc</code> Label</li> </ul> <p>Review RDoc</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n#Require more extensive reviews for large Ruby changes that lack RDoc updates.\nreview_rdoc_large:\nif:\n- {{ changes.additions &gt; 150}}\n- {{ source.diff.files | matchDiffLines(regex=r/(\\#.*\\n.*)*def/) | nope }}\nrun: - action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing RDoc\"\ncolor: {{ colors.yellow }}\n- action: add-comment@v1\nargs: comment: | This PR makes major changes to Ruby methods, but is missing updates to RDoc. Please double check for any necessary RDoc updates.\n- action: add-reviewers@v1\nargs:\nreviewers: [fourth-organization/tech-writers]\nchanges:\n# Sum all the lines added/edited in the PR\nadditions: {{ branch.diff.files_metadata | map(attr='additions') | sum }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/rdoc/#review-rdoc-for-function-parameter-changes","title":"Review RDoc For Function Parameter Changes","text":"<p>Warn PR authors when they change Ruby function or constructor input parameters without updating RDoc content.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR changes one or more input parameters in Ruby methods.</li> <li>The PR lacks RDoc updates.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment warning the user to review the method\u2019s RDoc to identify necessary updates.</li> </ul> <p>Review RDoc Input Parameters</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_rdoc_input: if:  - {{ source.diff.files | match(attr='diff', regex=r/(\\#.*\\n.*)*def/) | nope }}\n- {{ source.diff.files | match(attr='diff', regex=r/def.*\\(.*\\)/ | some }}\nrun:\n- action: add-comment@v1\nargs: comment: | This PR modifies method input parameters, but is missing RDoc changes. Please check to ensure no RDoc changes are necessary.\n</code></pre>  Download this example as a CM file."},{"location":"integrations/rdoc/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p> <p>Special thanks to Boemo W Mmopelwa for providing these examples.</p>"},{"location":"integrations/renovate/","title":"Integrate gitStream with Mend Renovate","text":""},{"location":"integrations/renovate/#auto-merge-renovate-dependency-updates","title":"Auto-Merge Renovate Dependency Updates","text":"<p>Auto-merge Renovate PRs</p> By Release TypeAll Updates <p>Required gitStream Plugins</p> <p>This example requires you to install the <code>extractRenovateVersionBump</code>, <code>compareMultiSemver</code> and <code>compareSemver</code> plugins.</p> <p>Learn more about gitStream plugins.</p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR author is Renovate.</li> <li>The branch name includes 'renovate'</li> <li>The dependency change is a patch or minor update.</li> </ul> <p>Automation Actions:</p> <ul> <li>Approve the PR</li> <li>Apply an <code>approved-renovate</code> label to the PR</li> <li>Merge the PR if all status checks pass.</li> </ul> <p>Configuration Example</p> <p><pre><code>manifest:\nversion: 1.0\nautomations:\nmerge_renovate_minor:\nif:\n- {{ bump == 'minor' }}\n- {{ branch.name | includes(term=\"renovate\") }}\n- {{ branch.author | includes(term=\"renovate\") }}\nrun:\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nRenovate `minor` version bumps are approved automatically.\nmerge_renovate_minor_patch:\nif:\n- {{ bump == 'patch' }}\n- {{ branch.name | includes(term=\"renovate\") }}\n- {{ branch.author | includes(term=\"renovate\") }}\nrun:\n- action: approve@v1\n- action: merge@v1\n- action: add-comment@v1\nargs:\ncomment: |\nRenovate `patch` version bumps are approved and merged automatically.\nbump: {{ pr.description | extractRenovateVersionBump | compareMultiSemver }}\n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR author is Renovate.</li> <li>The branch name includes 'renovate'</li> </ul> <p>Automation Actions:</p> <ul> <li>Approve the PR</li> <li>Apply an <code>approved-renovate</code> label to the PR</li> <li>Merge the PR if all status checks pass.</li> </ul> <p>Configuration Example</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_renovate:\nif:\n- {{ branch.author | includes(term=\"renovate\") }}\nrun:\n- action: approve@v1\n- action: add-label@v1\nargs:\nlabel: \"approved-renovate\"\n- action: merge@v1\nargs:\nwait_for_all_checks: true\nsquash_on_merge: true\n</code></pre>  Download this example as a CM file. </p>"},{"location":"integrations/review-todo-comments/","title":"Automation - Review TODO Comments","text":""},{"location":"integrations/review-todo-comments/#review-todo-comments","title":"Review TODO Comments","text":"<p>Request changes for a PR that contains a TODO statement.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains a TODO statement</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment explaining why.</li> </ul> <p>Review TODO Comments</p> <p><pre><code>manifest:\nversion: 1.0\nautomations:\nreview_todo_comments:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/^[+].*(TODO|todo)/) | some }}\nrun:\n- action: request-changes@v1\nargs:\ncomment: |\nThis PR contains a TODO statement. Please check to see if they should be removed.\n</code></pre>  Download this example as a CM file. <p>Special thanks to Boemo W Mmopelwa for providing these examples.</p>"},{"location":"integrations/shortcut/","title":"Integrate gitStream with Shortcut","text":"<p>Learn how to integrate gitStream with Shortcut</p> <p></p>"},{"location":"integrations/shortcut/#label-missing-shortcut-info","title":"Label Missing Shortcut Info","text":"<p>Automatically label PRs that are missing references to Shortcut resources.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR is missing one of the following:<ul> <li>An Shortcut ticket reference in the PR title.</li> <li>A link to an Shortcut resource in the PR description.</li> </ul> </li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a red <code>\u26a0\ufe0f Missing Shortcut Link</code> label</li> <li>Post a comment that asks the author to add an Shortcut reference to the PR.</li> </ul> <p>Label Missing Shortcut</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_missing_shortcut:\nif:\n- {{not (has.shortcut.ticket_in_title or has.shortcut.ticket_in_desc)}}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"\u26a0\ufe0f Missing Shortcut Link\"\ncolor: {{ colors.red }}\n- action: add-comment@v1\nargs:\ncomment: Please provide a link to the associated Shortcut resource.\nhas:\nshortcut:\nticket_in_title: {{ pr.title | includes(regex=r/(\\w+)\\/sc-(\\d+)/) }}\nticket_in_desc: {{ pr.description | includes(regex=r/(app\\.shortcut\\.com)\\/(\\w+)\\/story\\/(\\d+)\\/(\\w+)/) }}\ncolors:\nred: 'b60205'\n</code></pre>  Download this example as a CM file. <p></p>"},{"location":"integrations/shortcut/#automatically-link-prs-to-related-shortcut-tasks","title":"Automatically Link PRs to Related Shortcut Tasks","text":"<p>Provide automatic links to Shortcut tasks that are associated with PRs.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains a reference to an Shortcut card in the title or branch name.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment that provides a link to the associated Shortcut Task.</li> </ul> <p>Automatically Link to the Related Shortcut Task</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\n# Configure these to match your organization.\nprovider: jira\n# Change this to match the name of your Shortcut organization. This is used in tracker.shortcut.baseurl\norgName: org\n{% set ticketid = \"\" %}\n{% for ticket in tickets %}\n{% if (ticket | includes(regex=r/.+/)) %}\n{% set ticketid = ticket %}\n{% endif %}\n{% endfor %}\nautomations:\nlink_shortcut:\nif:\n- {{ has.ticket_in_title or has.ticket_in_branch }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: Issue Tracker Link - [{{ticketid}}]({{tracker[provider].baseurl}}{{ticketid}})\nhas:\nticket_in_title: {{ pr.title | includes(regex=tracker[provider].pattern) }}\nticket_in_branch: {{ branch.name | includes(regex=tracker[provider].pattern) }}\ntracker:\nshortcut:\nbaseurl: https://app.shortcut.com/{{orgName}}/story/\npattern: r/(\\w+)\\/sc-(\\d+)/\ntickets:\n- {{branch.name | capture(regex=tracker[provider].pattern)}}\n- {{pr.title | capture(regex=tracker[provider].pattern)}}\n</code></pre>  Download this example as a CM file."},{"location":"integrations/shortcut/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>Related Automations:</p> <ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/slack/","title":"Integrate gitStream with Slack","text":"<p>This page demonstrates uses cases for how to connect gitStream to Slack to post messages via webhooks.</p>"},{"location":"integrations/slack/#prerequisite-configurations","title":"Prerequisite Configurations","text":"<p>To use gitStream with Slack, you first need to do two things:</p> <ol> <li>Create a Slack app with incoming webhooks enabled.</li> <li>Provide your Slack webhook URL to gitStream as an organization environment variable.</li> </ol>"},{"location":"integrations/slack/#setup-incoming-webhooks-in-slack","title":"Setup Incoming Webhooks in Slack","text":"<p>Follow this tutorial to configure your Slack instance to receive webhooks from gitStream.You\u2019ll end up with a webhook URL like this:</p> <pre><code>https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX\n</code></pre> <p>Your webhook URL is secret information!</p> <p>Slack webhook URLs allow anyone with access to the URL to post to the channel its configured for. Do not publish this URL to public locations.</p>"},{"location":"integrations/slack/#configure-environment-variable","title":"Configure Environment Variable","text":"<p>gitStream can access GitHub orgnization secrets as environment variables, and you'll need to do this to provide gitStream with access to your Slack webhook URL. </p> <ol> <li>Create an organization secret in GitHub and ensure it isn't being overridden by a repo-level secret of the same name.</li> <li>Pass the organization secret to gitStream as an environment variable in your <code>gitstream.yml</code> workflow file. We recommend using an easy to understand term like <code>SLACK_WEBHOOK_CHANNEL_NAME</code>.</li> </ol>"},{"location":"integrations/slack/#how-to-send-slack-messages-from-gitstream","title":"How to Send Slack Messages From gitStream","text":"<p>Example</p> <p>To send Slack messages from gitStream, use the <code>send-slack-message</code> automation action, and pass the value you stored your Slack webhook URL to the <code>webhook_url</code> argument.</p> <pre><code>automations:\nsend_slack:\nif:\n- true\nrun:\n- action: send-slack-message@v1\nargs:\nmessage: \"A message sent from GitStream!\"\nwebhook_url: \"{{ env.SLACK_WEBHOOK }}\"\n</code></pre>"},{"location":"integrations/slack/#auto-recognition-for-meeting-team-goals","title":"Auto-Recognition For Meeting Team Goals","text":"<p>A good choice to reward developers for submitting great PRs would be to automate a Slack message that gives the developer recognition among their colleagues. To do this, you\u2019ll need to create a Slack webhook that sends to a channel full of reviewers, managers, and anybody else who should see the recognition.</p> <p>Automatic Slack Recognition</p> <p>Automatically post positive recognition messages in Slack for well-structured PRs.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains updates to tests.</li> <li>The PR has fewer than 5 modified files.</li> <li>The PR branch references a Jira ticket.</li> <li>The PR has fewer than 150 lines of code changed.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a Slack message that automatically recognizes the PR author and provides a link to the PR.</li> </ul> <p>Automatic Slack Messages</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nslack_auto_recognition:\nif:\n- {{ files | match(regex=r/(test|spec)/) | some }} # this pr has at least 1 test\n- {{ files | length &lt;= 5 }} # this pr has 5 or less files\n- {{ branch.name | includes(regex=r/[A-Z]{2,}-\\d+.*/) }} # this branch has the Jira ticket prefix\n- {{ branch.diff.size &lt;= 150 }} # this branch has 150 lines of code or less changed\nrun:\n- action: send-slack-message@v1\nargs:\nwebhook_url: \"{{ env.SLACK_WEBHOOK }}\"\nmessage: \":tada: Congrats to {{ pr.author }} for the amazing new PR, '{{ pr.title }}'! Check it out at https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"\n</code></pre>  Download this example as a CM file. </p>"},{"location":"integrations/slack/#message-specific-teams-based-on-pr-content","title":"Message Specific Teams Based on PR content","text":"<p>You can also use the Slack integration to automatically keep in touch with code owners and others who should be connected to the PR. You could check for certain conditions that require a more personal review from an experienced maintainer, like:</p> <ul> <li>Will the PR take too long to review?</li> <li>Did SonarCloud find vulnerabilities?</li> <li>Is this the author\u2019s first commit or are they new to the codebase?</li> <li>Is this an automated PR that for some reason didn\u2019t pass the automatic approval tests?</li> </ul> <p>On the other hand, some PRs might not have anything wrong, but still need to be assigned to a certain team based on expertise. In that case, you could set up several Slack automation actions at once, all with different webhooks and conditions. In an organization with different secrets for Slack webhooks to the <code>#security-team</code> channel, the <code>#qa-team</code> channel, and the <code>#docs-team</code> channel.</p> <p>Send Slack Notifications</p> <p>Automatically send Slack notifications to specific channels based on the contents of a pull request.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR meets one or more of the specified trigger criteria for Slack notifications.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a Slack message based on the contents of the PR.</li> </ul> <p>Send Slack Notifications</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nsend_slack_security:\n# use your custom logic here to determine whether this needs a security review\nif:\n- true\nrun:\n- action: send-slack-message@v1\nargs:\nwebhook_url: \"{{ env.SLACK_WEBHOOK_SECURITY }}\"\nmessage: \"A PR requires a security review. See https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"\nsend_slack_qa:\n# use your custom logic here to determine whether this needs a qa review\nif:\n- {{ not (files | match(regex=r/(test|spec)/) | some) }}\nrun:\n- action: send-slack-message@v1\nargs:\nwebhook_url: \"{{ env.SLACK_WEBHOOK_QA }}\"\nmessage: \"A PR was submitted without tests. See https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"\nsend_slack_docs:\n# use your custom logic here to determine whether this needs a docs review\nif:\n- {{ files | match(regex=r/(docs)/) | some }}\nrun:\n- action: send-slack-message@v1\nargs:\nwebhook_url: \"{{ env.SLACK_WEBHOOK_DOCS }}\"\nmessage: \"A PR has modified the docs. See https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"\n</code></pre>  Download this example as a CM file. </p> <p>Using this template and custom logic specific to your company, you can build a complete repo management system that gets the right people actively involved by pinging them where they are in Slack.</p>"},{"location":"integrations/slack/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/snyk/","title":"Integrate gitStream with Snyk","text":""},{"location":"integrations/snyk/#auto-merge-snyk-dependency-updates","title":"Auto-Merge Snyk Dependency Updates","text":"<p>Approve PRs from Snyk</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR author is Snyk.</li> </ul> <p>Automation Actions:</p> <ul> <li>Approve the PR</li> <li>Apply an <code>approved-snyk</code> label to the PR</li> <li>Merge the PR if all status checks pass.</li> </ul> <p>Approve Snyk</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_snyk:\nif:\n- {{ branch.author | includes(term=\"snyk\") }}\nrun:\n- action: approve@v1\n- action: add-label@v1\nargs:\nlabel: \"approved-snyk\"\n- action: merge@v1\nargs:\nwait_for_all_checks: true\nsquash_on_merge: true\n</code></pre>  Download this example as a CM file."},{"location":"integrations/soc2/","title":"Use gitStream for SOC 2 compliance.","text":"<p>gitStream policy-as-code makes it easy to implement workflow automations that help your team remain SOC 2 compliant during the code review process.</p>"},{"location":"integrations/soc2/#flag-code-thats-merged-without-review","title":"Flag Code That's Merged Without Review","text":"<p>Automatically send notifications to your team when code is merged without review.</p> <p></p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is merged without at least one review.</li> </ul> <p>Automation Actions:</p> <ul> <li>Send a Slack notification to alert your team.</li> <li>Apply a red <code>DCF5-merged-without-review</code> label.</li> <li>Post a comment explaining SOC II requirements.</li> </ul> <p>Flag Code That's Merged Without Review</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- merge\n# https://docs.gitstream.cm/automation-actions/#send-slack-message\nslack_webhook: {{ env.SLACK_WEBHOOK }}\n# Update security_team to match your organization\nsecurity_team: 'my-org/app-sec'\nautomations:\nflag_merged_no_review:\nif:\n- {{ pr.approvals | length == 0 }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"DCF5-merged-without-review\"\ncolor: {{ colors.red }}\n- action: send-slack-message@v1\nargs:\nmessage: \"PR #{{ pr.number }} - {{ pr.title }} - was merged without peer reviews. SOC2 requires code reviews for every code change. _SOC2 ref: CC8.1_\"\nwebhook_url: \"{{ slack_webhook }}\"\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR was merged without peer reviews. SOC2 requires code reviews for every code change.\n_SOC2 ref: CC8.1_\n@{{ security_team }}\ncolors:\nred: 'F6443B'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/soc2/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p>"},{"location":"integrations/sonar/","title":"Integrate gitStream with SonarCloud","text":"<p>Included with gitStream Core Functionality</p> <p>This integration is part of gitStream core functionality, and requires no additional configuration.</p>"},{"location":"integrations/sonar/#automation-examples","title":"Automation Examples","text":""},{"location":"integrations/sonar/#approve-sonar-clean-code","title":"Approve Sonar Clean Code","text":"<p>Approve PRs that pass SonarCloud's quality gate.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>SonarCloud reports an 'A' rating for vulnerabilities, bugs, security hotspots, and code smells.</li> <li>There is no duplicated code.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>Sonar: Clean Code</code> label to the PR.</li> <li>Approve the PR.</li> <li>Post a comment that explains why the PR was approved.</li> </ul> <p>Aprove Sonar Clean Code</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_sonar_clean_code:\nif:\n- {{ sonar.bugs.rating == 'A' }}\n- {{ sonar.code_smells.rating == 'A' }}\n- {{ sonar.vulnerabilities.rating == 'A' }}\n- {{ sonar.security_hotspots.rating == 'A' }}\n- {{ sonar.duplications == null or sonar.duplications == 0 }}\nrun: - action: add-label@v1\nargs:\nlabel: '\u2705 Sonar: Clean Code'\ncolor: {{ colors.green }}\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR passes the SonarCloud quality gate check and as been automatically approved.\nsonar: {{ pr | extractSonarFindings }}\ncolors:\ngreen: '0e8a16'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/sonar/#label-sonarcloud-quality-reports","title":"Label SonarCloud Quality Reports","text":"<p>Label the number of bugs, vulnerabilities, security hotspots, and code smells reported by SonarCloud.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>There is at least one vulnerability, code smell, security hotspot, or bug reported by SonarCloud. Uses the <code>extractSonarFindings</code> filter function</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply color-coded labels to indicate the number of vulnerabilities, code smells, security hotspots, and bugs.</li> </ul> <p>Label SonarCloud Quality Reports</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in reports %}\nlabel_sonar_{{ item.name }}:\nif:\n- {{ item.count &gt; 0}}\nrun:\n- action: add-label@v1\nargs:\nlabel: '{{ item.icon }} sonar:{{ item.name }}-{{ item.rating }}'\ncolor: {{ colors.red if (item.rating == 'E' or item.rating == 'D') else (colors.orange if (item.rating == 'C' ) else colors.yellow) }}\n{% endfor %}\nsonar: {{ pr | extractSonarFindings }}\nreports:\n- name: vulnerabilities\ncount: {{ sonar.vulnerabilities.count }}\nicon: \ud83d\udd13\nrating: {{ sonar.vulnerabilities.rating }}\n- name: code_smells\ncount: {{ sonar.code_smells.count }}\nicon: \u2623\ufe0f\nrating: {{ sonar.code_smells.rating }}\n- name: security_hotspots\ncount: {{ sonar.security_hotspots.count }}\nicon: \ud83d\udee1\ufe0f\nrating: {{ sonar.security_hotspots.rating }}\n- name: bugs\ncount: {{ sonar.bugs.count }}\nicon: \ud83e\udeb2\nrating: {{ sonar.bugs.rating }}\ncolors:\nred: 'b60205'\norange: 'd93f0b'\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/sonar/#review-sonar-duplications","title":"Review Sonar Duplications","text":"<p>Request changes when Sonar reports an excessive level of duplicated code.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains more than 3% duplicated code.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a label that indicates how much duplicated code Sonar detected.</li> <li>Request changes and post a comment explaining why.</li> </ul> <p>Review Sonar Duplications</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_sonar_duplications:\nif:\n- {{ sonar.duplications &gt; 3 }}\nrun: - action: add-label@v1\nargs:\nlabel: 'Sonar: {{ sonar.duplications}}% duplication'\ncolor: {{ colors.yellow }}\n- action: request-changes@v1\nargs:\ncomment: |\nSonar reports an excessive level of code duplication. Please consider refactoring your PR to reduce duplications.\nsonar: {{ pr | extractSonarFindings }}\ncolors:\nyellow: 'fbca04'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/sonar/#review-sonar-security-alerts","title":"Review Sonar Security Alerts","text":""},{"location":"integrations/sonar/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/swimm/","title":"Integrate gitStream with Swimm","text":""},{"location":"integrations/swimm/#approve-swimm-changes","title":"Approve Swimm Changes","text":""},{"location":"integrations/swimm/#approve-swimm-changes_1","title":"Approve Swimm Changes","text":"<p>Approve changes that only affect Swimm documentation.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR only affects files that end in a <code>.swm</code> extension.</li> </ul> <p>Automation Actions:</p> <ul> <li>Add a <code>swimm-docs-only</code> label</li> <li>Approve the PR</li> <li>Post a comment that explains that this is a Swimm docs change only.</li> </ul> <p>Approve Swimm Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\napprove_swimm_changes:\n# Triggered for any changes to Swimm documentation\nif:\n- {{ branch.diff.files_metadata | match(attr='file', regex=r/\\.swm\\//) | every }}\n# Apply a swimm-docs-only label, approve the PR and explain why in a comment.\nrun: - action: add-label@v1\nargs:\nlabel: 'swimm-docs-only'\n- action: approve@v1\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR is considered a safe change as it only affects Swimm Docs. \nIt has been automatically approved.\n</code></pre>  Download this example as a CM file. <p>Special thanks to Omerr for providing this example. </p>"},{"location":"integrations/teams/","title":"Integrate gitStream with Microsoft Teams","text":"<p>This page demonstrates uses cases for how to connect gitStream to Microsoft Teams to post messages via webhooks.</p>"},{"location":"integrations/teams/#prerequisite-configurations","title":"Prerequisite Configurations","text":"<p>To use gitStream with MS Teams, you first need to do two things:</p> <ol> <li>Create an incoming webhook in Teams.</li> <li>Provide your Teams webhook URL to gitStream as an organization environment variable.</li> </ol>"},{"location":"integrations/teams/#set-up-incoming-webhooks-in-teams","title":"Set Up Incoming Webhooks in Teams","text":"<p>Microsoft Teams can accept incoming webhooks to send fully-featured messages to channels and individuals. Here\u2019s the complete tutorial from Microsoft.</p> <p>Here is an overview of the process:</p> <p>Step 1: Add the Incoming Webhook connector inside MS Teams.</p> <p></p> <p>Step 2: Give it a name and an image so your teammates can identify it easily and click create.</p> <p></p> <p>Once created, copy the webhook URL, you'll need this in the next step.</p> <p>Your webhook URL is secret information!</p> <p>Teams webhook URLs allow anyone with access to the URL to post to the channel its configured for. Do not publish this URL to public locations.</p>"},{"location":"integrations/teams/#configure-gitstream-environment-variable","title":"Configure gitStream Environment Variable","text":"<p>gitStream can access GitHub orgnization secrets as environment variables, and you'll need to do this to provide gitStream with access to your Slack webhook URL. </p> <ol> <li>Create an organization secret in GitHub and ensure it isn't being overridden by a repo-level secret of the same name.</li> <li>Pass the organization secret to gitStream as an environment variable in your <code>gitstream.yml</code> workflow file. We recommend using an easy to understand term like <code>MS_TEAMS_WEBHOOK_CHANNEL_NAME</code>.</li> </ol> <p></p>"},{"location":"integrations/teams/#how-to-send-microsoft-teams-messages-from-gitstream","title":"How to Send Microsoft Teams Messages From gitStream","text":"<p>Example</p> <p>To send Teams messages from gitStream, use the <code>send-http-request</code> automation action and pass the value you stored your webhook URL to the <code>url</code> argument.</p> <pre><code>automations:\nsend_teams_message:\nif:\n- true\nrun:\n- action: send-http-request@v1\nargs:\nmethod: \"POST\"\nheaders: '{\"Content-type\": \"application/json\"}'\nurl: \"{{ env.MS_TEAMS_WEBHOOK }}\"\nbody: '{\"text\": \"Hello, world!\"}'\n</code></pre>"},{"location":"integrations/teams/#auto-recognition-for-meeting-team-goals","title":"Auto-Recognition For Meeting Team Goals","text":"<p>A good choice to reward developers for submitting great PRs would be to automate an MS Teams message that gives the developer recognition among their colleagues. To do this, you\u2019ll need to create a MS Teams webhook that sends to a channel full of reviewers, managers, and anybody else who should see the recognition.</p> <p>Automatic MS Teams Recognition</p> <p>Automatically post positive recognition messages in MS Teams for well-structured PRs.</p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains updates to tests.</li> <li>The PR has fewer than 5 modified files.</li> <li>The PR branch references a Jira ticket.</li> <li>The PR has fewer than 150 lines of code changed.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post an MS Teams message that automatically recognizes the PR author and provides a link to the PR.</li> </ul> <p>Automatic MS Teams Notifications</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nteams_auto_recognition:\nif:\n- {{ files | match(regex=r/(test|spec)/) | some }} # this pr has at least 1 test\n- {{ files | length &lt;= 5 }} # this pr has 5 or less files\n- {{ branch.name | includes(regex=r/[A-Z]{2,}-\\d+.*/) }} # this branch has the Jira ticket prefix\n- {{ branch.diff.size &lt;= 150 }} # this branch has 150 lines of code or less changed\nrun:\n- action: send-http-request@v1\nargs:\nmethod: \"POST\"\nheaders: '{\"Content-type\": \"application/json\"}'\nurl: \"{{ env.MS_TEAMS_WEBHOOK }}\"\nbody: '{\"text\": \"Congrats to {{ pr.author }} for the amazing new PR, {{ pr.title }}! Check it out at https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"}'\n</code></pre>  Download this example as a CM file. </p>"},{"location":"integrations/teams/#message-specific-teams-based-on-pr-content","title":"Message Specific Teams Based on PR content","text":"<p>You can also use the Slack integration to automatically keep in touch with code owners and others who should be connected to the PR. You could check for certain conditions that require a more personal review from an experienced maintainer, like:</p> <ul> <li>Will the PR take too long to review?</li> <li>Did SonarCloud find vulnerabilities?</li> <li>Is this the author\u2019s first commit or are they new to the codebase?</li> <li>Is this an automated PR that for some reason didn\u2019t pass the automatic approval tests?</li> </ul> <p>On the other hand, some PRs might not have anything wrong, but still need to be assigned to a certain team based on expertise. In that case, you could set up several Teams automation actions at once, all with different webhooks and conditions. In an organization with different secrets for Teams webhooks to the <code>#security-team</code> channel, the <code>#qa-team</code> channel, and the <code>#docs-team</code> channel.</p> <p>MS Teams Channels Notifications</p> <p>Automatically send Slack notifications to specific channels based on the contents of a pull request.</p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR meets one or more of the specified trigger criteria for MS Teams notifications.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post an MS Teams message based on the contents of the PR.</li> </ul> <p>Automatically Notify MS Teams Channels</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nsend_teams_security:\nif:\n# use your custom logic here to determine whether this needs a security review\n- true\nrun:\n- action: send-http-request@v1\nargs:\nmethod: \"POST\"\nheaders: '{\"Content-type\": \"application/json\"}'\nurl: \"{{ env.MS_TEAMS_WEBHOOK_SECURITY }}\"\nbody: '{\"text\": \"A PR requires a security review. See https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"}'\nsend_teams_qa:\nif:\n# use your custom logic here to determine whether this needs a qa review\n- {{ not (files | match(regex=r/(test|spec)/) | some) }}\nrun:\n- action: send-http-request@v1\nargs:\nmethod: \"POST\"\nheaders: '{\"Content-type\": \"application/json\"}'\nurl: \"{{ env.MS_TEAMS_WEBHOOK_QA }}\"\nbody: '{\"text\": \"A PR was submitted without tests. See https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"}'\nsend_teams_docs:\nif:\n# use your custom logic here to determine whether this needs a docs review\n- {{ files | match(regex=r/(docs)/) | some }}\nrun:\n- action: send-http-request@v1\nargs:\nmethod: \"POST\"\nheaders: '{\"Content-type\": \"application/json\"}'\nurl: \"{{ env.MS_TEAMS_WEBHOOK_DOCS }}\"\nbody: '{\"text\": \"A PR has modified the docs. See https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"}'\n</code></pre>  Download this example as a CM file. </p> <p>Using this template and custom logic specific to your company, you can build a complete repo management system that gets the right people actively involved by pinging them where they are in Teams.</p>"},{"location":"integrations/teams/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/terraform/","title":"Integrate gitStream with Terraform","text":""},{"location":"integrations/terraform/#automation-examples","title":"Automation Examples","text":""},{"location":"integrations/terraform/#review-terraform-changes","title":"Review Terraform Changes","text":"<p>Automatically assign <code>org/infrastructure</code> team for reviewing changes when PR contains Terraform file changes.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains changes to one or more Terraform configuration files.</li> </ul> <p>Automation Actions:</p> <ul> <li>Require a review from the org/infrastructure team.</li> </ul> <p>Review Terraform Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_terraform:\n# Triggered for any changes to Terraform files\nif:\n- {{ files | match(regex=r/.*\\.tf.*/) | some }}\n# Assign infrastructure team as reviewer for change in Terraform files\nrun:\n- action: require-reviewers@v1\nargs:\nreviewers: [org/infrastructure]\n- action: add-comment@v1\nargs:\ncomment: |\nThis PR affects Terraform configurations and requires a review from the Infra team.\n</code></pre>  Download this example as a CM file."},{"location":"integrations/terraform/#enforce-requirements-for-new-terraform-modules","title":"Enforce Requirements for New Terraform Modules","text":"<p>Request changes if a PR that creates a new Terraform module which do not conform to the required directory structure.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates a new Terraform module<ul> <li>A new sub-directory is created inside the <code>/modules</code> directory.</li> </ul> </li> <li>The PR lacks one or more required components from the list in the terraform custom expression.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request changes and post a comment explaining the missing parts of the module.</li> <li>Apply Label : <code>\u26a0\ufe0f Missing Terraform Components</code></li> </ul> <p>Review New Module</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\n{% set misslist = [] %}\n{% for pattern in terraform %}\n{% if (newfilesinpr | match(term=pattern) | nope) %}\n{% set misslist = misslist + [pattern+' '] %}\n{% endif %}\n{% endfor %} automations:\nreview_new_terraform_module:\nif: - {{misslist | match(regex=r/.*/) | some}}\n- {{is.mainfile and is.mainfilenotinroot }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nNew terraform modules must contain all required components before merging. Please update your PR with the required components and gitStream will automatically remove this comment once completed.\nHere are the required components, {{misslist}} should be customized appropriately:\nmy_module/\n\u251c\u2500\u2500 main.tf\n\u251c\u2500\u2500 outputs.tf\n\u251c\u2500\u2500 providers.tf\n- action: add-label@v1\nargs:\nlabel: '\u26a0\ufe0f Missing Terraform Components'\ncolor: '#FFA500'\nresources:\nmodule_directory: 'modules'\nterraform:\n- main.tf\n- outputs.tf\n- providers.tf\nis:\nmainfile: {{newfilesinpr | match(term = \"main.tf\") | some}}\nmainfilenotinroot: {{source.diff.files | map(attr='original_file') | match(term = \"main.tf\") | nope }}\nnewfilesinpr:\n{{ branch.diff.files_metadata | map(attr='new_file')}}\n</code></pre>  Download this example as a CM file."},{"location":"integrations/terraform/#ensure-terraform-source-urls-have-version-numbers","title":"Ensure Terraform Source URLs have version numbers","text":"<p>Ensure that all Terraform modules imported via a source URL specify a version.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains a Terraform source declaration via URL that lacks a version reference.</li> <li>The source is not included in a whitelist custom expression that defines one or more whitelisted source locations.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request review changes on the PR with a comment explaining version number requirement.</li> </ul> <p>Review Terraform Changes</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nreview_terraform_source_version:\n# Check if New Content contains a source URL, the URL is not part of allow list and lacks version reference\nif: - {{ source.diff.files | match(attr='new_content', regex=r/source.*?=.*\\\".*(http|https).*\\\"/) | some }}\n- {{ source.diff.files | match(attr='new_content', list=allowlist) | nope }}\n- {{ source.diff.files | match(attr='new_content', regex=r/source.*?=.*\\?ref=v.*/) | nope }}\nrun:\n- action: request-changes@v1\nargs:\ncomment: |\nYou must reference a specific version when accessing Terraform module sources via URL, e.g. `?ref=v1.0.0`. Please update your Terraform files to follow this practice.\nallowlist:\n- 'https://github.com/terraform-aws-modules/terraform-aws-s3-bucket.git'\n- 'https://github.com/terraform-aws-modules/terraform-aws-vpc.git'\n- 'https://github.com/terraform-aws-modules/terraform-aws-eks.git'\n</code></pre>  Download this example as a CM file."},{"location":"integrations/terraform/#ensure-new-terraform-modules-conform-to-a-naming-pattern","title":"Ensure New Terraform Modules conform to a Naming Pattern","text":"<p>Request changes if a PR creates a new Terraform module that is missing a required prefix or keyword in the name.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR creates a new Terraform module.</li> <li>The module name lacks a required name prefix, or one or more keywords.</li> </ul> <p>Automation Actions:</p> <ul> <li>Request review changes on the PR with a comment explaining the structure of module name.</li> </ul> <p>Review Terraform Module Name</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\n# Prefix Check Logic\n{% set prefixcheck = [] %}\n{% for pattern in terraform.prefixes %}\n{% if(newfilesinpr | match(term=module_location + pattern) | some) %}\n{% set prefixcheck = prefixcheck + [true]%}\n{% else %}\n{% set prefixcheck = prefixcheck + [false]  %}\n{% endif %}\n{% endfor %}\nautomations:\nreview_terraform_module_name:\nif:\n- {{is.mainfile and is.mainfilenotinroot}}\n- {{module_name_checks.prefix or module_name_checks.keyword}}\nrun:\n- action: request-changes@v1\nargs:\ncomment: |\nTerraform module names must contain a required prefix and keyword:\n* Prefixes: {{ terraform.prefixes }}\n* Keywords: {{ terraform.keywords }}\nmodule_name_checks:\nprefix: {{prefixcheck | match(term='true') | nope}}\nkeyword: {{newfilesinpr | match(list=terraform.keywords) | nope}}\nmodule_location: infrastructure/modules/\nterraform:\nprefixes: ['aws', 'gcp', 'azure']\nkeywords: ['db', 'networking', 'security']\nis:\nmainfile: {{newfilesinpr | match(term = \"main.tf\") | some}}\nmainfilenotinroot: {{source.diff.files | map(attr='original_file') | match(term = \"main.tf\") | nope }}\nnewfilesinpr:\n{{ branch.diff.files_metadata | map(attr='new_file')}}\n</code></pre>  Download this example as a CM file."},{"location":"integrations/terraform/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/unleash/","title":"Integrate gitStream with Unleash","text":""},{"location":"integrations/unleash/#label-unleash-feature-flags","title":"Label Unleash Feature Flags","text":"<p>Automatically label code that contians specified feature flags.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR adds one or more feature flag keys.</li> </ul> <p>Automation Actions:</p> <ul> <li>Label the PR for each feature flag key introduced in the PR.</li> </ul> <p>Label PRs Based on Feature Flags</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n{% for item in feature_flags %}\nlabel_ff_unleash_{{ item.name }}:\nif:\n- {{ source.diff.files | matchDiffLines(regex=r/const notificationBadgeEnabled = useFlag/) | some }}\n- {{ source.diff.files | matchDiffLines(regex=item.regex) | some }}\nrun:\n- action: add-label@v1\nargs:\nlabel: {{ item.name }}\ncolor: {{ colors.yellow }}\n{% endfor %}\nfeature_flags:\n- name: engineering_rollback_plan_activated regex: r/engineering_rollback_plan_activated/\n- name: marketing_premium_plan_features_unlocked regex: r/marketing_premium_plan_features_unlocked/\n- name: mobile_push_notifications_enabled\nregex: r/mobile_push_notifications_enabled/\ncolors:\nyellow: 'ffb300'   </code></pre>  Download this example as a CM file."},{"location":"integrations/unleash/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/windsurf/","title":"Integrate gitStream with Windsurf","text":""},{"location":"integrations/windsurf/#automatically-label-windsurf-assisted-prs","title":"Automatically Label Windsurf-Assisted PRs","text":"<p>Automatically apply labels to PRs that are assisted by Windsurf. You can apply labels based on a known list of Windsurf users, PR tags, or by prompting the PR author to indicate if they used Windsurf.</p> Label by PromptLabel by Known UsersLabel by Tag <p>Prompt PR authors to indicate if they used Windsurf for the PR and automatically label the PR if they did. This requires two separate automation files to handle posting the prompt and labeling accordingly.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is created</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment prompting the author to indicate if Windsurf assisted the author with writing the code in the PR.</li> </ul> <p>Ask the PR author about Windsurf usage</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\nautomations:\ncomment_windsurf_prompt:\n# Post a comment for all PRs to prompt the PR author to indicate whether they used Windsurf to assist coding in this PR\nif:\n- true\nrun:\n- action: add-comment@v1\nargs:\ncomment: |\nPlease mark whether you used Windsurf to assist coding in this PR\n- [ ] Windsurf Assisted\n- [ ] Not Windsurf Assisted \n</code></pre>  Download this example as a CM file. </p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>A PR is updated or merged where the author indicates they used Windsurf via a prompt.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Windsurf</code> label to the PR</li> </ul> <p>Label PRs where the user indicated Windsurf usage</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\n# You should use this automation in conjunction with comment_windsurf_prompt.cm\nlabel_windsurf_pr:\n# If the PR author has indicated that they used Windsurf to assist coding in this PR, \n# apply a label indicating the PR was supported by Windsurf\nif:\n- {{ pr.comments | filter(attr='commenter', term='gitstream-cm') | filter (attr='content', regex=r/\\- \\[x\\] Windsurf Assisted/) | some}}\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Windsurf' </code></pre>  Download this example as a CM file. </p> <p>Automatically apply labels to PRs that are created by known users of generative AI coding tools.</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The PR author is one of a specified list of contributors</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Windsurf</code> label to the PR</li> </ul> <p>Label by Contributors</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_windsurf_contributors:\n# For all PRs authored by someone who is specified in the windsurf_contributors list\nif:\n- {{ pr.author | match(list=windsurf_contributors) | some }}\n# Apply a label indicating the user has adopted Windsurf\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Windsurf'\nwindsurf_contributors:\n- username1\n- username2\n- etc </code></pre>  Download this example as a CM file. </p> <p>Look for a specific tag in the PR title, description, comments or commit messages and if found add a label to the PR</p> <p></p> <p>Configuration Description</p> <p>Conditions:</p> <ul> <li>The <code>#windsurf#</code> tag is found in any of the PR title, description, comments or commit messages for commits in the PR</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>\ud83e\udd16 Windsurf</code> label to the PR</li> </ul> <p>Label Windsurf by Tag</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- comment_added\n- commit\n- pr_created\nautomations:\nlabel_windsurf:\n# Detect PRs that contain the text '#windsurf#' in the title, description, comments, or commit messages\nif:\n- {{ windsurf_tag.pr_title or windsurf_tag.pr_desc or windsurf_tag.pr_comments or windsurf_tag.commit_messages }}\n# Apply a label indicating the user has adopted Windsurf\nrun:\n- action: add-label@v1\nargs:\nlabel: '\ud83e\udd16 Windsurf'\nwindsurf_tag:\npr_title: {{ pr.title | includes(regex=r/#windsurf#/) }}\npr_desc: {{pr.description | includes(regex=r/#windsurf#/) }}\npr_comments: {{ pr.comments | map(attr='content') | match(regex=r/#windsurf#/) | some }}\ncommit_messages: {{ branch.commits.messages | match(regex=r/#windsurf#/) | some }} </code></pre>  Download this example as a CM file. </p>"},{"location":"integrations/windsurf/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/zapier/","title":"Integrate gitStream with Zapier","text":"<p>Zapier is a workflow automation tool that connects to more than 7,000 apps and APIs and allows you to pass data between them using processes called Zaps. After something triggers the Zap, it\u2019ll sequentially call the different pieces of your workflow. </p>"},{"location":"integrations/zapier/#prerequisite-configurations","title":"Prerequisite Configurations","text":"<p>To use gitStream with Zapier, you first need to do two things:</p> <ol> <li>Create a Zap with incoming webhooks enabled.</li> <li>Provide your Zapier webhook URL to gitStream as an organization environment variable.</li> </ol>"},{"location":"integrations/zapier/#setup-incoming-webhooks-in-zapier","title":"Setup Incoming Webhooks in Zapier","text":"<p>Premium Zapier Subscription Required.</p> <p>As of December 2023, Zapier\u2019s Incoming Webhooks app is only available to premium members.</p> <p>Get started by signing into Zapier and clicking Create Zap:</p> <p></p> <p>Then, select the trigger and find the latest version of the Webhooks by Zapier app:</p> <p></p> <p>Choose Catch Hook (to pass JSON data from gitStream to Zapier), but don\u2019t add any child key (so the root object you send is parsed by Zapier). Then copy the URL it gives you and proceed to the next step</p> <p>Your webhook URL is secret information!</p> <p>Zapier webhook URLs allow anyone with access to the URL to use it. Do not publish this URL to public locations.</p>"},{"location":"integrations/zapier/#configure-environment-variable","title":"Configure Environment Variable","text":"<p>gitStream can access GitHub orgnization secrets as environment variables, and you'll need to do this to provide gitStream with access to your Slack webhook URL. </p> <ol> <li>Create an organization secret in GitHub and ensure it isn't being overridden by a repo-level secret of the same name.</li> <li>Pass the organization secret to gitStream as an environment variable in your <code>gitstream.yml</code> workflow file. We recommend using an easy to understand term like <code>ZAPIER_WEBHOOK</code>.</li> </ol> <p>You should now be ready to send data from gitStream to Zapier.</p>"},{"location":"integrations/zapier/#export-pr-data-to-zapier","title":"Export PR Data to Zapier","text":"<p>In your <code>.cm</code> file, you can include an automation that sends data to Zapier. Likely, you won\u2019t be using exactly the workflow that we\u2019re demonstrating here, but that\u2019s alright; you can send any of the context variables in the body of the request for you to make use of in your Zap. It\u2019s best practice to only send as much information as you need, so avoid sending unecessary data.</p> <p>A Simple Zapier Example</p> <p>This is an example of how to send data from gitStream to Zapier.</p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created.</li> </ul> <p>Automation Actions:</p> <ul> <li>gitStream sends a webhook to Zapier that contains the PR number</li> </ul> <p>Export PR Number to Zapier</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nzapier_export_pr_number:\nif:\n- true\nrun:\n- action: send-http-request@v1\nargs:\nurl: \"{{ ZAPIER_WEBHOOK }}\"\nmethod: POST\nheaders: '{\"Content-type\": \"application/json\"}'\nbody: '{ \"pr_number\":\"{{ pr.number }}\" }'\n</code></pre>  Download this example as a CM file. </p>"},{"location":"integrations/zapier/#store-pr-data-in-a-table","title":"Store PR Data in a Table","text":"<p>Zapier can store data it gets from incoming webhooks in its internal database. In Zapier, click on the menu on the left side and select Tables. Then, create a new table called PRs with fields <code>PR number</code>, <code>PR title</code>, and <code>PR URL</code>, with types <code>Number</code>, <code>Text</code>, and <code>Link</code> respectively:</p> <p></p> <p>Return to the home page and create a new Zap following the instructions above, with twos changes. First, the webhook should only be run when the PR is created. Notice the <code>on</code> condition in the new <code>.cm</code> file below. Also, you\u2019ll notice the example sends additional data points. This could be any data you want; gitStream makes numerous useful resources available via context variables.</p> <p>Storing PR Data in a Table</p> <p>Export new PR titles, numbers, and URLs to Zapier.</p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created.</li> </ul> <p>Automation Actions:</p> <ul> <li>gitStream sends the PR number, title, and URL to Zapier via webhook.</li> </ul> <p>Export PR Number, Title, and URL to Zapier</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\npr_url: \"https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"\non:\n- pr_created\nautomations:\nzapier_export_pr_number_title_url:\nif:\n- true\nrun:\n- action: send-http-request@v1\nargs:\nurl: \"{{ ZAPIER_WEBHOOK }}\"\nmethod: POST\nheaders: '{\"Content-type\": \"application/json\"}'\nbody: '{ \"pr_number\":\"{{ pr.number }}\", \"pr_title\":\"{{ pr.title }}\", \"pr_url\":\"{{ pr_url }}\" }'\n</code></pre>  Download this example as a CM file. </p> <p>After the webhook triggers, use the Tables app in the Zap to create a new record in your PR table with the available data.</p> <p></p> <p>Then, PRs will start showing up in the table as they\u2019re created:</p> <p></p> <p>Now, you can integrate this PR data into the rest of your workflow! You could expand on this, adding date and status information so that other applications could automatically injest this data.</p>"},{"location":"integrations/zapier/#create-project-management-tasks-from-prs","title":"Create Project Management Tasks From PRs","text":"<p>The next example follows similar conventions as the last, except this on includes the PR description instead of the number:</p> <p>Create PM Tasks From PR Data</p> <p>Export new PR titles, description, and URL to Zapier.</p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created.</li> </ul> <p>Automation Actions:</p> <ul> <li>gitStream sends a webhook to Zapier that contains the PR title, description, and URL.</li> </ul> <p>Create Project Management Tasks Via Zapier</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\npr_url: \"https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"\non:\n- pr_created\nautomations:\nzapier_export_pr_description_title_url:\nif:\n- true\nrun:\n- action: send-http-request@v1\nargs:\nurl: \"{{ ZAPIER_WEBHOOK }}\"\nmethod: POST\nheaders: '{\"Content-type\": \"application/json\"}'\nbody: '{ \"pr_description\":\"{{ pr.description }}\", \"pr_title\":\"{{ pr.title }}\", \"pr_url\":\"{{ pr_url }}\" }'\n</code></pre>  Download this example as a CM file. </p> <p>Now, in the Zap,you can pass this data to Trello to create a new task on the QA board. First, add the Trello app, select the Create Card event, and connect your Trello account. Then, you can build the card according to the information from gitStream:</p> <p></p> <p>This example puts the task in a the 'To Do\" column of the QA tasklist to make it easy for QA engineers to take it from there. The title, description and URL are all formatted to fit into Trello.</p> <p></p>"},{"location":"integrations/zapier/#automatically-schedule-sync-meetings","title":"Automatically Schedule Sync Meetings","text":"<p>The next example can help if you're responsible for all the PR reviews that come in. You might want to schedule a synchronous group meeting for the last half hour of every day for all of that day\u2019s PRs to be reviewed. Everyone assigned to review a PR that day is invited. gitStream and Zapier can help build those meetings, invite all the right people automatically, and skip the meeting altogether if it\u2019s not necessary.</p> <p>Start with this CM example:</p> <p>Send PR Reviewer Info to Zapier</p> <p>Automatically update Zapier with a list of PR reviewers.</p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created or updated.</li> </ul> <p>Automation Actions:</p> <ul> <li>gitStream sends the list of reviewers to Zapier via webooks.</li> </ul> <p>Auto-Schedule Sync Meetings via Zapier</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\npr_url: \"https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"\nautomations:\nzapier_export_pr_reviewers:\nif:\n- true\nrun:\n- action: send-http-request@v1\nargs:\nurl: \"{{ env.ZAPIER_WEBHOOK }}\"\nmethod: \"POST\"\nheaders: '{\"Content-type\": \"application/json\"}'\nbody: '{ \"reviewers\": \"{{ pr.reviewers }}\" }'\n</code></pre>  Download this example as a CM file. </p> <p>Then in Zapier, set up a Zap like this:</p> <p></p> <p>In the second piece of the Zap, you can write JavaScript (or Python) to format whatever you get from gitStream. If you return an array of the reviewer usernames, Zapier will run the rest of the steps of the Zap *once per reviewer*, which is what you want. Zapier also has a built-in lookup table you can use, but this example will use a Google Sheet for simplicity.</p> <p></p> <p>In the Find Event action of the Google Calendar app, search for the daily standup and create one if it doesn\u2019t yet. If you set the new event not to repeat, then the standup will only be created when you have PRs to review. Just make sure the search term and the title of the new event match:</p> <p></p> <p></p> <p>Lastly, search for the new calendar entry with the Add Attendee/s to Event action, and add the reviewer\u2019s email as an attendee. Remember, this will run *for each reviewer* so you only need to build out this linear path.</p> <p>Once you\u2019re done, you\u2019ll have your standup automatically added to the schedule whenever it\u2019s needed:</p> <p></p>"},{"location":"integrations/zapier/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/golang/golang-testing-automations/","title":"Golang Testing Automations","text":""},{"location":"integrations/golang/golang-testing-automations/#review-missing-golang-tests","title":"Review Missing Golang Tests","text":""},{"location":"integrations/golang/golang-testing-automations/#review-python-golang-test-name","title":"Review Python Golang Test Name","text":"<p>Special thanks to Boemo W Mmopelwa for providing these examples.</p>"},{"location":"integrations/html/html-css-automations/","title":"HTML/CSS Automations","text":""},{"location":"integrations/html/html-css-automations/#flag-missing-html-tags","title":"Flag Missing HTML Tags","text":""},{"location":"integrations/html/html-css-automations/#flag-duplicate-h1","title":"Flag Duplicate H1","text":""},{"location":"integrations/html/html-css-automations/#enforce-html-title-length-requirements","title":"Enforce HTML Title Length Requirements","text":""},{"location":"integrations/html/html-css-automations/#enforce-image-alt-attributes","title":"Enforce Image Alt Attributes","text":"<p>Special thanks to Boemo W Mmopelwa for providing these examples.</p>"},{"location":"integrations/java/java-testing-automations/","title":"Java Testing Automations","text":""},{"location":"integrations/java/java-testing-automations/#review-missing-java-tests","title":"Review Missing Java Tests","text":""},{"location":"integrations/java/java-testing-automations/#review-python-java-test-name","title":"Review Python Java Test Name","text":"<p>Special thanks to Boemo W Mmopelwa for providing these examples.</p>"},{"location":"integrations/javascript/javascript-testing-automations/","title":"JavaScript Testing Automations","text":""},{"location":"integrations/javascript/javascript-testing-automations/#review-missing-javascript-tests","title":"Review Missing JavaScript Tests","text":""},{"location":"integrations/javascript/javascript-testing-automations/#review-python-javascript-test-name","title":"Review Python JavaScript Test Name","text":"<p>Special thanks to Boemo W Mmopelwa for providing these examples.</p>"},{"location":"integrations/jira/","title":"Integrate gitStream with Jira","text":"<p>gitStream makes it easy to build workflows that link your GitHub repo to your Jira workspace. Automatically update Jira issues, enforce Jira best-practices, and reduce the amount of context switching developers experience by reducing their need to interact with third-party project management tools. </p>"},{"location":"integrations/jira/#automation-examples","title":"Automation Examples","text":""},{"location":"integrations/jira/#label-missing-jira-info","title":"Label Missing Jira Info","text":"<p>Label PRs that don't reference a Jira ticket in the title or description. This uses regex to detect Jira ticket formats in the title (e.g. ABC-1234), and URLs to Jira tickets in the description.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR lacks a Jira ticket number in the title, or a link to a Jira ticket in the PR description.</li> </ul> <p>Automation Actions:</p> <ul> <li>Apply a <code>missing-jira</code> label.</li> </ul> <p>Label Missing Jira Info</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nautomations:\nlabel_missing_jira_info:\n# Triggered for PRs that don't have either a Jira ticket number in the title,\n# or a link to a Jira ticket in the PR description.\nif:\n- {{ not (has.jira_ticket_in_title or has.jira_ticket_in_desc) }}\nrun:\n- action: add-label@v1\nargs:\nlabel: \"missing-jira\"\ncolor: 'F6443B'\nhas:\njira_ticket_in_title: {{ pr.title | includes(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\njira_ticket_in_desc: {{ pr.description | includes(regex=r/atlassian.net\\/browse\\/\\w{1,}-\\d{3,4}/) }}\n</code></pre>  Download this example as a CM file."},{"location":"integrations/jira/#automatically-link-prs-to-related-jira-issues","title":"Automatically Link PRs to Related Jira Issues","text":"<p>Provide automatic links to Jira issues that are associated with PRs.</p> <p></p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR contains a reference to an Jira card in the title or branch name.</li> </ul> <p>Automation Actions:</p> <ul> <li>Post a comment that provides a link to the associated Jira Card.</li> </ul> <p>Automatically Link to the Related Jira Card</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nprovider: jira\n# Change this to the name of your Jira organization\norgName: org\n{% set ticketid = \"\" %}\n{% for ticket in tickets %}\n{% if (ticket | includes(regex=r/.+/)) %}\n{% set ticketid = ticket %}\n{% endif %}\n{% endfor %}\nautomations:\nlink_jira:\nif:\n- {{ has.ticket_in_title or has.ticket_in_branch }}\nrun:\n- action: add-comment@v1\nargs:\ncomment: Issue Tracker Link - [{{ticketid}}]({{tracker[provider].baseurl}}{{ticketid}})\nhas:\nticket_in_title: {{ pr.title | includes(regex=tracker[provider].pattern) }}\nticket_in_branch: {{ branch.name | includes(regex=tracker[provider].pattern) }}\ntracker:\njira:\nbaseurl: https://{{orgName}}.atlassian.net/browse/\npattern: r/\\b[A-Za-z]+-\\d+\\b/\ntickets:\n- {{branch.name | capture(regex=tracker[provider].pattern)}}\n- {{pr.title | capture(regex=tracker[provider].pattern)}}\n</code></pre>  Download this example as a CM file."},{"location":"integrations/jira/#update-jira-fields-when-prs-are-created","title":"Update Jira Fields When PRs are Created","text":"<p>Automatically update Jira tickets with pull request information. You can modify this to send any PR metadata to Jira. </p> <p>Jira Webhook Integration Required</p> <p>You need to configure an incoming Jira webhook to use this automation.</p> <p> </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created that contains a Jira ticket reference in the title or branch name.</li> </ul> <p>Automation Actions:</p> <ul> <li>Send a webhook to Jira containing metadata to add to the Issue.</li> </ul> <p>Automatic Jira Updates</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\n{% set ticketid = '' %}\n{% for ticket in tickets %}\n{% if ticket and ticket | length &gt; 0 and ticketid == '' %}\n{% set ticketid = ticket %}\n{% endif %}\n{% endfor %}\nautomations:\njira_update_field: if:\n- {{ has.jira_ticket_in_title or has.jira_ticket_in_branch }}\nrun:\n- action: send-http-request@v1\nargs:\nurl: \"{{ env.JIRA_UPDATE_PR_FIELD_WEBHOOK }}\"\nmethod: POST\nheaders: '{\"Content-type\": \"application/json\", \"X-Automation-Webhook-Token\": \"{{ env.JIRA_UPDATE_PR_FIELD_SECRET }}\"}'\nbody: '{\"issues\":[\"{{ticketid}}\"],\"data\":{\"pr_url\":\"https://github.com/{{repo.owner}}/{{repo.name}}/pull/{{pr.number}}\"}}'\nhas:\njira_ticket_in_title: {{ pr.title | includes(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\njira_ticket_in_branch: {{ branch.name | includes(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\ntickets:\n- {{branch.name | capture(regex=r/\\b[A-Za-z]+-\\d+\\b/)}}\n- {{pr.title | capture(regex=r/\\b[A-Za-z]+-\\d+\\b/)}}\n</code></pre>  Download this example as a CM file."},{"location":"integrations/jira/#automatically-create-jira-issues-for-new-prs","title":"Automatically Create Jira Issues for New PRs","text":"<p>Automatically create Jira tickets for new pull/merge requests.</p> <p>Jira API &amp; Webhook Integration Required.</p> <p>This automation requires you to connect to the Jira API and incoming webooks.</p> <p>Required gitStream Plugins</p> <p>This example requires you to install the <code>hasJiraIssue</code> plugin.</p> <p>Learn more about gitStream plugins.</p> <p> </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR description contains the text <code>- [x] Auto-create Jira Issue</code></li> <li>No existing Jira issues reference the PRs URL.</li> </ul> <p>Automation Actions:</p> <ul> <li>Send an HTTP request to create a new Jira issue.</li> </ul> <p>Automatically Create Jira Issues</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\n###### ** Configure This Section ** ######\n# Configure this for your Jira instance and the email associated with your API key.\n# You can safely use these values because only your API key is sensitive. \njiraSpaceName: \"my-company\" # e.g. my-company.atlassian.net\nemail: \"my.email@example.com\"\n# If you're concerned about exposing this information,\n# we recommend using environment variables for your production environment.\n# -----------\n# Pass the API token associated with the email above to gitStream via an environment variable.\njiraAuth: {{ env.JIRA_API_TOKEN }}\n# Learn more about env: https://docs.gitstream.cm/context-variables/#env\n# -----------\n# Change this to the Jira field you want to match the input string against.\njiraField: \"myField\"\n# If you want to search a custom field, you should provide the ID like so:\n# jiraField: \"cf[XXXXX]\"\n# Replace XXXXX with the ID of the custom field you want to search.\n# More information:\n# Using JQL to search the Jira API: https://support.atlassian.com/jira-service-management-cloud/docs/jql-fields/\n# How to find the ID of a custom field: https://confluence.atlassian.com/jirakb/how-to-find-any-custom-field-s-ids-744522503.html\n# -----------\n###### ** Automation ** ######\n# You may want to update the text in the comment gitStream posts;\n# otherwise, this section shouldn't need to be changed.\nprUrl: \"https://github.com/{{ repo.owner }}/{{ repo.name }}/pull/{{ pr.number }}\"\nhas_jira_issue: {{ prUrl  | hasJiraIssue(jiraAuth, jiraField, jiraSpaceName, email) }}\nautomations:\nautomatic_jira_task: if:\n- {{ not has_jira_issue }}\n- {{ pr.description | includes(regex=r/\\- \\[x\\] Auto-create Jira Task/)}}\nrun:\n- action: send-http-request@v1\nargs:\nurl: {{ env.JIRA_WEBHOOK }}\nmethod: POST\nheaders: '{\"Content-type\": \"application/json\"}'\nbody: '{\"data\":{\"pr_url\": \"{{ prUrl }}\",\"title\":\"{{ pr.title }}\"}}'\n- action: add-comment@v1\nargs:\ncomment: \"gitStream automatically created a Jira task for this PR\"\n</code></pre>  Download this example as a CM file."},{"location":"integrations/jira/#update-jira-ticket-status-when-prs-are-created","title":"Update Jira Ticket Status When PRs are Created","text":"<p>Automatically update the status of Jira tickets when a PR is opened.</p> <p>Jira Webhook Integration Required</p> <p>You need to configure an incoming Jira webhook to use this automation.</p> <p> </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>A PR is created that references a Jira ticket in the title or description.</li> </ul> <p>Automation Actions:</p> <ul> <li>Make an HTTP request to a Jira webhook that is pre-configured to update the ticket status.</li> </ul> <p>Automatic Jira Status Updates</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\non:\n- pr_created\n{% set ticketid = \"\\b[A-Za-z]+-\\d+\\b\" %}\n{% for ticket in tickets %}\n{% if (ticket | includes(regex=r/.+/)) %}\n{% set ticketid = ticket %}\n{% endif %}\n{% endfor %} automations:\njira_change_status: if:\n- {{ has.jira_ticket_in_title or has.jira_ticket_in_desc }}\nrun:\n- action: send-http-request@v1\nargs:\nurl: \"{{ env.JIRA_CHANGE_STATUS_WEBHOOK }}\"\nmethod: POST\nheaders: '{\"Content-type\": \"application/json\"}'\nbody: '{\"issues\":[\"{{ticketid}}\"],\"data\":{\"pr_url\":\"https://github.com/{{repo.owner}}/{{repo.name}}/pull/{{pr.number}}\"}}'\nhas:\njira_ticket_in_title: {{ pr.title | includes(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\njira_ticket_in_branch: {{ branch.name | includes(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\ntickets:\n- {{branch.name | capture(regex=r/\\b[A-Za-z]+-\\d+\\b/)}}\n- {{pr.title | capture(regex=r/\\b[A-Za-z]+-\\d+\\b/)}}\n</code></pre>  Download this example as a CM file."},{"location":"integrations/jira/#use-slash-commands-to-assign-tickets-in-jira","title":"Use Slash Commands to Assign Tickets in Jira","text":"<p>Automatically assign Jira tickets based on code review actions.</p> <p>Jira Webhook Integration Required</p> <p>You need to configure an incoming Jira webhook to use this automation.</p> <p> </p> <p>Configuration Description</p> <p>Conditions (all must be true):</p> <ul> <li>The PR description contains the slash command: <code>/gitstream assign-jira</code> followed by a Jira username.</li> </ul> <p>Automation Actions:</p> <ul> <li>Trigger a Jira webhook to update the assignee field with the username provided in the slash command.</li> </ul> <p>Automatically Assign Jira Tickets</p> <p><pre><code># -*- mode: yaml -*-\nmanifest:\nversion: 1.0\nassigneeRegex: r/(?&lt;=\\/gitstream assign-jira ).*(?=&lt;br \\/&gt;)/\n{% set ticketid = \"\" %}\n{% for ticket in tickets %}\n{% if (ticket | includes(regex=r/.+/)) %}\n{% set ticketid = ticket %}\n{% endif %}\n{% endfor %} automations:\njira_assign: if:\n- {{ pr.description | includes(regex=assigneeRegex) }}\nrun:\n- action: send-http-request@v1\nargs:\nurl: \"{{ env.JIRA_WEBHOOK }}}\"\nmethod: POST\nheaders: '{\"Content-type\": \"application/json\"}'\nbody: '{\"issues\":[\"{{ticketid}}\"],\"data\":{\"assignee\":\"{{pr.description | capture(regex=assigneeRegex)}}\"}}'\nhas:\njira_ticket_in_title: {{ pr.title | includes(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\njira_ticket_in_branch: {{ branch.name | includes(regex=r/\\b[A-Za-z]+-\\d+\\b/) }}\ntickets:\n- {{branch.name | capture(regex=r/\\b[A-Za-z]+-\\d+\\b/)}}\n- {{pr.title | capture(regex=r/\\b[A-Za-z]+-\\d+\\b/)}}\n</code></pre>  Download this example as a CM file."},{"location":"integrations/jira/#configure-jira-for-gitstream-integrations","title":"Configure Jira for gitStream Integrations","text":"<p>If you want to build gitStream automations to interact with the Jira API or Jira webhooks, you'll need to complete some setup in Jira, GitHub, and gitStream. This section outlines the setup process depending on the type of automation you want to build.</p> <p>These guides are for sending HTTP requests to Jira</p> <p>If the gitStream automations you want to use don't make any HTTP requests to a Jira API or webhook, you can ignore this section.</p>"},{"location":"integrations/jira/#use-webhooks-to-trigger-jira-automations","title":"Use Webhooks to Trigger Jira Automations","text":"<p>Jira automations are the preferred method for gitStream to trigger actions within Jira, so you should use them whenever possible. If webhooks don't provide access to the data you need, or acheive the functionality you want, use the Jira API instead.</p> <p>First, create a Jira automation that uses an incoming webhook as the trigger and add whatever automation components you want after this trigger. Save the webhook URL in a secure place, you'll need it later. </p> <p>Here is an example of an automation that uses the <code>webhookData</code> property of the incoming data payload to create a new task. It expects the incoming data payload to contain <code>title</code> and <code>pr_url</code> fields to set the task summary and a <code>pr_url</code> custom field our demo environment already has configured.</p> <p></p> <p> Learn more about working with incoming webhooks in the Jira docs </p> <p>Next, in GitHub, create an organization secret to store your Jira webhook URL and pass it to gitStream's <code>env</code> context variable by adding a line to <code>.github/workflows/gitstream.yml</code> inside your repo. Make sure to give this a unique name, such as <code>JIRA_CREATE_ISSUE_WEBHOOK: ${{ secrets.JIRA_CREATE_ISSUE_WEBHOOK }}</code>.</p> <p>Once finished, you can use the <code>env.JIRA_CREATE_ISSUE_WEBHOOK</code> context variable inside CM files to send HTTP requests to Jira from your GitHub repo. For an example of how to do this, check out the create Jira issue automation.</p>"},{"location":"integrations/jira/#connect-to-the-jira-api","title":"Connect to the Jira API","text":"<p>The Jira API is useful in situations where you need to retreive data from Jira or need to access capabilities that aren't available via Jira Automations. The Jira API uses an account-based token system that follows a basic auth model; this means you'll need an individual account to connect to Jira's APIs and will pass the account email address and API token in the headers of your API requests.</p> <p>Here's the process to grant gitStream access to the Jira API:</p> <ol> <li>Create an API token for your Jira account, and give it a unique name. Copy the API token, you'll need it in the next step.</li> <li>Create a GitHub organization secret to store the token and make the secret available to gitStream's <code>env</code> context variable.</li> <li>Add <code>env.MY_API_TOKEN</code> to any of your CM automations to access the API token and pass it to plugins and automation actions.</li> </ol> <p>Check out the <code>hasJiraIssue</code> filter plugin for an example of how to use Jira API tokens.</p>"},{"location":"integrations/jira/#additional-resources","title":"Additional Resources","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p> <p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"integrations/python/python-testing-automations/","title":"Python Testing Automations","text":""},{"location":"integrations/python/python-testing-automations/#review-missing-python-tests","title":"Review Missing Python Tests","text":""},{"location":"integrations/python/python-testing-automations/#review-python-test-name","title":"Review Python Test Name","text":"<p>Special thanks to Boemo W Mmopelwa for providing these examples.</p>"},{"location":"integrations/ruby/ruby-testing-automations/","title":"Ruby Testing Automations","text":""},{"location":"integrations/ruby/ruby-testing-automations/#review-missing-ruby-tests","title":"Review Missing Ruby Tests","text":""},{"location":"integrations/ruby/ruby-testing-automations/#review-python-ruby-test-name","title":"Review Python Ruby Test Name","text":"<p>Special thanks to Boemo W Mmopelwa for providing these examples.</p>"},{"location":"snippets/automation-footer/","title":"Automation footer","text":"<p>More Automations can be found on the Automation Library and Integrations pages.</p>"},{"location":"snippets/change-request-automation/","title":"Change request automation","text":"<ul> <li>Require changelog updates for PRs to specific branches</li> <li>Flag the use of deprecated APIs, functions, or other components.</li> <li>Restrict portions of your code base to authorized teams only.</li> <li>Require changes when PRs include !important tags in CSS files</li> </ul>"},{"location":"snippets/context-automation/","title":"Context automation","text":"<ul> <li>Estimate the amount of time it would require someone to complete a PR review.</li> <li>Flag missing Jira ticket information</li> <li>Label PRs that delete files.</li> <li>Label PRs that lack tests</li> <li>Provide information about what percent of a PR is new code.</li> <li>Request PR authors to provide screenshots in relevant PRs.</li> </ul>"},{"location":"snippets/general/","title":"General","text":"<p>gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity.</p> <p>Learn More about how gitStream Works.</p>"},{"location":"snippets/javascript-automation/","title":"Javascript automation","text":"<ul> <li>Automatically approve PRs that conly contain changes to JavaScript log output</li> <li>Implement custom review policies for JSDoc</li> <li>Automatically Approve non-functional formatting updates to JavaScript files</li> </ul>"},{"location":"snippets/python-automation/","title":"Python automation","text":"<ul> <li>Automatically approve PRs that only change Python log output</li> <li>Automatically approve PRs that only include non-functional Python formatting changes</li> </ul>"},{"location":"snippets/review-assignment-automation/","title":"Review assignment automation","text":"<ul> <li>Assign additional reviewers for large PRs</li> <li>Assign or suggest reviewers based on level of code expertise for the code changed in a PR.</li> <li>Assign reviewers based on modified directories and files</li> <li>Assign reviewers to share knowledge based on pre-determined criteria</li> </ul>"},{"location":"snippets/safe-merge-automation/","title":"Safe merge automation","text":"<ul> <li>Automatically approve changes to docs, tests, and other safe assets.</li> <li>Approve low-risk PRs from trusted teams.</li> <li>Approve Python or JavaScript formatting changes.</li> <li>Approve Tiny Changes</li> <li>Approve JSDoc or Javadoc changes.</li> <li>Approve and Merge Dependabot PRs</li> </ul>"},{"location":"snippets/utility-automation/","title":"Utility automation","text":"<ul> <li>An informative header you can add to your CM files to help others.</li> <li>A custom expression that makes it easy to implement color-coded labels that match the GitHub UI.</li> </ul>"}]}